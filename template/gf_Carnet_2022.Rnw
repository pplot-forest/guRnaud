\PassOptionsToPackage{svgnames}{xcolor} % permet d'éviter le clash du package xcolor (chargé avec documentclass avec l'option [])

\documentclass[a4paper,openany]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage[french,english]{babel}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[svgnames]{colortbl, xcolor}
% \usepackage{xcolor}
\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage{float} % Allows increasing the font size of specific fonts beyond LaTeX default specifications
\usepackage{xifthen}
\usepackage{array}
\usepackage{multirow}
\usepackage[justification=centering]{caption}
\usepackage{booktabs}
\usepackage{eurosym}
\usepackage{multicol}
\usepackage[section]{placeins}
% \usepackage{uarial}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[toc,page]{appendix}
\usepackage{scrextend}
\usepackage{hyperref}
\usepackage{fix-cm}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{pgfsys}
\usepackage{keyval}
% \usepackage{subfig}
\usepackage{subcaption}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{chngcntr}
\usepackage{hhline}
% \usepackage{subcaption}
% \usepackage[output-decimal-marker={,}]{siunitx}
\usepackage[autolanguage,np]{numprint}
% \usepackage[bottom]{footmisc}
% \renewcommand{\familydefault}{\sfdefault}
\usepackage[left=1.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm]{geometry}

% \voffset -2cm
% \hoffset 0cm
% \oddsidemargin 0cm
% \evensidemargin -0.5cm
% \textwidth 17cm
% \topmargin 1cm
% \textheight 24cm
% \parindent 0cm
% \columnsep 0.7cm

\setcounter{tocdepth}{3}     % Dans la table des matieres
\setcounter{secnumdepth}{3}  % Avec un numero.

% Séparation entre les colonnes de multicols
\setlength{\columnsep}{1cm}

% set indent
\setlength{\parindent}{0pt}

 % --- espaces avant et après les floats
\setlength{\intextsep}{5pt} % Vertical space above & below [h] floats
\setlength{\textfloatsep}{5pt} % Vertical space below (above) [t] ([b]) floats
\setlength{\abovecaptionskip}{7pt}
\setlength{\belowcaptionskip}{3pt}
% ----- Numérotation figures en fonction des sections :
% \counterwithin{figure}{subsection}
% \counterwithin{table}{subsection}
% \RemoveFromReset{figure}{chapter}
% \AddToReset{figure}{section}
% \renewcommand{\thefigure}{\arabic{figure}}

% ----- Numérotation figures variable : en fonction des subsections, des sections ou des chapitres :
% \counterwithin*{figure}{subsubsection}
% \renewcommand{\thefigure}{%
% \ifnum\value{subsubsection}=0
%   \ifnum\value{subsection}=0
%     \ifnum\value{section}=0
%       \thechapter.%
%     \else
%       \thesection.%
%     \fi
%   \else
%     \thesubsection.%
%   \fi
% \else
%   \thesubsubsection.%
% \fi
%   \arabic{figure}%
% }
%
%
% \counterwithin*{table}{subsubsection}
% \renewcommand{\thetable}{%
% \ifnum\value{subsubsection}=0
%   \ifnum\value{subsection}=0
%     \ifnum\value{section}=0
%       \thechapter.%
%     \else
%       \thesection.%
%     \fi
%   \else
%     \thesubsection.%
%   \fi
% \else
%   \thesubsubsection.%
% \fi
%   \arabic{table}%
% }




% \titlespacing*{\chapter}{0pt}{0pt}{3cm}

%%%%% sections
% \titleformat{\section}[frame]
% {}%
% {}%
% {5pt}
% {\sffamily\Large\bfseries\filcenter\thesection\enspace}
%%%%%%%%%%%%%%%%%%%%

% ----- Réglage espace avant et après titres (left-before-after)
\titlespacing*{\chapter}
{0pt}{0.2cm plus 0.25cm minus 0.25cm}{1.5cm plus 0.1cm minus 0.1cm}
\titlespacing*{\section}
{0pt}{0.4cm plus 0cm minus 0cm}{0.4cm plus 0cm minus 0cm}
\titlespacing*{\subsection}
{0pt}{0.2cm plus 0cm minus 0cm}{0.2cm plus 0cm minus 0cm}
\titlespacing*{\paragraph}
{0pt}{0.1cm plus 0cm minus 0cm}{0.1cm plus 0cm minus 0cm}



%%%%% Sections invisibles
\newcommand\invisiblesection[1]{%
  \refstepcounter{section}%
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}%
  \sectionmark{#1}}




%%%% changement marge %%%%
\newenvironment{changemargin}[2]{\begin{list}{}{%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{0pt}%
\setlength{\rightmargin}{0pt}%
\setlength{\listparindent}{\parindent}%
\setlength{\itemindent}{\parindent}%
\setlength{\parsep}{0pt plus 1pt}%
\addtolength{\leftmargin}{#1}%
\addtolength{\rightmargin}{#2}%
}\item }{\end{list}}
%%%% fin macro %%%%


% ---------- A propos des pages où pas assez de texte pour remplir tous les espaces (ce qui conduit latex à répartir équitablement le texte => espaces verticaus dans le texte) :
% "LaTeX uses \flushbottom for two-sided documents (book by default). Odd pages and even pages are forced to be aligned. In one-sided documents (article, report by default) LaTeX uses \raggedbottom, extra spaces will gone. cf. classes document.
%
% You can use \raggedbottom if you meet too many bad page breaks. However, it is preferred to prevent big boxes in your document. Use floats instead of put big tabulars and figures directly. For lists and section titles, it is often not too serious, be sure you put enough text for each sections."
\raggedbottom



% Commande édition conditionnelle
\newcommand{\EditIf}[4]{
\ifthenelse{
\equal{#1}{#2}
}{#3}{#4}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<general_options, include = FALSE>>=
### lancement manuel
# -- identification du dispositif
# rv <- list(
#   forest_num = 21,
#   rep_figures = "figures/"
# )
###

opts_chunk$set(
  concordance = T, include = T, eval = T, tidy = F, cache = FALSE, 
  warning = F, comment = F, error = F, message = F, echo = F, 

  fig.path = rv$rep_figures, dev = 'pdf', fig.pos = "H", 
  fig.align = 'center', fig.show = 'hold', 
  size = 'normalsize', eval.after = 'fig.cap'
)
options(width = 45, guiToolkit = "tcltk")
par(mar = c(0, 0, 0, 0))
@

<<librairies>>=
# library(DBI)
suppressMessages({
  library("xtable")
  library("ggplot2")
  library("reshape2")
  library("scales")
  # library("doBy")
  library("gridExtra")
  library("gdata")
  library("rgdal")
  library("maptools")
  library("stringr")
  library("dplyr")
  library("tidyr")
  library("ggthemes")
  library("rgeos")
  library("tools")
  library("ggrepel")
  library("grid")
  library("openxlsx")
  library("fmsb")
  library("tcltk")
  library("rlang")
})
@

<<functions>>=
##### fonction de nettoyage des noms #####
clean_names <- function(string) {
  string <- gsub("/", " sur ", string)
  string <- gsub("\\.", "_", string, fixed)
  string <- gsub(" ", "_", string, fixed = T)
  string <- gsub("'", "", string, fixed = T)
  string <- gsub("\u00EA", "e", string, fixed = T)
  string <- gsub("\u00E2", "a", string, fixed = T)
  string <- gsub("\u00E9", "e", string, fixed = T)
  string <- gsub("\u00E8", "e", string, fixed = T)
  string <- gsub("\u00FB", "u", string, fixed = T)
  string <- gsub("\u00EE", "i", string, fixed = T)
  string <- gsub("\u00F4", "o", string, fixed = T)
  string <- gsub("\u00E7", "c", string, fixed = T)
  
  # majuscules
  string <- gsub("\u00CA", "E", string, fixed = T)
  string <- gsub("\u00C2", "A", string, fixed = T)
  string <- gsub("\u00C9", "E", string, fixed = T)
  string <- gsub("\u00C8", "E", string, fixed = T)
  string <- gsub("\u00DB", "U", string, fixed = T)
  string <- gsub("\u00CE", "I", string, fixed = T)
  string <- gsub("\u00D4", "O", string, fixed = T)
  string <- gsub("\u00C7", "C", string, fixed = T)
  
  # retour de la fonction clean_names
  return(string)
}

##### function to find increment value in plots #####
find_increment_value <- function(y_max) {
  # -- calculate default value
  default_increment_scale <- cut(
    y_max, breaks = c(-Inf, 0.25, 0.5, 2, 6, 13, 27, 40, 65, 130, 325, 650, 2000, 6000, 10000, Inf), 
    labels = c(0.05, 0.1, 0.2, 0.5, 1, 2, 3, 5, 10, 25, 50, 100, 200, 500, 1000), 
    include.lowest = T, 
    right = T
  ) %>% 
    as.character() %>% 
    as.numeric()
  
  # -- define increment scale (y)
  if (default_increment_scale > 1) {
    # construction d'increment value -> obtenir entre 8 et 15 labels
    increment_value <- 
      floor( ( (y_max / 8 + y_max / 15) / 2 ) / default_increment_scale + 0.5 ) * 
      default_increment_scale
    # security
    increment_value <- 
      if (increment_value == 0) default_increment_scale else increment_value
  } else {
    # valeur par défault
    increment_value <- default_increment_scale
  }
  
  # -- return of 'find_increment_value' function
  return(increment_value)
}

##### fonction pour construire les nuages de point illustrant l'évolution d'une variable (Gha, Vc, ...) par essence au cours du temps essences #####
build_evol_scatter_plot <- function(
  table = NULL, 
  var = NULL, 
  attribute = NULL, 
  scale_name = NULL, 
  colour_scale_name = NULL, 
  
  alpha_scale_range = NULL, 
  size_scale_range = NULL, 
  shape_scale_range = NULL, 
  colour_scale_range = NULL, 
  
  plot_title = NULL, 
  x_axis_name = NULL, # attribute
  y_axis_name = NULL, 
  last_cycle = NULL
) {
  # # data
  # table = scatter_plot_table # debug
  # var = "G" # debug
  # attribute = "Essence" # debug
  # last_cycle = last_cycle # debug
  # 
  # # ranges
  # alpha_scale_range = range_alpha # debug
  # size_scale_range = range_size # debug
  # shape_scale_range = range_shape # debug
  # colour_scale_range = colour_aes_for_species # debug
  # 
  # # labels
  # scale_name = "Années d'inventaire" # debug
  # plot_title = "Evolution de la surface terrière (pour les essences principales)\nau cours des différents inventaires" # debug
  # y_axis_name = "G (m2/ha)"
  
  # -- plot settings
  # guide length
  guide_length <- dim( table %>% distinct(!!sym(attribute)) )[1]
  
  # axis max values
  Y_max = max(table[, var])
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)
  
  # increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plot
ggplot(table) +
  geom_point(
    aes_string(x = attribute, y = var, alpha = "Annee", colour = attribute)
  ) +
  geom_point(
    aes_string(
      x = attribute, y = var, 
      alpha = "Annee", colour = attribute, 
      shape = "Annee", size = "Annee"
    )
  ) +
  geom_label_repel(
    table, 
    mapping = aes_string(x = attribute, y = var, label = "Annee"), 
    label.padding = unit(0.15, "lines"), 
    size = 1.7, alpha = 1
  ) +
  
  # scales
  labs(x = x_axis_name) +
  scale_y_continuous(
    name = y_axis_name, 
    limits = c(0, Y_max * 1.1), 
    breaks = seq(0, Y_max * 1.2, increment_value)
  ) +

  scale_alpha_manual(name = scale_name, values = alpha_scale_range) +
  scale_size_manual(name = scale_name, values = size_scale_range) +
  scale_shape_manual(name = scale_name, values = shape_scale_range) +
  scale_colour_manual(name = colour_scale_name, values = colour_scale_range) +
  
  # guides
  guides(
    # colour = guide_legend(
    #   nrow = ifelse(
    #     guide_length > 5, 
    #     ceiling(guide_length / 5), 1
    #   ), 
    #   byrow = TRUE, 
    #   order = 1
    # ), 
    colour = FALSE, 
    alpha = guide_legend(
      nrow = ifelse(last_cycle >= 5, 2, 1), 
      byrow = TRUE, 
      order = 2
    ), 
    shape = guide_legend(
      nrow = ifelse(last_cycle >= 5, 2, 1), 
      byrow = TRUE, 
      order = 2
    ), 
    size = guide_legend(
      nrow = ifelse(last_cycle >= 5, 2, 1), 
      byrow = TRUE, 
      order = 2
    )
  ) +
  ggtitle(plot_title) +
  theme_bw() + 
  theme(
    # title = element_text(face = 'plain', size = 7), 
    text = element_text(face = 'plain', size = 7), 
    
    legend.text = element_text(size = 5), 
    legend.position = "bottom", 
    legend.direction = "horizontal", 
    legend.box = "vertical", 
    legend.box.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), 
    
    plot.title = element_text(size = 7, hjust = 0.5), 
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )
  # theme(
  #   title = element_text(face = 'plain', size = 7), 
  #   
  #   axis.text.x = element_text(size = 6), 
  #   axis.text.y = element_text(size = 6), 
  #   axis.title.x = element_blank(), 
  #   
  #   legend.text = element_text(size = 5), 
  #   legend.position = "bottom", 
    # legend.direction = "horizontal", 
    # legend.box = "vertical", 
    # legend.box.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), 
  #   
  #   plot.title = element_text(hjust = 0.5), 
  #   plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  # )
}

##### fonction pour filtrer les tables selon une liste de dispositifs #####
filter_by_forest <- function(
  tables = NULL, 
  forest_num = NULL, 
  cycle = NULL
) {
  # -- liste des numéros de dispositifs
  # num_list <- as.numeric( str_sub(forest_list, 1, str_locate(forest_list, "-")[, 1] - 1) )
  # num_list <- str_split(forest_list, pattern = "_", simplify = T)[,1]
  # num_list <- as.numeric(num_list)
  
  for (tmp in tables) {
    # print(tmp) # debug
    # print(class(tmp)) # debug
    # tmp <- tables[[1]] # debug
    
    # cas où tmp est un nom de table
    # -- nom de la table
    tmp_NAME <- tmp
    # -- data.frame
    tmp <- get(tmp_NAME, envir = parent.frame())
    
    if ("data.frame" %in% class(tmp)) {
      if (nrow(tmp) > 0) {
        # -- filtre selon la liste de dispositifs sélectionnés
        if ("NumForet" %in% names(tmp)) {
        tmp <- tmp %>% filter(NumForet %in% forest_num)
        }
        
        # -- filtre selon le cycle
        if ("Cycle" %in% names(tmp)) {
          tmp <- tmp %>% filter(Cycle <= cycle) 
        }
        
        # if (cycle == 1) {
        #   tmp <- 
        #     tmp %>% 
        #     mutate(
        #       AcctGper = NULL, 
        #       AcctVper = NULL, 
        #       AcctD = NULL
        #     )
        # }
      } # end of cond 'dim(tmp)[1] > 0'
    } # end of cond '"data.frame" %in% class(tmp)'
    
    # cas où tmp est une liste
    if ("list" %in% class(tmp)) {
      for (i in 1:length(tmp)) {
        if (dim(tmp[[i]])[1] > 0) {
          # -- filtre selon la liste de dispositifs sélectionnés
          if ("Cycle" %in% names(tmp[[i]])) {
          tmp[[i]] <- tmp[[i]] %>% filter(NumForet %in% forest_num)
          }
          
          # -- filtre selon le cycle
          if ("Cycle" %in% names(tmp[[i]])) {
            tmp[[i]] <- tmp[[i]] %>% filter(Cycle <= cycle)
          }
          
          # if (cycle == 1) {
          #   tmp[[i]] <- 
          #     tmp[[i]] %>% 
          #     mutate(
          #       AcctGper = NULL, 
          #       AcctVper = NULL, 
          #       AcctD = NULL
          #     )
          # }
        }
      } # end of loop length(tmp)
    } # end of cond '"list" %in% class(tmp)'
    
  # retour de la fonction filter_by_forest : assign tmp_NAME to tmp
      assign(tmp_NAME, tmp, envir = parent.frame())
  }
}

##### fonction pour construire les histogrammes (en valeurs absolu) de la répartition de la qualité par catégorie de diamètre/essence #####
# TODO : à rapprocher de build_pie_chart
# TODO : mieux gérer les traductions d'unités (diminuer le nombre de paste0)
build_absolute_histo_plot <- function(
  table = NULL, 
  totals_table = NULL, 
  x = NULL, 
  y = NULL, 
  x_axis_name = NULL, 
  units_table = NULL, 
  palette = NULL
) {
  # -- plot settings
  # units
  y_unit <- with(units_table, units_label[match(y, var)])
  
  # axis max values
  X_max = dim( table %>% distinct(!!sym(x)) )[1]
  Y_max = max(totals_table[, y])
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)
  
  # increment scale (y)
  increment_value <- find_increment_value(Y_max)
  
  # -- plot
  ggplot() + 
    geom_bar(
      table, 
      mapping = aes_string(x = x, y = y, fill = "Reg1"), 
      stat = "identity", position = "stack", width = 0.5
    ) +
    annotate(
      "label", 
      x = X_max * 0.9, 
      y = Y_max, 
      label = paste0(
        i18n()$t(y), " = ", 
        round( sum(table[, y], na.rm = T) , 0), 
        i18n()$t(paste0(" ", y_unit))
      ), 
      size = 2, 
      col = "black", 
      label.padding = unit(0.1, "lines"), alpha = 1
    ) +
    scale_fill_manual(values = palette) +
    scale_y_continuous(
      limits = c(0, Y_max * 1.1), 
      breaks = seq(0, Y_max * 1.3, increment_value)
    ) +
    labs(
      fill = i18n()$t("Qualités de\r\nbille de pied"), 
      y = paste0(i18n()$t(y), " ", i18n()$t(paste0("(", y_unit, ")"))), 
      x = x_axis_name
    ) +
    guides(fill = guide_legend(reverse = T)) +
    theme_bw() +
    theme(
      text = element_text(size = 7), 
      
      axis.text.x = element_text(size = 6), 
      axis.text.y = element_text(size = 6), 
      
      legend.title = element_text(size = 9), 
      legend.position = "bottom", 
      legend.direction = "horizontal", 
      plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
    )
}

##### fonction pour construire les histogrammes (en valeurs relatives) de la répartition de la qualité par catégorie de diamètre #####
build_relative_histo_plot <- function(
  table = NULL, 
  x = NULL, 
  y = NULL, 
  x_axis_name = NULL, 
  palette = NULL
) {
  # -- plot
  ggplot() + 
    geom_bar(
      table, 
      mapping = aes_string(x = x, y = y, fill = "Reg1"), 
      stat = "identity", position = "fill", width = 0.5
    ) + 
    scale_fill_manual(values = palette) + 
    scale_y_continuous(expand = c(0, 0), labels = percent) + 
    labs(
      fill = i18n()$t("Qualités de\r\nbille de pied"), 
      y = paste0(i18n()$t("Part de "), y, " (%)"), 
      x = x_axis_name
    ) +  
    theme_bw() +
    theme(
      text = element_text(size = 7), 
      
      axis.text.x = element_text(size = 6), 
      axis.text.y = element_text(size = 6), 
      
      legend.title = element_text(size = 9), 
      legend.position = "bottom", 
      legend.direction = "horizontal", 
      plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
    )
}

##### function to get results by 2 attributes #####
  # attribute1 <- "Essence" # row attribute
  # attribute2 <- "Qual1" # column attribute
  # attribute1_levels <- main_species_order
  # attribute2_levels <- c("A", "B", "C", "D")
  # # results_with_attribute1_and_attribute2 <- gfForetFpied_EssenceQual1
  # # results_with_attribute1 <- gfForetFpied_Essence
  # var <- "Gha"
  # 
  # attribute1_total_label <- i18n()$t("\\textbf{Total par essence}")
  # attribute2_total_label <- i18n()$t("\\textbf{Total par catégorie}")
  # 
  # 
  # table_title <- i18n()$t("Répartition de la qualité par catégorie de diamètre (selon la surface terrière)")
  # table_label <- "species-qual1_distribution_table"
  
 set_up_results_by_2_attributes_table <- function(
    results_with_attribute1_and_attribute2 = NULL,
    forest_num = NULL,
    last_cycle = NULL,
    attribute1 = NULL,
    attribute2 = NULL,
    var = NULL,
    attribute1_name = attribute1_name,
    attribute1_levels = NULL,
    attribute2_levels = NULL,
    attribute1_total_label = NULL,
    attribute2_total_label = NULL,
    table_title = NULL,
    table_label = NULL,
    align_parameters = NULL,
    var_digits_parameter = NULL,
    
    hold_print = F
  ) {
    # set up digits parameter for var
    if (is.null(var_digits_parameter)) var_digits_parameter <- 1
    
    # -- set up table
    table <- results_with_attribute1_and_attribute2 %>% 
      filter(NumForet == forest_num & Cycle == last_cycle) %>%
      
      # define attributes columns
      mutate(
        attribute1 = !!sym(attribute1),
        attribute2 = !!sym(attribute2),
        var = !!sym(var),
        
        # translation
        attribute1 = i18n()$t(attribute1),
        # attribute2 = i18n()$t(attribute2),
        
        attribute1 = factor(attribute1, attribute1_levels),
        attribute2 = factor(attribute2, attribute2_levels)
      ) %>% 
      # complete(attribute2) %>% 
      select(attribute1, attribute2, var)
    
    # -- build results by attribute1 and attribute2
    results_by_attribute1_and_attribute2 <- 
      table %>%  
      
      # summarise by attribute1 and attribute2
      group_by(attribute1, attribute2) %>% 
      summarise(var = sum(var, na.rm = T)) %>% 
      ungroup() %>% 
      
      # total and share
      group_by(attribute2) %>% 
      mutate(
        # total by attribute2 (columns)
        total = sum(var, na.rm = T),
        
        # share of each attribute1 value by attribute2
        share = var / total * 100
      ) %>% 
      ungroup() %>% 
      
      # label
      mutate(
        # format var & share
        label = ifelse(
          round(var, var_digits_parameter) == 0, 
          "$\\sim$0", round(var, var_digits_parameter)
        ),
        share = ifelse(
          round(share, 0) == 0, 
          "$\\sim$0", round(share, 0) # digits fixe (0) pour les %
        ),
        label = ifelse(
          var != 0, 
          paste0(
              "\\footnotesize{", label, 
            "} \\scriptsize{\\textcolor{CornflowerBlue}{(", share, "\\%)}}"
          ), 
          ""
        )
        
        # # arrange
        # attribute1 = factor(attribute1, levels = attribute1_levels),
        # attribute2 = factor(attribute2, levels = attribute2_levels)
      ) %>% 
      arrange(attribute1, attribute2) %>% 
      
      # select
      select(attribute2, attribute1, label)
    
    
    # -- build total by attribute1 (rows) - faire une fonction pour ce modèle de table ?
    results_by_attribute1 <- 
      table %>%
      
      # summarise by attribute1
      group_by(attribute1) %>% 
      summarise(var = sum(var, na.rm = T)) %>% 
      ungroup() %>% 
      
      # total, share and label
      mutate(
        attribute2 = paste0(
          "\\cellcolor{LightGray} ", attribute1_total_label
        ),
        
        # total for attribute1
        total = sum(var, na.rm = T),
        
        # share of each attribute1 value
        share = var / total * 100,
        
        # format var & share (for label)
        label = ifelse(
          round(var, var_digits_parameter) == 0, 
          "$\\sim$0", round(var, var_digits_parameter)
        ),
        share = ifelse(
          round(share, 0) == 0, 
          "$\\sim$0", round(share, 0) # digits fixe (0) pour les %
        ),
        
        # label
        label = ifelse(
          var != 0, 
          paste0(
            "\\cellcolor{LightGray} \\textbf{\\footnotesize{", label, 
            "} \\scriptsize{\\textcolor{Brown}{(", share, "\\%)}}}"
          ), 
          ""
        )
        
        # # arrange attribute1
        # attribute1 = factor(attribute1, levels = attribute1_levels)
      ) %>% 
      arrange(attribute1) %>% 
      
      # select
      select(attribute2, attribute1, label)
    
    
    # -- build total by attribute2 (columns) - faire une fonction pour ce modèle de table ?
    results_by_attribute2 <- 
      table %>% 
      
      # summarise by attribute2
      group_by(attribute2) %>% 
      summarise(var = sum(var, na.rm = T)) %>% 
      ungroup() %>% 
      
      # total, share and label
      mutate(
        attribute1 = paste0(
          "\\rowcolor{LightGray} ", attribute2_total_label
        ),
        
        # total by diam cat
        total = sum(var, na.rm = T),
        
        # share for each diam cat
        share = var / total * 100,
        
        # format var & share (for label)
        label = ifelse(
          round(var, var_digits_parameter) == 0, 
          "$\\sim$0", round(var, var_digits_parameter)
        ),
        share = ifelse(
          round(share, 0) == 0, 
          "$\\sim$0", round(share, 0) # digits fixe (0) pour les %
        ),
        
        # label
        label = ifelse(
          var != 0, 
          paste0(
            "\\cellcolor{LightGray}{\\textbf{\\footnotesize{", label, 
            "} \\scriptsize{\\textcolor{DarkSlateBlue}{(", share, "\\%)}}}}"
          ), 
          "\\cellcolor{LightGray}{}"
        )
        
        # # arrange species
        # attribute2 = factor(attribute2, levels = attribute2_levels)
      ) %>% 
      arrange(attribute2) %>% 
      
      # select
      select(attribute2, attribute1, label)
    
    # -- build total
    global_results <- 
      table %>% 
      
      # summarise without attribute
      summarise(var = sum(var, na.rm = T)) %>% 
      
      # total, share and label
      mutate(
        attribute2 = paste0("\\cellcolor{LightGray} ", attribute1_total_label), 
        attribute1 = paste0("\\rowcolor{LightGray} ", attribute2_total_label),
        
        # total
        total = sum(var, na.rm = T),
        
        # share ( = 100 %)
        share = var / total * 100,
        
        # format var & share (for label)
        label = ifelse(
          round(var, var_digits_parameter) == 0, 
          "$\\sim$0", round(var, var_digits_parameter)
        ),
        share = ifelse(
          round(share, 0) == 0, 
          "$\\sim$0", round(share, 0) # digits fixe (0) pour les %
        ),
        
        # label
        label = ifelse(
          var != 0, 
          paste0(
            "\\cellcolor{DimGray}{\\textcolor{white}{\\textbf{\\footnotesize{", label, 
            "} \\scriptsize{(", share, "\\%)}}}}"
          ), 
          "\\cellcolor{LightGray}{}"
        )
      ) %>%
      
      # select
      select(attribute2, attribute1, label)
    
    
    # -- stack tables
    all_results <- rbind(
      results_by_attribute1_and_attribute2, 
      results_by_attribute1, 
      results_by_attribute2, 
      global_results
    ) %>%
      arrange(attribute1, attribute2) %>% 
      pivot_wider(
        id_cols = "attribute1", 
        names_from = "attribute2", 
        values_from = "label"
      ) %>% 
      
      # order
      select(attribute1, one_of(attribute2_levels), everything()) %>% 
      
      # replace attribute1 by attribute name
      rename(!!attribute1_name := "attribute1")
    names(all_results) <- paste0("\\textbf{", names(all_results), "}")
    
    # -- print table
    # set up digits
    digits_param = rep(0, dim(all_results)[2] + 1)
    # set up columns width
    if (is.null(align_parameters)) {
      align_parameters = list(first_column = 2.4, columns = 2)
    }
    
    if (!hold_print) {
    print(
      xtable(
        all_results, 
        caption = table_title, 
        caption.placement = "top", 
        digits = digits_param, 
        align = c(
          "M{0cm}|", 
          paste0("|M{", align_parameters$first_column, "cm}|"), 
          rep(paste0("M{", align_parameters$columns, "cm}|"), dim(all_results)[2] - 1)
        ), 
        label = table_label
      ), 
      hline.after = -1:dim(all_results)[1], 
      sanitize.text.function = function(x) return(x), 
      include.rownames = FALSE, 
      size = "\\footnotesize"
    )
    } else return(all_results)
  }

##### function to print main results table #####
print_main_results_table <- function(
  table = NULL, 
  cycles_table = NULL, attribute = "dendrometric", 
  forest_num = NULL, last_cycle = NULL, 
  label = NULL, caption = NULL
) {
  # -- var to select
  if (attribute == "economic") {
    var <- 
      if (last_cycle > 1) {
        c("VcHa", "VpHa", "Gainper", "CV_VcHa", "CV_VpHa", "CV_Gainper", "Er_VcHa", "Er_VpHa", "Er_Gainper")
      } else {
        c("VcHa", "CV_VcHa", "Er_VcHa")
      }
  }
  if (attribute == "dendrometric") {
    var <- 
      if (last_cycle > 1) {
        c(
          "Nha", "Gha", "Vha", "AcctGper", "AcctVper", 
          "CV_Nha", "CV_Gha", "CV_Vha", "CV_AcctGper", "CV_AcctVper", 
          "Er_Nha", "Er_Gha", "Er_Vha", "Er_AcctGper", "Er_AcctVper"
        )
      } else {
        c(
          "Nha", "Gha", "Vha", 
          "CV_Nha", "CV_Gha", "CV_Vha", 
          "Er_Nha", "Er_Gha", "Er_Vha"
        )
      }
  }
  
  # -- table
  table <- 
    table %>% 
    filter(Cycle == last_cycle & NumForet == forest_num & Gha > 0) %>% 
    left_join(
      cycles_table[, c("NumForet", "Cycle", "Annee")], 
      by = c("NumForet", "Cycle")
    ) %>%
    
    # sort and data
    arrange(-Gha) %>% 
    select("Annee", one_of(var)) %>% 
    
    # pivot
    pivot_longer(
      cols = -"Annee", 
      names_to = "variable", 
      values_to = "value"
    ) %>% 
    
    # get share and digits
    mutate(
      
      # digits
      digits = NA, 
      digits = case_when(
        variable %in% c("Nha", "Vha", "VcHa", "VpHa", "Gainper") ~ 0, 
        variable %in% c("Gha", "AcctVper") ~ 1, 
        variable %in% "AcctGper" ~ 2, 
        str_detect(variable, "CV") ~ 0, 
        str_detect(variable, "Er") ~ 1
      ), 
      
      # round values
      value = round(value, digits), 
      digits = NULL, 
      
      # mean label (for separate)
      variable = ifelse(
        !str_detect(variable, "CV") & !str_detect(variable, "Er"), 
        paste0("Moy_", variable), 
        variable
      )
    ) %>% 
    separate(variable, c("stat", "variable"), sep = "_") %>% 
    pivot_wider(
      id_cols = c("Annee", "variable"), 
      names_from = "stat", 
      values_from = "value"
    ) %>% 
    mutate(
      IC = paste0(
        "\\emph{[", round(Moy - Er * Moy / 100, 0), 
        "-", round(Moy + Er * Moy / 100, 0), "]}"
      ), 
      
      variable = gsub("ha", "", variable), 
      variable = gsub("per", "", variable), 
      variable = gsub("Ha", "", variable), 
      # variable = paste0("\\cellcolor{LightGray} ", variable)
      
      # translation
      variable = i18n()$t(variable)
    ) %>% 
    # pivot
    pivot_longer(
      cols = -c("Annee", "variable"), 
      names_to = "stat", 
      values_to = "value", 
      values_transform = list(
        value = as.character
      )
    ) %>% 
    pivot_wider(
      id_cols = c("Annee", "stat"), 
      names_from = "variable", 
      values_from = "value"
    ) %>% 
    
    # format table
    mutate(
      stat = case_when(
        stat == "Moy" ~ paste0("\\textbf{", i18n()$t("Moyenne"), "}"),
        stat == "CV" ~ i18n()$t("Coefficient de variation (\\%)"),
        stat == "Er" ~ i18n()$t("Erreur relative (\\%)"),
        stat == "IC" ~ i18n()$t("\\emph{Intervalle de confiance}")
      ), 
      
      # column 'N'
      empty = NA
    ) %>% 
    set_multirow_table(1) %>% # TODO : remplacer les numéros de colonne par les noms de colonne
    
    # rename
    rename(
      !!i18n()$t("Année") := "Annee", 
      " " = "stat", 
      "  " = "empty"
    )
  names(table)[ 1:(ncol(table) - 1) ] <- 
    paste0("\\cellcolor{LightGray} ", names(table)[ 1:(ncol(table) - 1) ])
  # N.B : attention si on utilise rowcolor, alors la colonne N est mise en couleur aussi et appraît + attention à ne pas colorier N!
  
  # print table settings
  digits_param = rep(0, ncol(table) + 1)
  
  # add.to.row parameters
  ## rows
  ### 1st row (names)
  rows_list <- list(0)
  ### other rows
  for (i in 1:(nrow(table) - 1)) {
    rows_list[length(rows_list) + 1] <- i
  }
  ## commands
  ### commande pour agrandir la ligne des moyennes
  command = "[3ex]\n\\hline\n\\rule{0pt}{3ex}"
  ### commande pour les autres lignes
  command <- c(
    command, 
    rep(paste0("\\cline{2-", ncol(table), "}"), length(rows_list) - 1)
  )
               
  # print table
  print(
    xtable(
      table, 
      digits = digits_param, 
      align = c(
        "|M{0.5cm}|", "|M{1cm}|", "M{2.5cm}|", 
        rep("M{1.8cm}|", ncol(table) - 3), "N"
      ), 
      caption = caption, 
      label = label
    ), 
    caption.placement = "bottom", 
    include.rownames = F, 
    hline.after = c(-1, nrow(table)), 
    
    # command to add to 1st row
    add.to.row = list(
      pos = rows_list, 
      command = command
    ), 
    sanitize.text.function = function(x) {return(x)}, 
    size = "\\footnotesize"
  )
  
  # -- return from print_main_results_table function
  return(table)
}

##### function to build boxplot #####
build_box_plot <- function(
  table = NULL, var = NULL, 
  y_axis_name = NULL, 
  max_definition_vars = NULL
) {
  # table = t # debug
  # var = "Nha" # debug
  # y_axis_name = "(tiges/ha)" # debug
  
  # -- plot table
  plot_table <- 
    table %>% 
    filter(variable == var) %>% 
    mutate(
      variable = gsub("ha", "", variable), 
      variable = gsub("Ha", "", variable), 
      variable = gsub("per", "", variable), 
      
      # translation
      variable = i18n()$t(variable)
    )
  
  # -- define Y_max
  if (is.null(max_definition_vars)) {
    Y_max = max(plot_table$value, na.rm = T)
  } else {
    Y_max <- 
      table %>% 
      filter(variable %in% max_definition_vars) %>% 
      arrange(desc(value)) %>% 
      head(1) %>% 
      select(value) %>% 
      unlist() %>% 
      unname()
  }
  
  # -- plot
  ggplot() +
    geom_boxplot(plot_table, mapping = aes(variable, value)) +
    scale_y_continuous(
      limits = c(0, Y_max * 1.1), 
      expand = c(0, 0), 
      name = y_axis_name
    ) +
    theme_bw() +
    theme(
      axis.title.x = element_blank(), 
      axis.title.y = element_text(size = 9, colour = "navy"), 
      axis.ticks.x = element_blank(), 
      axis.line.x = element_blank(), 
      axis.text.x = element_text(size = 9, colour = "springgreen4"), 
      axis.text.y = element_text(size = 7, colour = "navy")
    )
}

##### function to set up main results table to print (déclinés pour 1 attribut) #####
set_up_main_results_by_attribute_table <- function(
  table = NULL, 
  var = NULL, 
  attribute = NULL, 
  forest_num = NULL, last_cycle = NULL, 
  precision_needed = F
) {
  # -- default value -> var to select
  if (is.null(var)) {
    var <- 
      if (last_cycle > 1) {
        c("Nha", "Gha", "Vha", "AcctGper", "AcctVper", "Gainper", "VcHa", "VpHa")
      } else {
        c("Nha", "Gha", "Vha", "VcHa")
      }
  }
  
  # -- tables
  # main table
  table <- 
    table %>% 
    filter(Cycle == last_cycle & NumForet == forest_num & Gha > 0) %>% 
    
    # define attribute column
    mutate(attribute = !!sym(attribute)) %>% 
    
    # sort and select data
    arrange(-Gha) %>% 
    select("attribute", var) %>% 
    
    # pivot
    pivot_longer(
      cols = -"attribute", 
      names_to = "variable", 
      values_to = "value"
    ) %>% 
    
    # calcul totaux
    group_by(variable) %>% 
    mutate(total = sum(value, na.rm = T)) %>% 
    ungroup() %>% 
    
    # get share and digits
    mutate(
      value = ifelse(value < 0, 0, value), 
      
      # share
      share = round(value / total * 100), 
      share = ifelse(share >= 1, share, "$\\sim$0"), 
      share = ifelse(value > 0, share, NA), 
      
      # digits
      digits = case_when(
        variable %in% c("Nha", "Vha", "VcHa", "VpHa", "Gainper") ~ 0, 
        
        # Gha - precision needed or not
        variable == "Gha" & precision_needed == F ~ 1, 
        variable == "Gha" & value < 0.1 & precision_needed == T ~ 2, 
        variable == "Gha" & value >= 0.1 & precision_needed == T ~ 1, 
        
        variable == "AcctVper" ~ 1, 
        variable == "AcctGper" ~ 2, 
        
        str_detect(variable, "CV") ~ 0, 
        str_detect(variable, "Er") ~ 1
      )
    
    # ancienne version
      # digits = NA, 
      # digits = ifelse(
      #   variable %in% c("Nha", "Vha", "VcHa", "VpHa", "Gainper"), 
      #   0, digits
      # ), 
      # digits = ifelse(
      #   variable %in% c("Gha", "AcctVper"), 
      #   1, digits
      # ), 
      # digits = ifelse(
      #   variable == "AcctGper", 
      #   2, digits
      # )
    ) #%>% 
    # arrange(attribute)
  
  # rangement pour Cat et Qual1 -> # TODO : définir les classes (S4 ?) des attributs ?
  if (attribute != "Essence") {
    table <- table %>% arrange(attribute)
  }
  
  # total table
  total_table <- 
    table %>% 
    select(variable, total, digits) %>% 
    
    # securité pour éviter les doublons (si 1X 1 digits et 1X 2 digits)
    group_by(variable) %>% 
    mutate(digits = max(digits, na.rm = T)) %>% 
    ungroup() %>% 
    
    distinct() %>% 
    mutate(
      attribute = "\\rowcolor{LightGray} \\textbf{Total}", 
      value = total, 
      share = 100
    ) %>% 
    select( names(table) )
  
  # stack table
  final_table <- rbind(
    table, 
    total_table
  ) %>% 
    mutate(
      # label
      label = ifelse(value >= 1 / 10 ^ digits, round(value, digits), "$\\sim$0"), 
      label = paste0(
        "\\footnotesize{", 
        label, 
        "} \\scriptsize{\\textcolor{CornflowerBlue}{(", 
        share, 
        "\\%)}}"
      ), 
      # bold total
      label = ifelse(
        attribute == "\\rowcolor{LightGray} \\textbf{Total}", 
        paste0("\\textbf{", label, "}"), 
        label
      ), 
      # empty/zero values
      label = ifelse(value > 0, label, NA)
    ) %>% 
    pivot_wider(
      id_cols = "attribute", 
      names_from = "variable", 
      values_from = "label"
    )
  
  
  # -- return from set_up_main_results_by_attribute_table function
  return(list(print_table = final_table, plot_table = table))
}

##### function to get results by 2 attributes #####
  # attribute1 <- "Essence" # row attribute
  # attribute2 <- "Qual1" # column attribute
  # attribute1_levels <- main_species_order
  # attribute2_levels <- c("A", "B", "C", "D")
  # # results_with_attribute1_and_attribute2 <- gfForetFpied_EssenceQual1
  # # results_with_attribute1 <- gfForetFpied_Essence
  # var <- "Gha"
  # 
  # attribute1_total_label <- i18n()$t("\\textbf{Total par essence}")
  # attribute2_total_label <- i18n()$t("\\textbf{Total par catégorie}")
  # 
  # 
  # table_title <- i18n()$t("Répartition de la qualité par catégorie de diamètre (selon la surface terrière)")
  # table_label <- "species-qual1_distribution_table"

##### function to build pie chart #####
build_pie_chart <- function(
  table = NULL, 
  var = NULL, 
  x = NULL, 
  y = NULL, 
  attribute = NULL, 
  fill_scale_range = NULL, 
  fill_scale_name = NULL, 
  
  # titles
  y_axis_name = NULL, 
  plot_title = NULL, 
  
  # grob settings
  grob_settings = NULL, 
  
  # transform coord polar ?
  pie_chart = T
) {
  # -- plot settings & table mutation
  if (!is.null(var)) {
    table <- table %>% filter(variable %in% !!var)
  }
  guide_length <- nrow( table %>% distinct(!!sym(attribute)) )
  
  
  # # -- security if label_str missing
  # if (!"label_str" %in% names(table)) table2 <- mutate(table, label_str := !!x)
  
  # -- plot
  plot <-
    ggplot() +
    geom_bar(
      table, 
      mapping = aes_string(x = x, y = y, fill = attribute), 
      stat = 'identity', position = 'fill'
    ) +
    geom_label(
      if (pie_chart == T) {
        table %>% distinct(!!sym(x), .keep_all = T)
      } else {
        table
      }, 
      mapping = aes_string(
        x = x, 
        y = "label_y", 
        label = "label_str"
      ), 
      label.padding = unit(
        grob_settings$layers$geom_label$label.padding_unit.num, # 0.15
        "lines"
      ), 
      label.r = unit(
        grob_settings$layers$geom_label$label.r_unit.num, 
        "lines"
      ), 
      size = grob_settings$layers$geom_label$size, # 1.7
      alpha = grob_settings$layers$geom_label$alpha, # 1, 
      fill = grob_settings$layers$geom_label$fill, # 1
      fontface = grob_settings$layers$geom_label$fontface
    ) +
    scale_x_discrete("") +
    scale_y_continuous(
      expand = c(0, 0), 
      name = y_axis_name, 
      breaks = seq(0, 1, 0.1), 
      labels = percent_format(accuracy = 1)
    ) +
    scale_fill_manual(
      name = fill_scale_name, 
      values = fill_scale_range
    ) +
    ggtitle(plot_title) +
    theme_bw() +
    theme(
      # title
      title = element_text(
        face = 'plain', 
        size = grob_settings$theme$title$size
      ), 
      # text
      text = element_text(
        face = 'plain', 
        size = grob_settings$theme$text$size
      ), 
      
      # axis
      # axis.text.y  = element_blank(), 
      axis.text.x = 
        element_text(size = grob_settings$theme$axis.text.x$size), 
      axis.text.y = 
        element_text(size = grob_settings$theme$axis.text.y$size), 
      axis.title.x = element_text(
        face = 'plain', 
        size = grob_settings$theme$axis.title.x$size
      ), 
      
      # legend
      legend.text = 
        element_text(size = grob_settings$theme$legend.text$size), 
      legend.position = grob_settings$theme$legend.position, 
      legend.direction = grob_settings$theme$legend.direction, 
      
      # plot
      plot.title = element_text(size = 7, hjust = 0.5), 
      plot.margin = unit(
        grob_settings$theme$plot.margin_unit.num, 
        "cm"
      ), 
      
      # panel
      panel.grid.major = element_blank(), 
      panel.border = element_blank()
    )
  
  
  # -- transform to polar coord ?
  if (pie_chart == T) {
    plot <- 
      plot + 
      coord_polar(theta = "y") +
      theme(
        axis.text.y  = element_blank(), 
        axis.ticks = element_blank()
      )
  } else {
    plot <- 
      plot + 
      # scale_y_continuous(
      #   expand = c(0, 0)
      # ) +
      coord_flip()
  }
  
  
  # -- legend direction + return of funtion build_pie_chart
  if (grob_settings$theme$legend.direction == "horizontal") {
    plot + 
      guides(
        fill = guide_legend(
          nrow = ifelse(guide_length > 5, ceiling(guide_length / 5), 1), 
          byrow = TRUE, 
          reverse = grob_settings$guides$fill$reverse
        )
      )
  } else {
    plot + 
      guides(
        fill = guide_legend(
          ncol = ifelse(guide_length > 8, ceiling(guide_length / 6), 1), 
          bycol = TRUE, 
          reverse = grob_settings$guides$fill$reverse
        )
      )
  }
}

##### fonction de mise en forme des multilignes dans les tableaux #####
set_multirow_table <- function(table = NULL, columns_pos = NULL) {
  for (i in columns_pos) {
    # test if duplicated elements
    pos <- which(duplicated(table[, i]))
    
    if (length(pos) > 0) {
      
      attribute <- names(table)[i]
      table <- 
        table %>% 
        # mutate(attribute = Annee) %>% # debug
        group_by(!!sym(attribute)) %>% 
        mutate(rows_nb = length(!!sym(attribute))) %>% 
        ungroup() %>% 
        mutate(
          # security (attribute must be character)
          !!sym(attribute) := as.character(!!sym(attribute)), 
          # -- format attribute column
          !!sym(attribute) := ifelse(
            !!sym(attribute) != lag(!!sym(attribute), default = "0"), 
            # add multirow command
            paste0("\\multirow{", rows_nb, "}{*}{", !!sym(attribute), "}"), 
            # remove duplicates
            NA
          ), 
          
          # remove 'rows_nb' column
          rows_nb = NULL
        )
    } # end of cond 'length(pos) > 0'
  } # end of loop 'i in columns_pos'
  
  # -- return of 'set_multirow_table' function table
  return(table)
}

##### fonction pour récupérer la légende d'une figure #####
g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}


##### fonction mise en forme texte (string vector) pour édition LaTeX #####
utf8_to_LaTeX <- function(string, ...) {
  string <- paste0(string, ...)
  string <- gsub("-", "--", string, fixed = T)
  string <- gsub("—", "---", string, fixed = T)
  string <- gsub("#", "\\#", string, fixed = T)
  # string <- gsub("{", "\\{", string, fixed  = T)
  # string <- gsub("}", "\\}", string, fixed  = T)
  string <- gsub("$", "\\$", string, fixed = T)
  string <- gsub("_", "\\_", string, fixed = T)
  string <- gsub("&", "\\&", string, fixed = T)
  string <- gsub("œ", "\\oe ", string, fixed = T)
  string <- gsub("æ", "\\ae ", string, fixed = T)
  string <- gsub("«", "\\og ", string, fixed = T)
  string <- gsub("»", "\\fg{}", string, fixed = T)
  string <- gsub("“", "``", string, fixed = T)
  string <- gsub("”", "''", string, fixed = T)
  string <- gsub("n°", "\\no ", string, fixed = T)
  string <- gsub("N°", "\\No ", string, fixed = T)
  string <- gsub("%", "\\%", string, fixed = T)
  string <- gsub("°", "\\textdegree", string, fixed = T)
  string <- gsub("‰", "\\textperthousand", string, fixed = T)
  string <- gsub("€", "\\texteuro", string, fixed = T)
  string <- gsub("^", "\\textasciicircum", string, fixed = T)
  string <- gsub("~", "\\textasciitilde", string, fixed = T)

  # -- charactères mal copiés dans word (Unicode mark cf https://github.com/tidyverse/tibble/issues/316 - VD 191029)
  string <- gsub("e\u0302", "\u00EA", string, fixed = T)
  string <- gsub("a\u0300", "\u00E0", string, fixed = T)
  string <- gsub("a\u0302", "\u00E2", string, fixed = T)
  string <- gsub("a\u0308", "\u00E4", string, fixed = T)
  string <- gsub("e\u0301", "\u00E9", string, fixed = T)
  string <- gsub("e\u0300", "\u00E8", string, fixed = T)
  string <- gsub("u\u0302", "\u00FB", string, fixed = T)
  string <- gsub("u\u0308", "\u00FC", string, fixed = T)
  string <- gsub("i\u0302", "\u00EE", string, fixed = T)
  string <- gsub("o\u0302", "\u00F4", string, fixed = T)
  string <- gsub("é\u0301", "\u00E9", string, fixed = T)
  string <- gsub("è\u0300", "\u00E8", string, fixed = T)
  # --

  # -- problème avec le charactère "!"
  string <- gsub("\u00a0", " ", string, fixed = T)

  string <- gsub("ê", "\u00EA", string, fixed = T)
  string <- gsub("à", "\u00E0", string, fixed = T)
  string <- gsub("â", "\u00E2", string, fixed = T)
  string <- gsub("é", "\u00E9", string, fixed = T)
  string <- gsub("è", "\u00E8", string, fixed = T)
  string <- gsub("û", "\u00FB", string, fixed = T)
  string <- gsub("ü", "\u00FC", string, fixed = T)
  string <- gsub("î", "\u00EE", string, fixed = T)
  string <- gsub("ô", "\u00F4", string, fixed = T)

  string <- gsub("\u2028", " ", string, fixed = T)
  string <- gsub("\\retour\\", "\n\n\\noindent", string, fixed = T)
  string <- gsub("\\saut\\", "\\\\

                 ", string, fixed = T)
  # cat(string)
  return(string)
}

##### fonction de conversion des caractères UTF8 en LaTeX : (tiré de Fiches_Rem) #####
df_Trad <-
  data.frame(
    UTF8 = c(
      "#", "{", "}", "$", "_", "&", "\u0153", "œ", "oe", 
      "æ", "«", "»", "“", "”", "n°", "N°", 
      "%", "‰", "€", 
      "^", "~", "\u2026", "\u00A0"
    ), 
    LaTeX = c(
      "\\#", "\\{", "\\}", "\\$", "\\_", "\\&", "\\oe ", "\\oe ", "\\oe ", 
      "\\ae ", "\\og ", "\\fg{}", "``", "''", "\\no ", "\\No ", 
      "\\%", "\\textperthousand", "\\texteuro", 
      "\\textasciicircum", "\\textasciitilde", "\\ldots", " "
    ), 
    nchar_suppl = c(
      2, 2, 2, 2, 2, 2, 4, 4, 3, 
      4, 4, 5, 2, 2, 3, 3, 
      2, 16, 9, 
      16, 15, 6, 0
    ), 
    stringsAsFactors = F
  )
utf8_To_LateX <- function(
  vector, df_Trad
) {
  for (i in 1:dim(df_Trad)[1]) {
    vector <- gsub(df_Trad$UTF8[i], df_Trad$LaTeX[i], vector, fixed = T)
  }
  return(vector)
}
@

<<import>>=

##### Lancement manuel de l'édition du livret GF #####
# # -- répertoire de travail
#   repGF <- "/Users/Valentin/Travail/Outils/Inventaire_PP"
#   # -- répertoire de l'application/package
#   app_dir <- "/Users/Valentin/Travail/Outils/Inventaire_PP/scripts/PermGF3"
# 
# rv <- list(
#   forest_num = 21,
#   rep_figures = "figures/",
#   repGF = repGF
# )
# # --- chargement des données d'inventaire
# tables <- load(file.path(repGF, "tables/gfDonneesBrutes.Rdata"))
# 
# # -- identification du dispositif
# rv <- c(
#   rv,
#   # nom de la forêt
#   forest_name = with(Forets, Nom[match(rv$forest_num, NumForet)]),
#   # numéro du dernier passage en inventaire
#   last_cycle = with(Cycles, max(Cycle[NumForet == rv$forest_num], na.rm = T)),
#   # année du dernier passage en inventaire
#   last_year = with(Cycles, Annee[NumForet == rv$forest_num & Cycle == rv$last_cycle])
# )
# 
# # -- chemins du répertoire de sauvegarde
# rv$rep_sav = paste0(repGF, "/out/", rv$forest_num, "-", clean_names(rv$forest_name))
# 
# # -- create translator tool
# translator <- shiny.i18n::Translator$new(translation_json_path = file.path(app_dir, "translations/translation.json"))
# # set language
# # rv$lang = "Deutsch"
# # rv$lang = "English"
# rv$lang = "Français"
# translator$set_translation_language(rv$lang)
# # i18n reactive function
# i18n <- function() {
#   translator
# }

##### / \ #####
repGF <- rv$repGF
forest_num <- rv$forest_num
forest_name <- rv$forest_name
last_cycle <- rv$last_cycle
rep_sav <- rv$rep_sav

# set wd
setwd(file.path(rv$rep_sav, "livret_GF"))

# --- chargement des données d'inventaire # TODO :  à supprimer ?
tables <- load(file.path(repGF, "tables/gfDonneesBrutes.Rdata"))

# -- filtre des tables liées à l'inventaire en fonction du numéro de forêt sélectionné
filter_by_forest(tables, forest_num = rv$forest_num, cycle = rv$last_cycle)

# chargement des tables brutes
load(file.path(rv$rep_sav, "tables/gfTablesBrutes.RData"))

# chargement des tables élaborées par placettes
load(paste0(rv$rep_sav, "/tables/gfTablesElaboreesPlac.Rdata"))
for (i in 1:length(results_by_plot)) {assign(names(results_by_plot)[i], results_by_plot[[i]])}

# chargement des tables élaborées
load(paste0(rv$rep_sav, "/tables/gfTablesElaborees.Rdata"))
for (i in 1:length(results_by_group)) {assign(names(results_by_group)[i], results_by_group[[i]])}
@

<<edition_parameters_init>>=
# -- édition des commentaires
Eval_Comment <- F
# Answer_Comments <- tk_messageBox(
#   type = "yesno",
#   message = "Editer le livret GF avec les commentaires ?",
#   caption = "Edition des commentaires"
# )

Answer_Comments <- "no" # debug
if (Answer_Comments == "yes") {
  Eval_Comment <- T
  Comments_FILE <- tk_choose.files(
    default = "",
    caption = "Sélection du classeur de commentaires",
    filters = matrix(c("Classeur excel xlsx",".xlsx"), 1, 2, byrow = T)
  )
}


# ----- Autres ----- # TODO : à revoir
# table cycle de la forêt
Cycles_Disp <- Cycles %>% filter(NumForet == forest_num)

# last cycle & last year
last_cycle <- max(Cycles_Disp$Cycle, na.rm = T)
last_year <-
  Cycles$Annee[Cycles$NumForet == forest_num & Cycles$Cycle == last_cycle]

# nombre de placettes
plot_nb <- with(
  Placettes,
  length(unique(NumPlac[which(NumForet == forest_num & Cycle == last_cycle)]))
)

# -- nombre de sous-placettes de régénération
sub_plot_nb <- unique(with(Echantillonnages, NbSousPlac[NumForet & Cycle == last_cycle]))
sub_plot_nb <- sub_plot_nb * plot_nb

Eval_GF <- FALSE

# -- DMH figure parameters
Param_CodesEcoRare <- 8
Param_CodesEco <- 8
Param_CodesEcoCat <- 8
CodeEcolos <- CodeEcolos %>% mutate(Code = toupper(Code))


# Evaluation du bois mort :
BMP_Disp <-
  BMP %>%
  filter(NumForet == forest_num & Cycle == last_cycle)
BMortSup30_Disp <-
  BMSsup30 %>%
  filter(NumForet == forest_num & Cycle == last_cycle)
BMortLineaires_Disp <-
  BMSLineaires %>%
  filter(NumForet == forest_num & Cycle == last_cycle)
eval_BMP <- TRUE
if (dim(BMP_Disp)[1] == 0) {
  eval_BMP <- FALSE
}

eval_BMortLineaires <- TRUE
if (dim(BMortLineaires_Disp)[1] == 0) {
  eval_BMortLineaires <- FALSE
}

eval_BMortSup30 <- TRUE
if (dim(BMortSup30_Disp)[1] == 0) {
  eval_BMortSup30 <- FALSE
}

eval_BM <- TRUE
if (eval_BMP==FALSE & eval_BMortLineaires == 0 & eval_BMortSup30 == 0) {
  eval_BM <- FALSE
}

Eval_Taillis <- TRUE
if (dim(Taillis[which(Taillis$NumForet==forest_num &
                      Taillis$Cycle==last_cycle),])[1]==0) {
  Eval_Taillis <- FALSE
}

Eval_Rege <- TRUE
if (dim(Reges[which(Reges$NumForet==forest_num &
                      Reges$Cycle==last_cycle),])[1]==0) {
  Eval_Rege <- FALSE
}

# -- Evaluation des stades écorce et de décomposition :
# Eval_Stades <- F
Eval_Stades <- TRUE
df1 <-
  BMP %>%
  filter(NumForet==forest_num & Cycle == last_cycle & !is.na(Stade))
df2 <-
  BMSCercles %>%
  filter(NumForet==forest_num & Cycle == last_cycle & !is.na(Stade))
df3 <-
  BMSLineaires %>%
  filter(NumForet==forest_num & Cycle == last_cycle & !is.na(Stade))
test = dim(df1)[1] + dim(df2)[1] + dim(df3)[1]
if (test == 0) {
  Eval_Stades <- FALSE
}

# -- Evaluation Perches - Taillis
eval_Perches <- TRUE
df <- Perches %>% filter(NumForet == forest_num & Cycle == last_cycle)
if (dim(df)[1] == 0) {
  eval_Perches <- FALSE
}

Eval_Taillis <- TRUE
df <- Taillis %>% filter(NumForet == forest_num & Cycle == last_cycle)
if (dim(df)[1] == 0) {
  Eval_Taillis <- FALSE
}

# -- Evaluation partie évolution
eval_evol = ifelse(last_cycle > 1, TRUE, FALSE)

# -- eval harvesting
tmp <- 
  gfForetFpied_Coupe %>% filter(NumForet == forest_num & Cycle == last_cycle - 1 & Coupe == "E")
eval_harvest <- if (dim(tmp)[1] > 0) TRUE else FALSE

# -- eval economic values
eval_econ <- tk_messageBox(
  type = "yesno",
  message = "Editer le livret GF avec les résultats économiques ?",
  caption = "Edition des variables économiques"
)
eval_econ <- if (eval_econ == "yes") TRUE else FALSE

# -- Valeurs par défaut d'objets appelés avec \Sexpr{} :
period <- c()
VpHa_variation <- c()
VcHa_variation <- c()

# -- Evaluation partie DMH
# dmh
eval_dmh_table <- 
  Codes %>% 
  filter(NumForet == forest_num & Cycle == last_cycle)
eval_dmh <- ifelse( nrow(eval_dmh_table) == 0, FALSE, TRUE)
# note AFI
eval_note_dmh_table <- 
  eval_dmh_table %>% filter(tolower(Ref_CodeEcolo) %in% c("afi","engref"))
eval_note_dmh <- ifelse( nrow(eval_note_dmh_table) == 0, FALSE, TRUE)

# valeurs de paramètres par défaut
fig_height_parameters <- list()
fig_height_parameters$frequent_dmh_density_plot <-
fig_height_parameters$infrequent_dmh_density_plot <-
fig_height_parameters$dmh_density_by_diam_cat_plot <- 2

# -- Phrase sous la figure des dendromicrohabitats (rares ou nons -> possible qu'une des deux figures disparaissent si pas assez de DMH)
sentence <- c()

if (!eval_dmh) {
  Note_Totale = 0
  NoteForte_Totale = 0
  Indice1 = Indice2 = Indice3 = Indice4 = Indice5 = 0
}

# -- évaluation partie carbone
eval_carbon <- F

Eval_Geneve <- F # Pour besoin traitement Leforestier
eval_appendix <- T # définir manuellement

# -- titre du 2nd chapitre (selon last_cycle - evolution ou non)
title_chap2 = ifelse(
  last_cycle > 1,
  i18n()$t("Bilan et évolution du patrimoine"),
  "Bilan du patrimoine" # TODO : à traduire
)

# ----- Palette -----
df_PALETTE1 <- select(Essences,
                      Nom,Couleur) %>%
  distinct(Nom,Couleur) %>%
  rename(Essence=Nom)
df_PALETTE2 <- select(EssReg,
                      EssReg,Couleur) %>%
  distinct(EssReg,
           .keep_all=T) %>% # ,Couleur # Attention si on prend EssReg depuis Essences, on a
  rename(Essence=EssReg)

df_Palette <- filter(df_PALETTE1,
                     !is.element(Essence,df_PALETTE2$Essence)) %>%
                       rbind(df_PALETTE2) %>%
  distinct()

Palette_Essence <- df_Palette$Couleur
names(Palette_Essence) <- df_Palette$Essence


# Tri -> essence majoritaire==max de Gha
order_DF <- filter(gfForetFpied_Essence,
                   NumForet==forest_num & Cycle==last_cycle) %>%
  arrange(desc(Gha))
Essence_ORDER <- order_DF$Essence
Palette_Essence <- Palette_Essence[c(match(Essence_ORDER,names(Palette_Essence)),
                                     which(!is.element(names(Palette_Essence),Essence_ORDER)))]

@

<<aesthetics>>=
# -- filter table
Essences <- Essences %>% filter(NumForet == forest_num)
EssReg <- EssReg %>% filter(NumForet == forest_num)

# -- colour for species
df <-
  Essences %>%
  select(Nom, Reg, Couleur) %>%
  # translation
  mutate(Nom = i18n()$t(Nom)) %>%
  distinct(Nom, Couleur, .keep_all = T) %>%
  rename(EssReg = Reg)

# aesthetics
colour_aes_for_species <- df$Couleur
names(colour_aes_for_species) <- df$Nom

# -- colour for grouped species
df <-
  EssReg %>%
  filter(NumForet == forest_num) %>% 
  select(Essence, EssReg, Couleur) %>%
  distinct(Essence, Couleur, .keep_all = T) %>%
  # translation
  mutate(EssReg = i18n()$t(EssReg)) %>%
  # mutate(Essence = i18n()$t(Essence)) %>%
  distinct(EssReg, Couleur, .keep_all = T)

# aesthetics
colour_aes_for_grouped_species <- df$Couleur
names(colour_aes_for_grouped_species) <- df$EssReg

# -- colour for diameter category
diam_cat <- Cats %>% filter(NumForet == forest_num & Cat != "PER")
# couleurs
colour_aes_for_diameter_category <- diam_cat$Couleur
# labels
names(colour_aes_for_diameter_category) <- i18n()$t(diam_cat$Cat)
# sort -> ordre demandé = "TGB" "GB"  "BM"  "PB"  "PER"
colour_aes_for_diameter_category <- rev(colour_aes_for_diameter_category)

# -- colour for log qualities
qual_table <- Quals %>% distinct(Reg1, .keep_all = T)
colour_aes_for_qual1 <- qual_table$Couleur
names(colour_aes_for_qual1) <- qual_table$Reg1











# -- colours for dmh
colour_aes_for_dmh <- CodeEcolos$Couleur
names(colour_aes_for_dmh) <- i18n()$t(CodeEcolos$Descriptif)

# -- colours for deadwood types
colour_aes_for_deadwood <- c("burlywood1", "chocolate4")
names(colour_aes_for_deadwood) <- i18n()$t(c("Bois mort au sol", "Bois mort sur pied"))

# -- colours for deadwood diameter category
colour_aes_for_deadwood_diameter_category <- 
  c("Gray15", "Gray40", "Gray60", "Gray80")
names(colour_aes_for_deadwood_diameter_category) <- i18n()$t(c(
  "Bois mort sur pied ≥ 30", 
  "Bois mort au sol ≥ 30", 
  "Bois mort sur pied < 30", 
  "Bois mort au sol < 30"
))
@

<<formats>>=
MyTheme <-  
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 8), 
    axis.text.y = element_text(size = 8), 
    legend.text = element_text(size = 8), 
    axis.title.x = element_text(size = 9), 
    axis.title.y = element_text(size = 9), 
    legend.title = element_text(size = 9), 
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )

MyTheme1 <-  
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 6), 
    axis.text.y = element_text(size = 6), 
    legend.text = element_text(size = 6), 
    plot.title = element_text(size = 7), 
    axis.title.x = element_text(size = 7), 
    axis.title.y = element_text(size = 7), 
    legend.title = element_text(size = 7), 
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )

MyTheme2 <- 
  theme_bw() +
  theme(
    axis.text.x = element_blank(), 
    axis.title.x = element_blank(), 
    axis.text.y = element_text(size = 8), 
    axis.title.y = element_text(size = 9), 
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )

par(mar = c(0, 0, 0, 0))
@

<<edition_parameters>>=
# -- choix : import des images/docs annexes
# eval_imgs <- F
eval_imgs_answ <- tk_messageBox(
  type = "yesno",
  message = "Editer le livret GF avec les logos/images annexes ?",
  caption = "Edition des images"
)

# eval_imgs_answ = "no"
if (eval_imgs_answ == "yes") {
# logo AFI
GF_LOGO <- tk_choose.files(
  default = "", 
  caption = "Sélection du logo AFI", 
  multi = T
)

# photo couverture
Couverture_PHOTO <- tk_choose.files(
  default = "", 
  caption = "Choix de la photo de couverture"
)

# logo financeurs
Financeurs_LOGOS <- tk_choose.files(
  default = "", 
  caption = "Sélection du/des logo(s) du/des financeur(s)", 
  multi = T
)

# plan de situation globale
global_localisation_map <- tk_choose.files(
  default = "", 
  caption = "Choix du plan de situation globale"
)

# plan de la forêt
forest_localisation_map <- tk_choose.files(
  default = "", 
  caption = "Sélection du plan de la forêt"
)

# plan des placettes
plots_localisation_map <- tk_choose.files(
  default = "", 
  caption = "Sélection du plan des placettes"
)

# document d'analyse stationnelle
Station_Doc <- tk_choose.files(
  default = "", 
  caption = "Sélection du document d'analyse stationnelle"
)

# document d'analyse pédologique
Geol_Doc <- tk_choose.files(
  default = "", 
  caption = "Sélection de la carte géologique"
)
} else { # end of cond 'eval_imgs_answ == "yes"'
  GF_LOGO <- Couverture_PHOTO <- Financeurs_LOGOS <- Geol_Doc <- Station_Doc <- plots_localisation_map <- forest_localisation_map <- global_localisation_map <- character()
}

  if (length(Financeurs_LOGOS) == 0) {
  Financeur1_LOGO <- NA
  Financeur2_LOGO <- NA
  Couverture_WIDTH <- "15cm"
} # end of cond 'eval_imgs_answ == "yes"'

if (length(Financeurs_LOGOS) == 1) {
  Financeur1_LOGO <- Financeurs_LOGOS
  Financeur2_LOGO <- Financeurs_LOGOS
  Couverture_WIDTH <- "10cm"
}

if (length(Financeurs_LOGOS) == 2) {
  Financeur1_LOGO <- Financeurs_LOGOS[1]
  Financeur2_LOGO <- Financeurs_LOGOS[2]
  Couverture_WIDTH <- "10cm"
}
  
  # -- ancienne version
# 
interact = F
# 
# AFI_LOGO <- c()
# if (interact == T) {
#   AFI_LOGO <-
#     tk_choose.files(default = "", caption = "Sélection du logo", multi = T)
# }
# 
# 
# Couverture_PHOTO <- c()
# if (interact == T) {
#   Couverture_PHOTO <-
#     tk_choose.files(default = "", caption = "Choix de la photo de couverture")
# }
# 
# Financeurs_LOGOS <- c()
# if (interact == T) {
#   Financeurs_LOGOS <-
#     tk_choose.files(
#       default = "", caption="Sélection du/des logo(s) du/des financeur(s)", multi = T
#     )
# }
# 
# if (length(Financeurs_LOGOS) == 0) {
#   Financeur1_LOGO <- NA
#   Financeur2_LOGO <- NA
#   Couverture_WIDTH <- "15cm"
# }
# if (length(Financeurs_LOGOS) == 1) {
#   Financeur1_LOGO <- Financeurs_LOGOS
#   Financeur2_LOGO <- Financeurs_LOGOS
#   Couverture_WIDTH <- "10cm"
# }
# if (length(Financeurs_LOGOS) == 2) {
#   Financeur1_LOGO <- Financeurs_LOGOS[1]
#   Financeur2_LOGO <- Financeurs_LOGOS[2]
#   Couverture_WIDTH <- "10cm"
# }
# 
# Localisation_Globale <- c()
# if (interact == T) {
# Localisation_Globale <-
#   tk_choose.files(default = "", caption = "Choix du plan de localisation globale")
# }
# 
# Plan_Foret <- c()
# if (interact == T) {
# Plan_Foret <-
#   tk_choose.files(default = "", caption = "Sélection du plan de la forêt")
# }
# 
# Plan_Placettes <- c()
# if (interact == T) {
# Plan_Placettes <-
#   tk_choose.files(default = "", caption = "Sélection du plan des placettes")
# }
# 
# Station_Doc <- c()
# if (interact == T) {
# Station_Doc <-
#   tk_choose.files(
#     default = "", caption = "Sélection du document d'analyse stationnelle"
#     )
# }
# 
# Geol_Doc <- c()
# if (interact == T) {
# Geol_Doc <-
#   tk_choose.files(default = "", caption = "Sélection de la carte géologique")
# }
# 
# ---- Cartes de résultats :
Answer_MAPS <- "no"

if (interact == T) {
Answer_MAPS <-
  tk_messageBox(
    type = "yesno",
    message = "Souhaitez-vous ajouter des cartes de résultats (format '.jpeg') ?\n\nattention ordre de sélection !"
  )
}

Map_ListFiles <- c()
while(Answer_MAPS == "yes") {
  Map_FILE <-
    tk_choose.files(
      default = "", caption = "Sélection d'une carte de résultats",
      filters = matrix(c("jpg", ".jpg"), ncol = 2),
      multi = T
    )

  Map_ListFiles <- c(Map_ListFiles, Map_FILE)
  Answer_MAPS <-
    tk_messageBox(
      type = "yesno",
      message = "Souhaitez-vous ajouter des cartes de résultats (format '.jpeg') ?\n\nattention ordre de sélection !"
    )
}

eval_maps <- ifelse(length(Map_ListFiles) > 0, TRUE, FALSE)
  
  
# ---- Autres éléments :
# initialisation phrase pour les DMH
sentence_dmh <- c()
NumParcelle <- c()
Commune <- c()
seedlings_nb_str <- c()
@


% -- set chapter format
% classic style
\titleformat{\chapter}[frame]
{\normalsize}%
{\filright\sffamily\Large%
\enspace \Sexpr{i18n()$t("Chapitre")} \thechapter\enspace}%
{8pt}
{\sffamily\Huge\bfseries\filcenter}

% fancy style - chapter
\newcommand*{\fancychapterstyle}{%
  \titleformat{\chapter}[frame]
{\normalsize}%
{\filright\sffamily\Large%
\enspace \Sexpr{i18n()$t("Chapitre")} \thechapter\enspace}%
{8pt}
{\sffamily\Huge\bfseries\filcenter}
  \titlespacing*{\chapter}{0pt}{250pt}{80pt}
}

% fancy style - appendice
\newcommand*{\fancyappendicestyle}{%
  \titleformat{\chapter}[frame]
{\normalsize}%
{\filright\sffamily\Large%
\enspace \Sexpr{i18n()$t("Annexe")} \thechapter\enspace}%
{8pt}
{\sffamily\Huge\bfseries\filcenter}
  \titlespacing*{\chapter}{0pt}{250pt}{80pt}
}

\newcommand*{\standardchapterstyle}{%
  \titleformat{\chapter}[display]
  {\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
  \titlespacing*{\chapter}{0pt}{50pt}{40pt}
}

% -- columns types settings
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash }b{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}b{#1}}
% \newcolumntype{N}{@{}m{0pt}@{}}
\newcolumntype{N}{@{}>{\columncolor{white}[0pt][0pt]}m{0pt}@{}}
\newcolumntype{X}[1]{>{\raggedright\let\newline\\\arraybackslash}p{#1}}

% -- appendice settings
\def\appendixtocname{\Sexpr{i18n()$t("Annexes")}}
\def\appendixpagename{\Sexpr{i18n()$t("Annexes")}}
\def\appendixname{\Sexpr{i18n()$t("Annexe")}}

% -- set title translation
\addto\captionsenglish{\def\tablename{\Sexpr{i18n()$t("Tableau")}}}
\addto\captionsenglish{\def\figurename{\Sexpr{i18n()$t("Figure")}}}
\addto\captionsenglish{\def\contentsname{\Sexpr{i18n()$t("Table des matières")}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\raggedbottom
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\thispagestyle{empty}

\begin{center}
\EditIf{\Sexpr{length(GF_LOGO) > 0}}{TRUE}{
\begin{figure}[ht]
\centering
% \includegraphics[width=6cm]{/Users/bruciamacchiemax/Desktop/AFI/Images/Logos/AFI_logo}
\includegraphics[width=3cm]{\Sexpr{GF_LOGO}}
\end{figure}
}{
\vspace{6cm}
}

\vspace*{0.5cm}


\large{\textbf{\Sexpr{i18n()$t("Livret des résultats de l'inventaire forestier\\\\par placettes permanentes")}\\
- \Sexpr{last_year} -}}\\
\vspace*{0.5cm}
\Sexpr{forest_name}


\vspace*{1cm}

\EditIf{\Sexpr{length(Couverture_PHOTO) > 0}}{TRUE}{
\begin{figure*}[ht]
\begin{center}
\includegraphics[height=13cm]{\Sexpr{Couverture_PHOTO}}
%    \includegraphics[width=17cm]{/Users/bruciamacchiemax/Desktop/AFI/Images/PhotosLivret/5.jpg}
\end{center}
\end{figure*}
}{
\vspace{10cm}
}

\vfill

% \footnotesize{Placettes installées par :}\\
% \includegraphics[height=2.5cm]{Figures/Logo_JT_CabinetFL.png}
% \begin{minipage}[h]{\dimexpr.2\textwidth-\tabcolsep-.1pt}
% \bigbreak
% Valentin DEMETS\\
% Benjamin ROUVIERE\\
%\end{minipage}
%\begin{minipage}[h]{\dimexpr.1\textwidth-\tabcolsep-.1pt}
%\centering
%
% \end{minipage}
\EditIf{\Sexpr{length(Financeurs_LOGOS)}}{0}{
}{
\vspace*{0.5cm}
avec le financement de\\
\EditIf{\Sexpr{length(Financeurs_LOGOS)}}{1}{
\includegraphics[height=3cm]{\Sexpr{Financeur1_LOGO}}
}{
\begin{multicols}{2}

\begin{flushleft}
\includegraphics[height=3cm]{\Sexpr{Financeur1_LOGO}}
\end{flushleft}

\begin{flushright}
\includegraphics[height=3cm]{\Sexpr{Financeur2_LOGO}} % changement
\end{flushright}

\end{multicols}
}
}
\end{center}

% \newpage
% \thispagestyle{empty}
\pagestyle{plain}
% \clearpage
\tableofcontents


% \noindent\fbox{\parbox{\linewidth-2\fboxrule-2\fboxsep}{\centering \huge \textbf{FORÊT DE GERGY}}}\\
% \vfill

% \noindent\fbox{\parbox{\linewidth-2\fboxrule-2\fboxsep}{
% \LARGE \centering \textbf{Généralités}
% }}

\chapter{\Sexpr{i18n()$t("Généralités")}}

\section{\Sexpr{i18n()$t("Domaine d'inventaire")}}
% \textcolor{red}{Attention ici aussi, seuil de densité à 1\%}
<<Comment_1.1, results='asis',eval=Eval_Comment, include=Eval_Comment>>=
Comments <- read.xlsx(Comments_FILE, sheet="Feuil1")

#Ici dans introduction on prend le texte correspondant :
Comment <- filter(Comments, Section=="1.1")
cat(utf82LaTeX(Comment$Texte))
@

\captionsetup{labelformat=empty}
<<operators, results = 'asis', size = 'scriptsize', out.width = "\\textwidth">>=

# table contenant la liste des opérateurs pour la forêt choisie
df <-
  Cycles %>%
  # filtre par forêt
  filter(NumForet == forest_num) %>%
  select(Cycle, Annee, Operateurs) %>% 
  # calcul du nombre d'opérateurs à chaque cycle
  mutate(
    operateurs_nb = length( str_extract_all(Operateurs, pattern = "/")[[1]] ) + 1
  )

# nombre maximum d'opérateurs détecté:
operateurs_nb_max <- max(df$operateurs_nb, na.rm = T)

# -- format df
df <- 
  df %>% 
  # separate all operators
  separate(
    Operateurs, 
    into = paste0("Operateurs", 1:operateurs_nb_max), 
    sep = "/"
  ) %>% 
  # remove operateurs_nb column
  select(-operateurs_nb) %>% 
  # pivot
  pivot_longer(
    cols = -c("Cycle", "Annee"), 
    names_to = "variable", 
    values_to = "value"
  ) %>%
  # remove empty values
  filter(!is.na(value)) %>%
  # sort
  arrange(Cycle, Annee, variable)

# -- extraction des noms de tiers (et donc d'opérateurs) possibles -> TODO : mettre en place une sécurité pour les noms d'opérateurs
tiers_list <- with(Tiers, paste0(Prenom," ",Nom))

# -- liste des opérateurs du dernier inventaire
operators_list <- 
  df %>% 
  filter(Cycle == last_cycle) %>% 
  select(value) %>% 
  unlist() %>% 
  unname()
# remove NA
operators_list <- operators_list[!is.na(operators_list)]
# unknown operators
unknown_operators <- which(!operators_list %in% tiers_list)
# # security
# if (length(unknown_operators) > 0) unknown_operators_msg <- tk_messageBox(type = "ok", message = "Noms d'opérateurs non reconnus dans la table Tiers")

# date de réalisation du dernier inventaire :
date_last_inv <- 
  Cycles %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>% 
  select(Date) %>% 
  format(format = "%d/%m/%Y") %>% 
  unlist() %>% 
  unname()

# -- format final table
df2 <-
  df %>%
  set_multirow_table(c(1, 2)) %>%
  select(Cycle, Annee, value) %>%
  mutate(Vide = NA) %>% # Création colonne vide pour mise en forme tableau
  
  # rename/translate columns
  rename(
    "\\rowcolor{LightGray} Cycle" = "Cycle", 
    !!i18n()$t("Année") := "Annee", 
    !!i18n()$t("Opérateurs") := "value", 
    " " = "Vide"
  )

# line position (<-> print table)
pos_Lines <- which(!is.na(df2[, i18n()$t("Année")]))
if (is.element(1, pos_Lines)) {
  pos_Lines <- pos_Lines[-which(pos_Lines == 1)]
}
# commande pour régler la hauteur de la première ligne :
pos = list(0)
command = "[3ex]\n\\hline"


print(
  xtable(
    df2, 
    caption = i18n()$t("Ce dispositif a été mis en place et mesuré par les opérateurs suivants :"), 
    digits = rep(0, dim(df2)[2] + 1), 
    align = c("M{0cm}|", "|M{2cm}|", "M{2cm}|", "M{6cm}|", "N"), 
    label = "TabOperateurs"
  ), 
  include.rownames = FALSE, 
  caption.placement = "top", 
  sanitize.text.function = function(x) {return(x)}, 
  hline.after = c(-1, pos_Lines - 1, nrow(df2)), 
  floating = T, 
  add.to.row = list(
    pos = pos, 
    command = command), 
  size = "\\normalsize"
)
@
\captionsetup{labelformat=default}
%\vspace{1cm}
% \vfill
%%%%%%%%%%%%%%%%%%%%%
% \begin{figure}[H]
\EditIf{\Sexpr{length(global_localisation_map) > 0}}{TRUE}{
\section{\Sexpr{i18n()$t("Plan de situation")}}
\begin{center}
% \textbf{Plan de situation (1/\np{200000})}
\includegraphics[width=\textwidth]{\Sexpr{global_localisation_map}}
\end{center}
% \end{figure}
}{}

\newpage


% \invisiblesection{Plan de localisation}
\EditIf{\Sexpr{length(forest_localisation_map) > 0}}{TRUE}{
\section{\Sexpr{i18n()$t("Plan de localisation")}}
\begin{center}
\includegraphics[width=\textwidth]{\Sexpr{forest_localisation_map}}
\end{center}
}{}



\EditIf{\Sexpr{length(plots_localisation_map) > 0}}{TRUE}{
 \invisiblesection{\Sexpr{i18n()$t("Plan des placettes")}}
\includepdf[pages=-]{\Sexpr{plots_localisation_map}}
\clearpage
}{}
\EditIf{\Sexpr{length(Station_Doc) > 0}}{TRUE}{
 \invisiblesection{\Sexpr{i18n()$t("Stations")}}
\includepdf[pages=-]{\Sexpr{Station_Doc}}
}{}
\EditIf{\Sexpr{length(Geol_Doc) > 0}}{TRUE}{
 \invisiblesection{\Sexpr{i18n()$t("Géologie")}}
\includepdf[pages=-]{\Sexpr{Geol_Doc}}
}{}
\clearpage

<<Photos_Supplementaires,echo=F,message=F,results='asis',eval=T,include=T>>=
# Photo1=paste0(repAFI,"/Images/1.jpg")
# Photo2=paste0(repAFI,"/Images/3.jpg")
# Photo3=paste0(repAFI,"/Images/4.jpg")
# Photo4=paste0(repAFI,"/Images/5.jpg")

# Title1="Photo 1"
# Title2="Photo 2"
# Title3="Photo 3"
# Title4="Photo 4"

if (eval_imgs_answ == "yes") {
Disp_PHOTOS <- tk_choose.files(
  default="",
  caption="Sélection des photos à rajouter (4 maximum)",
  # filters=matrix(c(".JPG",".jpg",
  #                  ".PDF",".pdf",
  #                  ".PNG",".png"),
  #             3,2,byrow=T),
  multi=T
)
} else Disp_PHOTOS <- c()

if (length(Disp_PHOTOS) == 0) {
  Disp1_PHOTO <- NA
  Disp2_PHOTO <- NA
  Disp3_PHOTO <- NA
  Disp4_PHOTO <- NA
}
if (length(Disp_PHOTOS) == 1) {
  Disp1_PHOTO <- Disp_PHOTOS[1]
  Disp2_PHOTO <- NA
  Disp3_PHOTO <- NA
  Disp4_PHOTO <- NA
}
if (length(Disp_PHOTOS) == 2) {
  Disp1_PHOTO <- Disp_PHOTOS[1]
  Disp2_PHOTO <- Disp_PHOTOS[2]
  Disp3_PHOTO <- NA
  Disp4_PHOTO <- NA
}
if (length(Disp_PHOTOS) == 3) {
  Disp1_PHOTO <- Disp_PHOTOS[1]
  Disp2_PHOTO <- Disp_PHOTOS[2]
  Disp3_PHOTO <- Disp_PHOTOS[3]
  Disp4_PHOTO <- NA
}
if (length(Disp_PHOTOS) == 4) {
  Disp1_PHOTO <- Disp_PHOTOS[1]
  Disp2_PHOTO <- Disp_PHOTOS[2]
  Disp3_PHOTO <- Disp_PHOTOS[3]
  Disp4_PHOTO <- Disp_PHOTOS[4]
}
@

\EditIf{\Sexpr{length(Disp_PHOTOS)}}{0}{

}{

%%%%%%%%%%

\EditIf{\Sexpr{length(Disp_PHOTOS)}}{1}{

\includegraphics[width=\textwidth]{\Sexpr{Disp1_PHOTO}}

}{

%%%%%%%%%%

\EditIf{\Sexpr{length(Disp_PHOTOS)}}{2}{

\begin{multicols}{2}

\begin{flushleft}
\includegraphics[width=0.45\textwidth]{\Sexpr{Disp1_PHOTO}}
\end{flushleft}

\begin{flushright}
\includegraphics[width=0.45\textwidth]{\Sexpr{Disp2_PHOTO}} % changement
\end{flushright}

\end{multicols}

}{

%%%%%%%%%%

\EditIf{\Sexpr{length(Disp_PHOTOS)}}{3}{

\begin{figure}[ht!]
\centering
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp1_PHOTO}}
% \caption{Title2}\label{fig:Title2}
\end{subfigure}
~ % ce symbole ajoute un espacement horisontal entre les premières deux images
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp2_PHOTO}}
% \caption{Title4}\label{fig:Title4}
\end{subfigure}

% la ligne blanche correspond au retour à la ligne après le deuxième image
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp3_PHOTO}}
% \caption{Title3}\label{fig:Title3}
\end{subfigure}
\end{figure}

}{

%%%%%%%%%%

\EditIf{\Sexpr{length(Disp_PHOTOS)}}{4}{

\begin{figure}[ht!]
\centering
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp1_PHOTO}}
% \caption{\Sexpr{Title2}}\label{fig:\Sexpr{Title2}}
\end{subfigure}
~ % ce symbole ajoute un espacement horisontal entre les premières deux images
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp2_PHOTO}}
% \caption{\Sexpr{Title4}}\label{fig:\Sexpr{Title4}}
\end{subfigure}

% la ligne blanche correspond au retour à la ligne après le deuxième image
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp3_PHOTO}}
% \caption{\Sexpr{Title3}}\label{fig:\Sexpr{Title3}}
\end{subfigure}
~
\begin{subfigure}[b]{0.45\textwidth}
\includegraphics[width=\textwidth]{\Sexpr{Disp4_PHOTO}}
% \caption{\Sexpr{Title1}}\label{fig:\Sexpr{Title1}}
\end{subfigure}
\end{figure}

}{}
}
}
}
}


\clearpage

\section{\Sexpr{i18n()$t("Commentaires des résultats")}}
<<Comment_1.7, echo=F,message=F,results='asis',eval=Eval_Comment,include=Eval_Comment>>=
Comments <- read.xlsx(Comments_FILE,
                      sheet="Feuil1")

#Ici dans introduction on prend le texte correspondant :
Comment <- filter(Comments, Section=="1.6")
cat(utf82LaTeX(Comment$Texte))
@
\subsection{\Sexpr{i18n()$t("Aspects sylvicoles")}}
<<Comment_1.7.1, echo=F,message=F,results='asis',eval=Eval_Comment,include=Eval_Comment>>=
Comments <- read.xlsx(Comments_FILE,
                      sheet="Feuil1")

#Ici dans introduction on prend le texte correspondant :
Comment <- filter(Comments, Section=="1.7.1")
cat(utf82LaTeX(Comment$Texte))
@

\vspace{0.2cm}





\subsection{\Sexpr{i18n()$t("Aspects écologiques")}}
<<Comment_1.7.2, results = 'asis', eval = Eval_Comment, include = Eval_Comment>>=
Comments <- read.xlsx(Comments_FILE,  sheet = "Feuil1")

# -- extract paragraph
Comment <- filter(Comments, Section == "1.7.2")

# -- print text
cat(utf82LaTeX(Comment$Texte))
@
\clearpage

\chapter{\Sexpr{title_chap2}}

<<stack_species_data>>=
# N.B : species for current period only

# -- arbres
species_in_standing_wood <-
  gfForetFpied_Essence %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(Essence, Gha) %>%
  # remove null values
  filter(Gha != 0) %>% 

  mutate(
    Population = i18n()$t("Précomptables "),
    Gha = round(Gha, 2),

  # translation
  Essence = i18n()$t(Essence)
  ) %>%
  rename(Valeur = Gha) %>%
  arrange(-Valeur)

# -- sous-ensemble d'essences faisant au moins 15% de la surface terrière :
threshold_ba <- 0.10 # 1
majority_species <- with(
  species_in_standing_wood,
  Essence[which(Valeur >= threshold_ba * sum(Valeur))]
)

majority_species <-
  species_in_standing_wood %>%
  filter(Valeur >= threshold_ba * sum(Valeur)) %>%
  arrange(-Valeur) %>%
  select(Essence) %>%
  unlist() %>%
  unname()

main_species <- majority_species[1]
# main_species <- i18n()$t(majority_species[1]) # TODO

# -- perches
species_in_stems <-
  gfForetPer_Essence %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(Essence, Nha) %>%
  mutate(
    Population = i18n()$t("Perches"),
    # Gha = round(Gha, 1),

  # translation
  Essence = i18n()$t(Essence)
  ) %>%
  rename(Valeur = Nha) %>%
  arrange(-Valeur)

# -- taillis
species_in_coppice <-
  if (Eval_Taillis) {
    gfForetTaillis_Essence %>%
      filter(Cycle == last_cycle & NumForet == forest_num) %>%
      select(Essence, Nha) %>%
      mutate(
        Population = i18n()$t("Taillis"),
        # Nha = round(Nha, 0), #

        # translation
        Essence = i18n()$t(Essence)
      ) %>%
      rename(Valeur = Nha)
  } else {
    species_in_standing_wood[0, ]
  }

# -- regeneration
species_in_regeneration <-
  gfForetRege_EssenceRejet %>%
  filter(Cycle == last_cycle & NumForet == forest_num & Rejet == 0) %>%
  filter(!(Classe1Ha == 0 & Classe2Ha == 0 & Classe3Ha == 0)) %>%
  select(Essence, Classe1Ha, Classe2Ha, Classe3Ha) %>%

  # sort species
  arrange(desc(Classe3Ha), desc(Classe2Ha), desc(Classe1Ha)) %>%

  rename(
    "Classe 1" = "Classe1Ha",
    "Classe 2" = "Classe2Ha",
    "Classe 3" = "Classe3Ha"
  ) %>%
  pivot_longer(
    cols = -"Essence",
    names_to = "Population",
    values_to = "Valeur"
  ) %>%
  mutate(
    Valeur = round(Valeur, 0),

    # translation
    Essence = i18n()$t(Essence),
    Population = i18n()$t(Population)
  )

# -- total
species_main_results_table <- rbind(
  species_in_standing_wood,
  species_in_stems,
  species_in_coppice,
  species_in_regeneration
)
@

<<global_composition_set_up>>=
# préparation hauteur du chunk suivant :
global_composition_table <-
  species_main_results_table %>%
  group_by(Population) %>%
  mutate(
    Valeur = ifelse(Valeur == 0, NA, Valeur),
    value_sum = sum(Valeur, na.rm = T),
    value_rel = Valeur / value_sum
  ) %>%
  ungroup()

species_nb <- length(unique(global_composition_table$Essence))

# -- paramètres pour équilibrer le paramètre fig.height en fonction du nombre d'essences dans la figures qui suit
fig_height_param_lookup_table <- data.frame(
  species_nb = seq(0, 40)
) %>%
  mutate(
    class = cut(
      species_nb,
      breaks = c(-Inf, seq(5, 35, 5), Inf),
      labels = c(1, seq(5, 35, 5)),
      right = F
    ),
    fig_height = cut(
      species_nb,
      breaks = c(-Inf, seq(5, 35, 5), Inf),
      labels = c(3, 3, seq(3, 8)),
      right = F
    )
  )
# -- paramètre fig.height en fonction du nombre de species dans les figures
# look up table
look_up_for_heights_table <- tibble(
  elements_nb = seq(0, 45),
  fig_height = cut(
    elements_nb,
    breaks = c(-Inf, seq(5, 35, 5), Inf),
    labels = c(3, 3, seq(3, 8)),
    right = F
  )
) %>%
  mutate(fig_height = as.numeric(as.character(fig_height)))
# list fig_height_parameters (à compléter ensuite)
fig_height_parameters <- list()
fig_height_parameters$global_composition <- with(
  look_up_for_heights_table,
  fig_height[match(species_nb, elements_nb)]
)
@

<<sort_species>>=
# -- tri par ordre décroissant des essences dans les résultats de régénération
regeneration_main_results_by_species <-
  gfForetRege_EssenceRejet %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  filter(!(Classe1Ha == 0 & Classe2Ha == 0 & Classe3Ha == 0)) %>%
  mutate(
    Classe1Ha = round(Classe1Ha, 0),
    Classe2Ha = round(Classe2Ha, 0),
    Classe3Ha = round(Classe3Ha, 0),
    Total = round(Classe1Ha + Classe2Ha + Classe3Ha, 0)
  ) %>%
  arrange(Rejet, desc(Total)) %>%

  mutate(
    Classe1Ha = ifelse(Classe1Ha == 0, NA, Classe1Ha),
    Classe2Ha = ifelse(Classe2Ha == 0, NA, Classe2Ha),
    Classe3Ha = ifelse(Classe3Ha == 0, NA, Classe3Ha),
    Total = ifelse(Total == 0, "", Total),
    Total_Mark = Total,

    Total = paste0("\\cellcolor{LightGray}{\\textbf{", Total, "}}"),

    # translation
    Essence = i18n()$t(Essence)
  ) %>%
  select(Essence, Classe1Ha, Classe2Ha, Classe3Ha, Total, Rejet, Total_Mark)

# -- tri par ordre décroissant des essences regroupées dans les résultats de régénération
# TODO : faire une fonction pour construire ces tables selon Essence ou EssReg
regeneration_main_results_by_grouped_species <-
  gfForetRege_EssRegRejet %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  filter(!(Classe1Ha == 0 & Classe2Ha == 0 & Classe3Ha == 0)) %>%
  mutate(
    Classe1Ha = round(Classe1Ha, 0),
    Classe2Ha = round(Classe2Ha, 0),
    Classe3Ha = round(Classe3Ha, 0),
    Total = round(Classe1Ha + Classe2Ha + Classe3Ha, 0)
  ) %>%
  arrange(Rejet, desc(Total)) %>%

  mutate(
    Classe1Ha = ifelse(Classe1Ha == 0, NA, Classe1Ha),
    Classe2Ha = ifelse(Classe2Ha == 0, NA, Classe2Ha),
    Classe3Ha = ifelse(Classe3Ha == 0, NA, Classe3Ha),
    Total = ifelse(Total == 0, "", Total),
    Total_Mark = Total,

    Total = paste0("\\cellcolor{LightGray}{\\textbf{", Total, "}}"),

    # translation
    Essence = i18n()$t(EssReg)
  ) %>%
  select(Essence, Classe1Ha, Classe2Ha, Classe3Ha, Total, Rejet, Total_Mark)

eval_regen <- if (nrow(regeneration_main_results_by_grouped_species) > 0) T else F

# -- sauvegarde ordre des essences pour la régé :
sorted_species_in_regeneration <- unique(regeneration_main_results_by_species$Essence)

# -- essences à régénérer
# species_to_regenerate <-
#   EssRegeneration %>%
#   filter(NumForet == forest_num) %>%
#   select(Essence) %>%
#   mutate(
#     # translation
#     Essence = i18n()$t(Essence),
#
#     Essence = factor(
#       Essence,
#       levels = c(
#         sorted_species_in_regeneration,
#         setdiff(names(colour_aes_for_species), sorted_species_in_regeneration)
#       )
#     )
#   ) %>%
#   arrange(Essence) %>%
#   unlist() %>%
#   unname()

# if (length(species_to_regenerate) == 0) {
  # species_to_regenerate <- main_species # voir plus bas changement définition
# }

# -- essences triées par Gha décroissant
standing_trees_species_order <- # ancien Essences_ORDER1
  gfForetFpied_Essence %>%
  complete(Essence, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  arrange(-Gha) %>%
  select(Essence) %>%
  unlist() %>%
  unname()

# -- essences triées par classe 1 décroissante (régénération - viable)
regen_species_order <-
  gfForetRege_EssenceRejet %>%
  # gfForetRege_EssRegRejet %>% mutate(Essence = EssReg) %>%  # livret Morgan
  complete(Essence, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num & Rejet == 0) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  arrange(-Classe1Ha) %>%
  select(Essence) %>%
  unlist() %>%
  unname()

# -- deadwood species order
deadwood_species_order <-
  gfForetBM_Essence %>%
  complete(Essence, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  arrange(-Vha_total) %>%
  select(Essence) %>%
  unlist() %>%
  unname()
# -- deadwood grouped species order
deadwood_grouped_species_order <-
  gfForetBM_EssReg %>% rename(Essence = EssReg) %>% 
  complete(Essence, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  arrange(-Vha_total) %>%
  select(Essence) %>%
  unlist() %>%
  unname()

# deadwood_species_order <- sort(unique(table$Essence))
pop_order <- c("BMSinf", "BMSsup", "BMPinf", "BMPsup")

# -- main order
main_species_order <- c( # ancien Essences_ORDER
  standing_trees_species_order,
  setdiff(regen_species_order, standing_trees_species_order)
)
# rajout des essences manquantes
main_species_order <- c(
  main_species_order,
  setdiff(species_main_results_table$Essence, main_species_order)
)

# -- grouped species order
# grouped_species_order <- with(
#   EssReg,
#   EssReg[match(main_species_order, Essence)]
#   )

standing_trees_grouped_species_order <- # ancien Essences_ORDER1
  gfForetFpied_EssReg %>%
  complete(EssReg, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%

  # translation
  mutate(EssReg = i18n()$t(EssReg)) %>%

  arrange(-Gha) %>%
  select(EssReg) %>%
  unlist() %>%
  unname()

regen_grouped_species_order <- with(
  EssReg %>% mutate(Essence = i18n()$t(Essence), EssReg = i18n()$t(EssReg)),
  unique( EssReg[match(regen_species_order, Essence)] )
)

grouped_species_order <- c(
  standing_trees_grouped_species_order,
  setdiff(regen_grouped_species_order, standing_trees_grouped_species_order)
)

# grouped majority species (cas si Epicéa C et Epicéa S rassemblés en Epicéa)
grouped_majority_species <-
  gfForetFpied_EssReg %>%
  complete(EssReg, nesting(NumForet, Foret, Cycle)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  
  filter(Gha >= threshold_ba * sum(Gha, na.rm = T)) %>%
  arrange(-Gha) %>%
  select(EssReg) %>%
  
  # # cas Chêne (sessile et pédonculé non distingués au stade semis) -> modifié. A présent "Chêne" est mis dans la colonne Essence de la régé
  # mutate(EssReg = case_when(
  #   EssReg %in% c("Chêne S", "Chêne P") ~ "Chêne",
  #   TRUE ~ EssReg
  # )) %>% 
  
  distinct() %>% 
  unlist() %>%
  i18n()$t() %>% 
  unname() %>% 
  unique()

species_to_regenerate <- grouped_majority_species # grouped_majority_species[1]
# modification si Chêne S ou  Chêne P inscrit dans les essences à régénérer
species_to_regenerate <- str_replace_all(species_to_regenerate, "Chêne S", "Chêne")
species_to_regenerate <- str_replace_all(species_to_regenerate, "Chêne P", "Chêne")
species_to_regenerate <- unique(species_to_regenerate)

# définition manuelle
if (forest_num == 16) species_to_regenerate <- c("Chêne", "Charme", "Frêne", "Alisier T")
if (forest_num == 15) species_to_regenerate <- c("Chêne", "Charme", "Frêne", "Merisier")
if (forest_num == 17) species_to_regenerate <- c("Chêne", "Charme", "Tremble")
if (forest_num == 18) species_to_regenerate <- c("Chêne", "Charme", "Hêtre", "Frêne", "Tremble")
if (forest_num == 21) species_to_regenerate <- c("Erable", "Frêne", "Charme", "Merisier", "Chêne")
if (forest_num == 22) species_to_regenerate <- c("Chêne", "Hêtre", "Erable C", "Frêne")
if (forest_num == 23) species_to_regenerate <- c("Chêne", "Erable P", "Erable C", "Merisier", "Erable S")
if (forest_num == 24) species_to_regenerate <- c("Pin M", "Châtaignier", "Pin L", "Chêne", "Pin S", "Chêne R")

ok <- tk_messageBox(type = "ok", message = "attention : caler les essences à régénérer (species_to_regenerate)")
# species_to_regenerate <- c("Chêne", "Hêtre", "Charme", "Epicéa", "Pin S", "Sapin P")
@

\section{ \Sexpr{i18n()$t("Capital sur pied")} }
\subsection{ \Sexpr{i18n()$t("Variables dendrométriques")} }
\subsubsection{ \Sexpr{i18n()$t("En")} \Sexpr{last_year} }
% \textcolor{red}{Utiliser le même plan que pour le livret AFI ?}
 \Sexpr{i18n()$t("Le tableau")} \ref{standing_trees_dendrometric_results_table}  \Sexpr{i18n()$t("présente les résultats sur les principales variables dendrométriques pour le dernier inventaire")}.

<<standing_trees_dendrometric_results_table, results = 'asis'>>=
attribute <- "dendrometric"
label = "standing_trees_dendrometric_results_table"

# -- caption
add_to_caption <- if (last_cycle > 1) {
  i18n()$t("\\\\AcctG = Accroissement en surface terrière (m\\up{2}/ha/an)\\\\AcctV = Accroissement en volume (m\\up{3}/ha/an)}")
} else "}"
caption <- paste0(
  i18n()$t("Principales caractéristiques dendrométriques des tiges précomptables, avec leur précision.\\\\\\scriptsize{N = nombre de tiges (tiges / ha), G = surface terrière (m\\up{2} / ha), V = volume (m\\up{3} / ha)"),
  add_to_caption
)


main_dendrometric_results <- print_main_results_table(
  table = gfForetFpied_,
  cycles_table = Cycles,
  attribute = "dendrometric",
  forest_num = forest_num,
  last_cycle = last_cycle,
  label = label,
  caption = caption
)
@

\Sexpr{i18n()$t("La figure")} \ref{fig:dendro_var_boxplot} \Sexpr{i18n()$t("illustre la variabilité des principales composantes dendrométriques à l'échelle du dispositif, soit")} \Sexpr{plot_nb} \Sexpr{i18n()$t("placettes.")}\\
\emph{\Sexpr{i18n()$t("La médiane de chaque variable est représentée par le trait horizontal au milieu de chaque boîte à moustache. Les côtés de la boîte (bas et haut) représentent respectivement le premier et le dernier quartile des résultats obtenus par placettes.")}}

<<dendro_var_boxplot, size = 'footnotesize', fig.height = 2, fig.width = ifelse(last_cycle == 1, 4.5, 7), fig.cap = i18n()$t("Variabilité des principales caractéristiques dendrométriques pour les tiges précomptables")>>=
# -- table
boxplot_table <-
  gfPlaFpied_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(-NumPlac) %>%
  pivot_longer(
    cols = -c("NumForet", "Cycle"),
    names_to = "variable",
    values_to = "value"
  )

# -- plots
# densité de tiges
p1 <- build_box_plot(table = boxplot_table, var = "Nha", y_axis_name = i18n()$t("(tiges/ha)"))
# surface terrière
p2 <- build_box_plot(table = boxplot_table, var = "Gha", y_axis_name = i18n()$t("(m2/ha)"))
# volume
p3 <- build_box_plot(table = boxplot_table, var = "Vha", y_axis_name = i18n()$t("(m3/ha)"))
if (last_cycle > 1) {
  # acct surface terrière
  p4 <- build_box_plot(table = boxplot_table, var = "AcctGper", y_axis_name = i18n()$t("(m2/ha/an)"))
  # acct volume
  p5 <- build_box_plot(table = boxplot_table, var = "AcctVper", y_axis_name = i18n()$t("(m3/ha/an)"))

  # -- arrange grid
  grid.arrange(p1, p2, p3, p4, p5, widths = c(1, 1, 1, 1, 1))
} else {
  grid.arrange(p1, p2, p3, widths = c(1, 1, 1))
}

@

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsubsection{ \Sexpr{i18n()$t("Evolution")} }
\Sexpr{i18n()$t("Le tableau")} \ref{Tab_GestionPassee_Prec} \Sexpr{i18n()$t("retrace l'évolution des principales composantes dendrométriques des précomptables au cours des différents inventaires.")}

<<Tab_GestionPassee_Prec, size = 'footnotesize', results = 'asis'>>=

# -- table : résultats des précomptables au cours des inventaires
df1 <-
  # initialisation
  gfForetFpied_ %>%
  filter(NumForet == forest_num) %>%
  left_join(Cycles[, c("NumForet", "Cycle", "Annee")], # "Mesure Houppiers"
    by = c("NumForet", "Cycle")
  ) %>%
  # rename("Mesure_Houppiers" = "Mesure Houppiers") %>%

  # calculs
  mutate(
    Nha = as.character( round(Nha, 0) ),
    Gha = as.character( round(Gha, 1) ),
    Vha = as.character(round(Vha) )
  ) %>%
  select(Annee, Nha, Gha, Vha) %>%
  pivot_longer(
    cols = -c("Annee"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  pivot_wider(
    id_cols = "variable",
    names_from = "Annee",
    values_from = "value"
  )

# -- table : Gha par Reg2 au cours des inventaires
df2 <-
  gfForetFpied_Reg1 %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  left_join(
    Quals[, c("Nom", "Reg2")],
    by = c("Reg1" = "Nom")
  ) %>%
  select(Annee, Reg2, Gha) %>%

  # somme par années et par qualité regroupées
  group_by(Annee, Reg2) %>%
  summarise(Gha = sum(Gha)) %>%
  # somme par années
  group_by(Annee) %>%
  mutate(Gha_Tot = sum(Gha)) %>%

  # part relative par années et par qualité regroupées
  group_by(Annee, Reg2) %>%
  mutate(
    Gha_Part = round(Gha/Gha_Tot*100),
    Gha = round(Gha, 1)
  ) %>%
  ungroup() %>%

  # sélection et pivots
  select(-one_of("Gha_Tot")) %>%
  pivot_longer(
    cols = c("Gha", "Gha_Part"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  pivot_wider(
    id_cols = "Annee",
    names_from = c("variable", "Reg2"),
    values_from = "value"
  ) %>%
  select(-one_of("Gha_Part_C+D")) %>%
  pivot_longer(
    cols = -c("Annee"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(value = as.character(value)) %>%
  pivot_wider(
    id_cols = "variable",
    names_from = "Annee",
    values_from = "value"
  )

# -- table : Gha de l'essence principale par Reg2 au cours des inventaires
df2_EssencePrinc <-
  gfForetFpied_EssenceReg1 %>%
  filter(NumForet == forest_num) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  left_join(
    Quals[, c("Nom", "Reg2")],
    by = c("Reg1" = "Nom")
  ) %>%
  select(Annee, Essence, Reg2, Gha) %>%
  mutate(
    Gha = round(Gha, 1),
    Essence_Mark = ifelse(Essence == main_species, Essence, "Autres")
  ) %>%
  group_by(Annee, Essence_Mark, Reg2) %>%
  summarise(Gha = sum(Gha)) %>%
  ungroup() %>%
  filter(Essence_Mark == main_species)

# alibi - sécurité si A+B = 0
Qual2_ALIBI <- with(
  df2_EssencePrinc,
  expand.grid(
    Annee = unique(Annee),
    Essence_Mark = unique(Essence_Mark),
    Reg2 = c("A+B", "C+D"),
    stringsAsFactors = F
  )
) %>%
  data.frame()

# -- table : Gha de l'essence principale au cours des inventaires
df2_EssencePrinc <-
  df2_EssencePrinc %>%
  full_join(
    Qual2_ALIBI,
    by = c("Annee", "Essence_Mark", "Reg2")
  ) %>%
  select(-one_of("Essence_Mark")) %>%
  pivot_longer(
    cols = -c("Annee", "Reg2"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  pivot_wider(
    id_cols = "Annee",
    names_from = c("variable", "Reg2"),
    values_from = "value"
  ) %>%
  select(-one_of("Gha_C+D")) %>%
  pivot_longer(
    cols = -c("Annee"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  pivot_wider(
    id_cols = "variable",
    names_from = "Annee",
    values_from = "value"
  ) %>%
  mutate(variable = ifelse(variable == "Gha_A+B", "Gha_A+B_main_species", variable))

df2 <- rbind(df2, df2_EssencePrinc)

# -- table : Gha par catégorie de diamètre au cours des inventaires
df3 <-
  gfForetFpied_Cat %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  select(Annee, Cat, Gha) %>%
  group_by(Annee) %>%
  mutate(Gha_Tot = sum(Gha)) %>%
  group_by(Annee, Cat) %>%
  mutate(Gha_Part = round(Gha / Gha_Tot * 100)) %>%
  ungroup() %>%
  select(Annee, Cat, Gha_Part) %>%
  # sort
  mutate(Cat = factor(Cat, levels = c("PB", "BM", "GB", "TGB"))) %>%
  arrange(Cat) %>%
  pivot_wider(
    id_cols = "Annee",
    names_from = "Cat",
    values_from = "Gha_Part"
  ) %>%
  pivot_longer(
    cols = -c("Annee"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  pivot_wider(
    id_cols = "variable",
    names_from = "Annee",
    values_from = "value"
  )

# -- stack tables
df <- rbind(
  df1, df2
) %>%
  rbind(df3) %>%
  mutate(
  variable = as.character(variable),

  variable = ifelse(variable == "Nha", i18n()$t("N"), variable),
  variable = ifelse(variable == "Gha", i18n()$t("G"), variable),
  variable = ifelse(variable == "Vha", i18n()$t("V"), variable),
  variable = ifelse(variable == "Couvert", i18n()$t("Couvert"), variable),
  variable = ifelse(
    variable == "Gha_Part_A+B",
    paste0( "\\hline\n", i18n()$t("\\% G (A+B)") ),
    variable
  ),
  variable = ifelse(variable == "Gha_A+B", i18n()$t("G (A+B)"), variable),
  variable = ifelse(variable == "Gha_C+D", i18n()$t("G (C+D)"), variable),
  variable = ifelse(
    variable == "Gha_A+B_main_species",
    paste(i18n()$t("G"), main_species, i18n()$t("(A+B)")),
    variable
  ),
  variable = ifelse(
    variable == "PB",
    paste0("\\hline\n", i18n()$t("\\% PB")),
    variable
  ),
  variable = ifelse(variable == "BM", i18n()$t("\\% BM"), variable),
  variable = ifelse(variable == "GB", i18n()$t("\\% GB"), variable),
  variable = ifelse(variable == "TGB", i18n()$t("\\% TGB"), variable),

  # translation
  # variable = i18n()$t(variable),

  variable = factor(
    variable,
    levels = c(
      i18n()$t("N"),
      i18n()$t("G"),
      i18n()$t("V"),
      i18n()$t("Couvert"),
      paste0( "\\hline\n", i18n()$t("\\% G (A+B)") ),
      i18n()$t("G (A+B)"),
      i18n()$t("G (C+D)"),
      paste( i18n()$t("G"), main_species, i18n()$t("(A+B)") ),
      paste0( "\\hline\n", i18n()$t("\\% PB") ),
      i18n()$t("\\% BM"),
      i18n()$t("\\% GB"),
      i18n()$t("\\% TGB")
    )
  )
) %>%
  # arrange(variable) %>%
  rename("\\rowcolor{LightGray} " = "variable")

pos_NAME <- which(names(df) != "\\rowcolor{LightGray} ")
names(df)[pos_NAME] <- paste0("\\textbf{", names(df)[pos_NAME], "}")

# -- print table
print(
  xtable(
    df,
    digits = c(0, rep(0, dim(df)[2])),
    align = c("M{0cm}", "|M{2.5cm}|", rep("M{1cm}|", dim(df)[2] - 1)),
    caption = i18n()$t("Evolution du matériel sur pied"),
    label = "Tab_GestionPassee_Prec"
  ),
  table.placement = "H",
  caption.placement = "bottom",
  hline.after = -1:dim(df)[1],
  sanitize.text.function = function(x) {return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)
@

<<Hist_GestionPassee_set_up>>=
# -- Paramétrage largeur chunk suivant :
width_PARAM <- 2
if (last_cycle == 1) {
  width_PARAM <- 2
}
if (last_cycle == 2) {
  width_PARAM <- 3.25
}
if (last_cycle == 3) {
  width_PARAM <- 4.5
}
if (last_cycle == 4) {
  width_PARAM <- 5.75
}
if (last_cycle > 4) {
  width_PARAM <- 7
}
@

\Sexpr{i18n()$t("La figure")} \ref{fig:Hist_GestionPassee} \Sexpr{i18n()$t("représente l'évolution de la répartition de la surface terrière entre les précomptables de qualité A+B, les perches de qualité A+B, les précomptables de qualité C+D, les perches de qualité C+D et le taillis.")}

<<Hist_GestionPassee, size = 'footnotesize', fig.pos = "H", fig.height = 4, fig.width=width_PARAM, fig.cap = i18n()$t("Suivi de la répartition de la surface terrière entre les différentes qualités au cours du temps"), eval = eval_evol, include = eval_evol>>=
# %%%%%%%%%% Précomptables :
df1 <-
  gfForetFpied_Reg2 %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  mutate(Population = Reg2) %>%
  select(Annee, Population, Gha)

df2 <-
  gfForetPer_Reg2 %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  mutate(Population = paste(i18n()$t("Perches"), Reg2)) %>%
  select(Annee, Population, Gha)

df3 <-
  gfForetTaillis_ %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  mutate(Population = i18n()$t("Taillis")) %>%
  select(Annee, Population, Gha)

df <- rbind(
  df1, df2, df3
) %>%
  mutate(
    Population = factor(
      Population,
      levels = c(
        i18n()$t("Taillis"),
        paste(i18n()$t("Perches"), "C+D"),
        "C+D",
        paste(i18n()$t("Perches"), "A+B"),
        "A+B"
      )),
    Annee = factor(Annee)
  )

Palette_Hist_GestionPassee <-
  c("red2", "darkgreen", "darkviolet", "darkseagreen1", "navajowhite4")
names(Palette_Hist_GestionPassee) <- c(
  "A+B", "C+D",
  paste(i18n()$t("Perches"), "A+B"),
  paste(i18n()$t("Perches"), "C+D"),
  i18n()$t("Taillis")
)

Y <-
  df %>%
  group_by(Annee) %>%
  summarise(Gha = sum(Gha)) %>%
  ungroup() %>%
  select(Gha) %>%
  filter(Gha == max(Gha)) %>%
  unlist()

ggplot() +
  geom_bar(
    df,
    mapping = aes(Annee, Gha, fill = Population),
    position = "stack", stat = "identity", width = 0.5
  ) + #, width = 0.7
  scale_y_continuous(
    limits = c(0, Y * 1.1),
    breaks = seq(0, Y * 1.3, 2.5)
  ) +
  scale_fill_manual(
    name = NULL,
    values = Palette_Hist_GestionPassee
  ) +
  # coord_flip() +
  guides(
    fill = guide_legend(
      reverse = T,
      nrow = ifelse(width_PARAM < 4.5, 2, 1)
    )
  ) +
  labs(x = i18n()$t("Années d'inventaire"), y = i18n()$t("G (m2/ha)")) +
  theme_bw() + MyTheme +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
@

\Sexpr{i18n()$t("La figure")} \ref{fig:Hist_GestionPassee_Effectif} \Sexpr{i18n()$t("représente l'évolution du nombre de tiges de précomptables au cours du temps.")}

<<Hist_GestionPassee_Effectif, size = 'footnotesize', fig.height = 4, fig.cap = i18n()$t("Effectif à l'hectare des arbres précomptables"), eval = eval_evol, include = eval_evol>>=
# %%%%%%%%%% Précomptables :
table <-
  gfForetFpied_Classe %>%
  filter(NumForet == forest_num) %>%
  left_join(Cycles[, c("NumForet", "Cycle", "Annee")]) %>%
  select(Annee, Classe, Nha) %>%
  mutate(Annee = factor(Annee))

##### aesthetics #####
# -- all species
# alpha & colour values
if (last_cycle == 2) {
  colour_aes <- c("dodgerblue3", "firebrick3")
  alpha_aes <- c(1, 1)
} else { # cond last_cycle > 2
  colour_aes <- c("dodgerblue3", rep("dodgerblue3", last_cycle - 2), "firebrick3")
  alpha_aes <- c(1, rep(0.3, last_cycle - 2), 1)
} # end of cond last_cycle == 2

# palette names
names(colour_aes) <- unique(table$Annee)
names(alpha_aes) <- unique(table$Annee)

# -- plot settings
# axis max values
X_max = max(table$Classe)
Xmin = min(table$Classe)
Y_max = max(table$Nha)

# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plot
ggplot() +
  # lines
  geom_line(
    table,
    mapping = aes(
      Classe, Nha, colour = Annee,
      alpha = Annee, group = Annee
    )
  ) + #, width = 0.7
    # add period labels (on 1st and last 'Classe')
  geom_label_repel(
    table %>% filter(Classe %in% first(Classe) | Classe %in% last(Classe)),
    mapping = aes(x = Classe, y = Nha, label = Annee),
    label.padding = unit(0.15, "lines"),
    size = 1.7, alpha = 1, colour = "black"
  ) +
    # setting scales
  scale_x_continuous(
    limits = c(17, X_max * 1.1),
    breaks = seq(20, X_max * 1.3, 5),
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  scale_colour_manual(name = i18n()$t("Années d'inventaire"), values = colour_aes) +
  scale_alpha_manual(name = i18n()$t("Années d'inventaire"), values = alpha_aes) +
    # axis title
  labs(x = i18n()$t("Classes de diamètre"), y = i18n()$t("N/ha")) +
  # themes
  theme_bw() +
  theme(
    text = element_text(size = 7),
    title = element_text(size = 8),

    strip.background = element_blank(),
    strip.text = element_text(face = "bold"),

    legend.spacing.y = unit(0, "cm"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "vertical",
    legend.box.just = "bottom",
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )
@
\FloatBarrier
}{}

\subsubsection{\Sexpr{i18n()$t("Variabilité spatiale")}}
\Sexpr{i18n()$t("Le tableau")} \ref{dendro_variability_table} \Sexpr{i18n()$t("présente succinctement la variabilité des résultats sur la surface terrière des placettes d'inventaire.")}

<<build_dendro_variability_table, results = 'asis'>>=
# -- tables
# ba by plot
ba_by_plot <-
  gfPlaFpied_ %>%
  filter(NumForet == forest_num) %>%
  
  # NumPlac into numeric and sort
  mutate(NumPlac = as.numeric(NumPlac)) %>% 
  arrange(NumPlac) %>% 
  
  select(NumForet, Cycle, NumPlac, Gha) %>%
  rename(variable = NumPlac) %>%
  pivot_longer(cols = "Gha") %>%
  select(-name)

# ba by stand
ba_by_stand <-
  gfForetFpied_ %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Cycle, Gha, CV_Gha, Er_Gha) %>%
  mutate(Sd = round(Gha * CV_Gha / 100, 1)) %>%
  pivot_longer(
    cols = c("Gha", "CV_Gha", "Er_Gha", "Sd"),
    names_to = "variable",
    values_to = "value"
  )

# main table
table <-
  # rbind(ba_by_plot, ba_by_stand) %>%
  ba_by_stand %>%
  left_join(
      Cycles[, c("NumForet", "Cycle", "Annee")],
      by = c("NumForet", "Cycle")
    ) %>%
  mutate(
    value = case_when(
        variable %in% c("Er_Gha", "CV_Gha") ~ paste0(round(value, 0), " \\%"),
        variable == "Gha" ~ paste0("\\textbf{", round(value, 1), "}"),
        TRUE ~ as.character(round(value, 1))
      ),
    NumForet = NULL, Cycle = NULL
  ) %>%
  pivot_wider(
    id_cols = "variable",
    names_from = "Annee",
    values_from = "value"
  ) %>%
  mutate(
    variable = case_when(
      variable == "Gha" ~ "\\rowcolor{LightGray} \\textbf{Moy}",
      variable %in% c("CV_Gha", "Er_Gha") ~ gsub("_Gha", "", variable),
      variable == "Sd" ~ "E.-type",
      TRUE ~ variable
      ),

    # translation
    variable = i18n()$t(variable)
  ) %>%
  rename(!!i18n()$t("Placettes") := variable)
names(table) <- paste0("\\textbf{", names(table), "}")

# -- print
print(
  xtable(
    table,
    caption = i18n()$t("Variabilité spatiale (sur la surface terrière)"),
    caption.placement = "top",
    digits = rep(0, ncol(table) + 1),
    align = c("M{0cm}", "|M{1.7cm}|", rep("M{1cm}|", ncol(table) - 1)),
    label = "dendro_variability_table"
  ),
  include.rownames = FALSE,
  sanitize.text.function = function(x){return(x)},
  hline.after = -1:nrow(table),
  size = "\\footnotesize"
)
@
\FloatBarrier

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\Sexpr{i18n()$t("La figure")} \ref{fig:evol_dendro_variability_plot} \Sexpr{i18n()$t("représente l'évolution au cours du temps du coefficient de variation des données de surface terrière.")}

<<evol_dendro_variability_plot, fig.pos = 'H', include = eval_evol, eval = eval_evol, fig.height = 2, fig.cap = i18n()$t("Evolution du coefficient de variation")>>=

df <-
  gfForetFpied_ %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  mutate(
    CV_Gha = CV_Gha / 100,
    Annee = factor(Annee)
  ) %>%
  select(NumForet, Annee, CV_Gha)

cv_max <- if (max(df$CV_Gha, na.rm = T) <= 0.5) 0.5 else max(df$CV_Gha, na.rm = T)

ggplot() +
  geom_line(
    df,
    mapping = aes(Annee, CV_Gha, group = NumForet)) +
  scale_y_continuous(
    name = "CV %",
    limits = c(0, cv_max),
    breaks = seq(0, 1, 0.1),
    labels = percent_format(accuracy = 1)
  ) +
  labs(x = i18n()$t("Années d'inventaire")) +
  theme_bw() + MyTheme

@
}{}

\EditIf{\Sexpr{eval_econ}}{TRUE}{
\subsection{\Sexpr{i18n()$t("Variables économiques")}}
\subsubsection{\Sexpr{i18n()$t("En")} \Sexpr{last_year}}
\Sexpr{i18n()$t("Le tableau")} \ref{standing_trees_economic_results_table} \Sexpr{i18n()$t("présente les résultats sur les principales variables économiques, pour le dernier inventaire.")}

<<standing_trees_economic_results_table, results = 'asis'>>=
attribute <- "economic"
label = "standing_trees_economic_results_table"

# -- caption
add_to_caption <- if (last_cycle > 1) {
  i18n()$t(", Vp = valeur potentielle (\\euro{}/ha), Gain = accroisement en valeur (\\euro{}/ha/an)}")
} else "}"
caption <- paste0(
  i18n()$t("Principales caractéristiques économiques des tiges précomptables, avec leur précision.\\\\\\scriptsize{Vc = valeur de consommation (\\euro{} / ha)"), add_to_caption
  )

main_economic_results <- print_main_results_table(
  table = gfForetFpied_,
  cycles_table = Cycles,
  attribute = attribute,
  forest_num = forest_num,
  last_cycle = last_cycle,
  label = label,
  caption = caption
)
@

\Sexpr{i18n()$t("La figure")} \ref{fig:econ_var_boxplot} \Sexpr{i18n()$t("illustre la variabilité des principales composantes économiques.")}

<<econ_var_boxplot, fig.pos = 'H', size = 'footnotesize', fig.height = 2, fig.width = ifelse(last_cycle == 1, 1.5, 4.5), fig.cap = i18n()$t("Variabilité des principales caractéristiques économiques pour les tiges précomptables")>>=
# boxplot_table <-
#   gfPlaFpied_ %>%
#   filter(Cycle == last_cycle & NumForet == forest_num) %>%
#   select(-NumPlac) %>%
#   pivot_longer(
#     cols = -c("NumForet", "Cycle"),
#     names_to = "variable",
#     values_to = "value"
#   )

# -- plots
# valeur de consommation
p1 <- build_box_plot(
  table = boxplot_table, var = "VcHa",
  y_axis_name = "(euros/ha)",
  max_definition_vars = c("VcHa", "VpHa")
)

if (last_cycle > 1) {
# valeur potentielle
p2 <- build_box_plot(
  table = boxplot_table, var = "VpHa",
  y_axis_name = "(euros/ha)",
  max_definition_vars = c("VcHa", "VpHa")
)
# gain
p3 <- build_box_plot(
  table = boxplot_table, var = "Gainper",
  y_axis_name = "(euros/ha/an)"
)

# -- arrange grid
grid.arrange(p1, p2, p3, widths = c(1, 1, 1))
} else {
  p1
}
@
\FloatBarrier
}

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsubsection{\Sexpr{i18n()$t("Evolution")}}
\Sexpr{i18n()$t("Le tableau")} \ref{Tab_GestionPasseeEco_Prec} \Sexpr{i18n()$t("présente l'évolution des valeurs de consommation et potentielle au cours du temps. On y retrouve les résultats pour les différentes populations du sous-étage (taillis et perches) ainsi que ceux pour les précomptables, déclinés par catégorie de diamètre.")}\\
\Sexpr{i18n()$t("La figure")} \ref{fig:evol_all_pop_values_bar_charts} \Sexpr{i18n()$t("complète cet aperçu de l'évolution des principales composantes économiques de la forêt.")}\\

<<evol_all_pop_values_tables>>=

# regenerated share by year
regenerated_share_by_year <-
  Reges %>%
  filter(NumForet == forest_num & Essence == species_to_regenerate[1] & Rejet == 0) %>% # !is.element(Rejet, c("X", "x"))
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%

  # calcul du nombre total de semis & test si régénération acquise
  mutate(seedling_nb = Class1 + Class2 + Class3) %>%
  group_by(NumForet, NumPlac, SsPlac, Annee, Essence, Rejet) %>%
  summarise(
    seedling_nb = sum(seedling_nb),
    regenerated_sub_plot = ifelse(seedling_nb >= 5, 1, 0)
  ) %>%

  # part de la surface régénérée
  group_by(NumForet, Annee, Essence, Rejet) %>%
  summarise(regenerated_share = sum(regenerated_sub_plot) / sub_plot_nb) %>%
  ungroup() %>%

  select(NumForet, Annee, Essence, regenerated_share) %>%

  # plafond - TODO : à revoir ?
  mutate(regenerated_share = ifelse(regenerated_share > 0.2, 0.2, regenerated_share))

# # regeneration value by year
# regeneration_value_by_year <-
#   gfForetRege_Essence %>%
# 
#   # security if year(s) missing
#   mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
#   complete(NumForet, Cycle) %>%
#   mutate(Cycle = as.numeric(Cycle)) %>%
# 
#   # join years
#   left_join(
#     Cycles[, c("NumForet", "Cycle", "Annee")],
#     by = c("NumForet", "Cycle")
#   ) %>%
# 
#   filter(Essence == species_to_regenerate[1]) %>%
#   select(NumForet, Annee, Essence, Classe1Ha, Classe2Ha, Classe3Ha) %>%
#   mutate(
#     # on pondère les différentes classes par les différents facteurs (macros)
#     Classe1Ha = Classe1Ha * 1,
#     Classe2Ha = Classe2Ha * 2,
#     Classe3Ha = Classe3Ha * 5
#   ) %>%
# 
#   # pivot
#   pivot_longer(
#     cols = c("Classe1Ha", "Classe2Ha", "Classe3Ha"),
#     names_to = "variable",
#     values_to = "weighted_density"
#   ) %>%
#   # mutate(variable = as.character(variable)) %>%
# 
#   # join ClePrixRege -> get RegionRege + FaciliteRege
#   left_join(
#     ClePrixRege,
#     by = c( "NumForet" = "NumForet", "Essence" = "EssenceRege" )
#   ) %>%
# 
#   # cleaning
#   mutate(
#     join_species = Essence,
#     join_species = ifelse(is.na(RegionRege), NA, join_species),
#     join_species = as.character(join_species),
# 
#     FaciliteRege = tolower(FaciliteRege)
#   ) %>%
# 
#   # join PrixRege_pivoted -> get price for each join_species
#   left_join(
#     PrixRege_pivoted,
#     by = c(
#       "RegionRege" = "Région", "join_species" = "Essence",
#       "FaciliteRege" = "Facilité", "variable" = "variable"
#     )
#   ) %>%
# 
#   select(NumForet, Annee, Essence, variable, weighted_density, price) %>%
#   # regeneration price
#   mutate(regeneration_price = weighted_density * price) %>%
# 
#   group_by(NumForet, Annee) %>%
#   summarise(
#     # total weighted density
#     total_weighted_density = sum(weighted_density, na.rm = T),
#     # total regeneration price
#     total_regeneration_price = sum(regeneration_price, na.rm = T)
#   ) %>%
#   ungroup() %>%
# 
#   # join regenerated_share_by_year -> get regenerated_share
#   left_join(regenerated_share_by_year, by = c("NumForet", "Annee")) %>%
#   mutate(
#     VpHa = ifelse(
#       total_weighted_density > 0 & regenerated_share > 0,
#       round(total_regeneration_price / total_weighted_density * regenerated_share, 0),
#       0
#     ),
#     population = "Semis"
#   ) %>%
#   select(Annee, population, VpHa) %>%
# 
#   # pivot
#   pivot_longer(
#     cols = "VpHa",
#     names_to = "variable",
#     values_to = "value"
#   )

# -- valeur pour les perches
stems_values_by_year <-
  gfForetPer_ %>%

  # security if year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(NumForet, Cycle) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join years
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  select(Annee, Gha) %>%

  # calcul VcHa & VpHa
  mutate(
    Vha = Gha * 7,
    VcHa = round(Vha * 3 / 2 * 6, 0),
    VpHa = round(VcHa * 1.3)
  ) %>%  # 3/2 -> passage de m3 en stère; 6 -> prix du stère %>%
  mutate(population = "Perches") %>%
  select(Annee, population, VcHa, VpHa) %>%

  # pivot
  pivot_longer(
    cols = c("VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  )

# -- valeur pour le taillis
coppice_values_by_year <-
  gfForetTaillis_ %>%

  # security if year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(NumForet, Cycle) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join years
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  select(Annee, Gha) %>%

  # calcul VcHa & VpHa
  mutate(
    Vha = Gha * 7,
    VcHa = round(Vha * 3  /2 * 6, 0),
    VpHa = 0
  ) %>%
  mutate(population = "Taillis") %>%
  select(Annee, population, VcHa, VpHa) %>%

  # pivot
  pivot_longer(
    cols = c("VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  )

# -- valeur pour les arbres sur pied
standing_trees_values_by_cat_and_year <-
  gfForetFpied_Cat %>%
  filter(NumForet == forest_num) %>%

  # join years
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%

  select(Annee, Cat, VcHa, VpHa) %>%

  # pivot
  pivot_longer(
    cols = c("VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  rename("population" = "Cat") %>%

   # complete diam cat
  mutate(population = factor(population, levels = c("PB", "BM", "GB", "TGB"))) %>%
  complete(population, Annee, variable, fill = list(value = 0)) %>% 
  mutate(population = as.character(population))

# -- table avec toutes les populations
all_population_values_by_year <- rbind(
  standing_trees_values_by_cat_and_year,
  stems_values_by_year,
  coppice_values_by_year#,
  # regeneration_value_by_year
)

# -- total pour toutes les populations
total_values_by_year <-
  all_population_values_by_year %>%

  # calcul total by variable and year
  group_by(Annee, variable) %>%
  summarise(value = round( sum(value, na.rm = T) )) %>%
  ungroup()

total_values_by_year_label <-
  total_values_by_year %>%
  # format
  mutate(
    population = "\\rowcolor{DimGray} \\textbf{\\textcolor{white}{Total}}",
    value = paste0("\\textbf{\\textcolor{white}{", value, "}}")
  ) %>%
  select(Annee, population, variable, value)

# -- rajout du total + mise en forme des labels pour les arbres sur pied
standing_trees_values_by_year <-
  standing_trees_values_by_cat_and_year %>%

  # calcul total by variable and year
  group_by(Annee, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share
  mutate(
    share = NA,
    share = ifelse(value > 0, round(value / total * 100), share),
    # share = paste0("(", round(value / total * 100), "\\%)")),
    share = case_when(
      value > 0 & share >= 1 ~
        paste0(" \\scriptsize{\\textcolor{CornflowerBlue}{(", share, "\\%)}}"),
      value > 0 & share < 1 ~
        " \\scriptsize{\\textcolor{CornflowerBlue}{($\\sim$0 \\%)}}"
    ),

    value = round(value),
    value = ifelse(!is.na(share), paste0(round(value), share), share),

    total = paste0(
      "\\textbf{", round(total),
      " \\scriptsize{\\textcolor{CornflowerBlue}{(100\\%)}}}"
    )
  ) %>%

  # pivot
  pivot_wider(
    id_cols = c("Annee", "variable", "total"),
    names_from = "population",
    values_from = "value"
  ) %>%

  # rename total
  # rename(!!i18n()$t("\\rowcolor{LightGray} \\textbf{Précomptables}") := "total") %>%
  rename("Précomptables" = "total") %>%

  # pivot
  pivot_longer(
    cols = c(
      "PB", "BM", "GB", "TGB",
      # i18n()$t("\\rowcolor{LightGray} \\textbf{Précomptables}")
      "Précomptables"
    ),
    names_to = "population",
    values_to = "value"
  )
@

<<evol_all_pop_values_print_tables, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=

# -- build final tables
table <- rbind(
  standing_trees_values_by_year,
  stems_values_by_year,
  coppice_values_by_year,
  # regeneration_value_by_year,
  total_values_by_year_label
)

# table VcHa
table_VcHa <-
  table %>%
  filter(variable == "VcHa") %>%

  # pivot
  pivot_wider(
    id_cols = "population",
    values_from = "value",
    names_from = "Annee"
  ) %>%

  # format
  mutate(population = i18n()$t(population)) %>%
  rename(!!i18n()$t("Population") := "population")

# table VpHa
table_VpHa <-
  table %>%
  filter(variable == "VpHa") %>%

  # pivot
  pivot_wider(
    id_cols = "population",
    values_from = "value",
    names_from = "Annee"
  ) %>%

  # format
  mutate(population = i18n()$t(population)) %>%
  rename(!!i18n()$t("Population") := "population")

# -- print tables
cat("\\begin{table}[ht]\n\\centering")

print(
  xtable(
    table_VcHa,
    digits = rep(0, dim(table_VcHa)[2] + 1),
    align = c(
      "M{0cm}", "|M{2cm}|",
      rep("M{1.5cm}|", dim(table_VcHa)[2] - 2),
      "M{2.1cm}|"
    ),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  hline.after = -1:nrow(table_VcHa),
  floating = F,
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)
cat("\n\\vspace{0.25cm}\n\n")

print(
  xtable(
    table_VpHa,
    digits = rep(0, dim(table_VpHa)[2] + 1),
    align = c(
      "M{0cm}", "|M{2cm}|",
      rep("M{1.5cm}|", dim(table_VpHa)[2] - 2),
      "M{2.1cm}|"
    ),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  hline.after = -1:dim(table_VpHa)[1],
  floating = F,
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)

cat(
  "\\caption{",
  i18n()$t("Evolution de la valeur de consommation et de la valeur potentielle du matériel sur pied (en \\euro{}/ha)"),
  "}\n\\label{Tab_GestionPasseeEco_Prec}\n\\end{table}\n"
)
@

<<evol_all_pop_values_set_up, eval = eval_evol, include = eval_evol>>=
# -- paramétrage largeur chunk suivant :
width_PARAM <- if (last_cycle <= 2) 5.75 else 7

# -- get values variations for sentence
first_year <- with(Cycles_Disp, Annee[Cycle == 1])
period <- paste0(first_year, " - ", last_year)
initial_values <- total_values_by_year %>% filter(Annee == first_year)
current_values <- total_values_by_year %>% filter(Annee == last_year)

initial_VcHa <- with(initial_values, value[variable == "VcHa"])
current_VcHa <- with(current_values, value[variable == "VcHa"])

initial_VpHa <- with(initial_values, value[variable == "VpHa"])
current_VpHa <- with(current_values, value[variable == "VpHa"])

VcHa_variation <- round( (current_VcHa - initial_VcHa) / initial_VcHa * 100 )
VcHa_variation_sign <- if (VcHa_variation > 0) "+" else "-"
VcHa_variation <- paste0(VcHa_variation_sign, VcHa_variation)

VpHa_variation <- round( (current_VpHa - initial_VpHa) / initial_VpHa * 100 )
VpHa_variation_sign <- if (VpHa_variation > 0) "+" else "-"
VpHa_variation <- paste0(VpHa_variation_sign, VpHa_variation)
@
\FloatBarrier

\Sexpr{i18n()$t("La variation de la valeur de consommation est de")} \Sexpr{VcHa_variation} \Sexpr{i18n()$t("\\% sur la période")} \Sexpr{period}. \Sexpr{i18n()$t("Celle de la valeur potentielle est de")} \Sexpr{VpHa_variation} \%.\\
% \textcolor{red}{\Huge Note : traduction manquante}
<<evol_all_pop_values_bar_charts, size = 'footnotesize', fig.pos = "H", fig.height = 4, fig.width = width_PARAM, fig.cap = i18n()$t("Suivi de la répartition des valeurs de consommation et potentielle au cours du temps et entre les différentes populations"), eval = eval_evol, include = eval_evol>>=

# -- colour aesthetics
# colour values
# colour_aes <- c(
#   "chartreuse3", "navajowhite4", "dodgerblue1",
#   # "darkseagreen2", "darkorange1",
#   "Gray15", "Gray40", "Gray60", "Gray80", "Gray100"
# )
colour_aes <- c(
  "Gray15", "Gray40", "Gray60", "Gray80",
  "dodgerblue1", "navajowhite4", "chartreuse3"
)
# palette names
# names(colour_aes) <-
#   c("Semis", "Taillis", "Perches", "TGB", "GB", "BM", "PB", "Perches")
names(colour_aes) <-
  c("TGB", "GB", "BM", "PB", "Perches", "Taillis", "Semis")

names(colour_aes) <- i18n()$t(names(colour_aes))


# -- table
plot_table <-
  all_population_values_by_year %>%
  mutate(
    population = i18n()$t(population),
    population = factor(
      population,
      levels = names(colour_aes)
    ),
    Annee = factor(Annee)
  )

# -- plots settings 1+2 : densité de tiges
# axis max values
# X_max <- max(plot_table$Classe)
max_table <-
  plot_table %>%
  group_by(Annee, variable) %>%
  summarise(value = sum(value, na.rm = T)) %>%
  ungroup()
Y_max <- max(max_table$value, na.rm = T)

# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plots
# VcHa plot
p1 <-
  ggplot() +
  geom_bar(
    plot_table %>% filter(variable == "VcHa"),
    # df_TOT_VcHa,
    mapping = aes(Annee, value, fill = population),
    position = "stack", stat = "identity"
  ) +
  scale_y_continuous(
    name = paste(i18n()$t("Vc"), "(euros/ha)"),
    limits = c(0, Y_max * 1.1),
    expand = c(0, 0),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  scale_fill_manual(
    name = i18n()$t("Population"),
    values = colour_aes
  ) +
  guides(fill = guide_legend(reverse = T, nrow = 1)) +
  labs(x = i18n()$t("Années d'inventaire")) +
  theme_bw() +
  MyTheme +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

# VpHa plot
p2 <-
  ggplot() +
  geom_bar(
    plot_table %>% filter(variable == "VpHa"),
    # df_TOT_VcHa,
    mapping = aes(Annee, value, fill = population),
    position = "stack", stat = "identity"
  ) +
  scale_y_continuous(
    name = paste(i18n()$t("Vp"), "(euros/ha)"),
    limits = c(0, Y_max * 1.1),
    expand = c(0, 0),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  scale_fill_manual(
    name = i18n()$t("Population"),
    values = colour_aes
  ) +
  # coord_flip() +
  guides(fill = guide_legend(reverse = T, nrow = 1)) +
  labs(x = i18n()$t("Années d'inventaire")) +
  theme_bw() +
  MyTheme +
  theme(
    legend.position="bottom",
    legend.direction="horizontal"
  )

# final plot
myLegend2 <- g_legend(p2)
grid.arrange(
  arrangeGrob(
    p1 + theme(legend.position = "none"),
    p2 + theme(legend.position = "none"),
    nrow = 1, widths = c(1, 1)
  ),
  myLegend2,
  nrow = 2, heights = c(8, 1)
)
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:evol_all_pop_values_line_graph} \Sexpr{i18n()$t("présente l'évolution des valeurs de consommation et potentielle au cours du temps.")}

<<evol_all_pop_values_line_graph, size = 'footnotesize', fig.pos = "H", fig.height = 3, fig.cap = i18n()$t("Evolution des valeurs de consommation et potentielle au cours du temps"), eval = eval_evol, include = eval_evol>>=

# -- plot table
plot_table <-
  total_values_by_year %>%
  mutate(
    variable = case_when(
      variable == "VcHa" ~ i18n()$t("Valeur de consommation"),
      variable == "VpHa" ~ i18n()$t("Valeur potentielle")
    )
  )

# -- plots settings
# axis max values
# X_max <- max(plot_table$Classe)
Y_max <- max(plot_table$value, na.rm = T)

# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- colour aesthetics
# colour values
colour_aes <- c("mediumseagreen", "red3")
# palette names
names(colour_aes) <-
  c(i18n()$t("Valeur de consommation"), i18n()$t("Valeur potentielle"))

# -- plot
ggplot() +
  geom_line(
    plot_table,
    mapping = aes(factor(Annee), value, colour = variable, group = variable)
  ) + #, width=0.7
  geom_point(
    plot_table,
    mapping = aes(factor(Annee), value, colour = variable, shape = variable),
    size = 2, fill = "yellow"
  ) +
  scale_y_continuous(
    name = i18n()$t("Valeur (euros/ha)"),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  scale_colour_manual(
    name = "",
    values = colour_aes
  ) +
  scale_shape_manual(name = "", values = c(15, 21)) +
  # coord_flip() +
  # guides(fill = guide_legend(label = c(
  #   i18n()$t("Valeur de consommation"),
  #   i18n()$t("Valeur potentielle")
  # ))) +
  labs(x = i18n()$t("Années d'inventaire")) +
  theme_bw() +
  MyTheme +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
@
\FloatBarrier
}{}

\section{\Sexpr{i18n()$t("Analyse de la composition")}}

\subsection{\Sexpr{i18n()$t("Composition globale")}}
\Sexpr{i18n()$t("Le dispositif possède au total")} \Sexpr{length(unique(species_main_results_table$Essence))} \Sexpr{i18n()$t("espèces sous forme de semis (viables), de brins de taillis, de perches ou d'arbres précomptables.")} \Sexpr{i18n()$t("La figure")} \ref{fig:global_composition_plot} \Sexpr{i18n()$t("donne une image de l'importance des essences dans chacune des 4 populations. Elle fournit à la fois la répartition de la surface terrière (en relatif et en absolu) par essence pour les précomptables, les perches et le taillis, mais aussi celle du nombre de tiges par essence pour les semis.")}\\
% On tient compte uniquement des données de régénération dite acquise - on ne tiendra donc pas compte du recouvrement dans les classes de semis.

<<global_composition_plot, size = 'footnotesize', fig.height = fig_height_parameters$global_composition, fig.cap = i18n()$t("Composition en essence des différentes populations inventoriées, semis, taillis, perches, arbres précomptables.\\\\\\footnotesize{Classe 1 = hauteur semis $<$ 1.50 m\\\\Classe 2 = hauteur semis $\\geqslant$ 1.50 m et diamètre $<$ 2.5 cm\\\\Classe 3 = 2.5 cm $\\leqslant$ diamètre $<$ 7.5 cm\\\\Taillis = tiges issues d'un rejet de souche (distance à une tige de même essence d'au plus 30 cm) et avec 7.5 cm $\\leqslant$ diamètre $<$ 17.5 cm\\\\Perches = tiges de franc-pied avec 7.5 cm$\\leqslant$ diamètre $<$ 17.5 cm\\\\Précomptables = tiges de franc-pied avec diamètre $\\geqslant$ 17.5 cm}"), fig.pos = "ht", dev = "cairo_pdf">>=
# -- plot table
pop_order <- c(
  i18n()$t("Classe 1"),
  i18n()$t("Classe 2"),
  i18n()$t("Classe 3"),
  i18n()$t("Taillis"),
  i18n()$t("Perches"),
  i18n()$t("Précomptables ")
)

global_composition_table <-
  global_composition_table %>%
  complete(Essence, Population, fill = list(Valeur = NA)) %>%
  mutate(
    # order
    Population = factor(Population, pop_order),
    Essence = factor(Essence, rev(main_species_order)),

    # define label
    digits = case_when(
      Population != i18n()$t("Précomptables ") ~ 0,
      Population == i18n()$t("Précomptables ") ~ 1
    ),
    units = ifelse(
      Population == i18n()$t("Précomptables "),
      i18n()$t(" m2/ha"),
      i18n()$t(" tiges/ha")
    ),
    value_label = round(Valeur, digits),
    label = case_when(
      # gestion des labels avec des valeurs trop faibles
      Valeur > 0  & value_label == 0 ~ paste0("~0", units),

      Valeur > 0 ~ paste0( value_label, units)
    )
  ) %>%
  arrange(Population, Essence)

# -- plot
ggplot(global_composition_table, aes(Population, Essence)) +
  geom_tile(
    aes(fill = value_rel * 100),
    colour = "gray80"
  ) +
  geom_text(
    aes(x = Population, y = Essence, label = label),
    col = "black",
    size = 2
  ) +
  scale_fill_gradient2(
    name = i18n()$t("Part de la valeur totale (%)\r\npour chaque stade de\r\ndéveloppement"),
    low = "white", mid = "forestgreen", high = "dodgerblue3",
    midpoint = 50,
    limits = c(0, 100),
    breaks = c(0, 25, 50, 75, 100),
    na.value = NA
  ) +
  scale_x_discrete(
    position = 'top',
    expand = c(0, 0)
  ) +
  scale_y_discrete(expand = c(0, 0)) +
  labs(x = NULL, y = NULL) +
  theme(
    axis.text.x  = element_text(size = 7, face = 'plain'),
    axis.text.y  = element_text(size = 7),
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 9, face = 'plain'),
    legend.position = "bottom",
    panel.grid.major = element_line(colour = "gray80"),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.border = element_rect(fill = NA, colour = "gray80")
  )
@
\FloatBarrier

\subsection{\Sexpr{i18n()$t("Individus précomptables")}}
\label{subsec:Compo_Prec}

\Sexpr{i18n()$t("Le tableau")} \ref{standing_trees_species_distribution_table} \Sexpr{i18n()$t("fournit la composition en essences des arbres précomptables (arbres dont le diamètre est supérieur à 17,5 cm) selon différentes variables. Il est trié par ordre de surface terrière décroissante.")}\\

% \textcolor{blue}{Attention, comme on arrondit les valeurs des tableaux, si jamais une essence contribue à 0.2\%, cela ne sera pas visible. voir AcctG (différence au total et somme des lignes)}

<<standing_trees_species_distribution_table, results = 'asis', fig.pos = "H">>=

attribute <- "Essence"
attribute_name <- paste0("\\textbf{", i18n()$t("Essences"), "}")
label = "standing_trees_species_distribution_table"
caption = i18n()$t("Composition en essences des tiges précomptables")

main_results_by_species <- set_up_main_results_by_attribute_table(
  table = gfForetFpied_EssReg %>% rename(Essence = EssReg),
  attribute = attribute,
  # attribute_name = attribute_name,
  forest_num = forest_num,
  last_cycle = last_cycle#,
  # label = label,
  # caption = caption
)

# -- print table
table <-
  main_results_by_species$print_table %>%
  # N_name <- paste0(
  #   "\\textbf{N\\hspace{1.2cm}\\scriptsize{(tiges/ha)}}"
  # ) %>%

  # translation
  mutate(attribute = i18n()$t(attribute)) %>%

# rename & translation
rename(
  !!i18n()$t("\\textbf{N\\hspace{1.4cm}\\scriptsize{(tiges/ha)}}") := "Nha",
  !!i18n()$t("\\textbf{G\\hspace{1.4cm}\\scriptsize{(m2/ha)}}") := "Gha",
  !!i18n()$t("\\textbf{V\\hspace{1.4cm}\\scriptsize{(m3/ha)}}") := "Vha",
  !!i18n()$t("\\textbf{Vc\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VcHa",

    !!attribute_name := "attribute"
  )

if (last_cycle > 1) {
  table <-
    table %>%
    rename(
      !!i18n()$t("\\textbf{AcctG\\hspace{1.4cm}\\scriptsize{(m2/ha/an)}}") := "AcctGper",
      !!i18n()$t("\\textbf{AcctV\\hspace{1.4cm}\\scriptsize{(m3/ha/an)}}") := "AcctVper",
      !!i18n()$t("\\textbf{Vp\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VpHa",
      !!i18n()$t("\\textbf{Gain\\hspace{1.4cm}\\scriptsize{(\\euro/ha/an)}}") := "Gainper"
    )
}

# -- remove economic variables (T/F)
if (!eval_econ) table <- table[, !str_detect(names(table), "euro")]

  # -- print table settings
  digits_param = rep(0, ncol(table) + 1)

  # -- print table
  print(
    xtable(
      table,
      digits = digits_param,
      align = c(
        "M{0cm}|", "|M{2.2cm}",
        rep("|M{1.4cm}", ncol(table) - 2),
        "|M{1.7cm}|"
      ),
      caption = caption,
      label = label),
    caption.placement = "bottom",
    include.rownames = F,
    hline.after = c(-1:nrow(table)),
    sanitize.text.function = function(x) {return(x)},
    size = "\\footnotesize"
  )
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:standing_trees_species_distribution_pie_chart} \Sexpr{i18n()$t("permet de visualiser simultanément la contribution de chaque essence aux différentes variables économiques et dendrométriques présentées.")}\\

<<standing_trees_species_distribution_pie_chart, size = 'footnotesize', fig.height = 4, fig.cap = i18n()$t("Importance relative des différentes essences."), fig.pos = "H">>=
 # -- table
pie_chart_table <-
    main_results_by_species$plot_table %>%
  filter(variable != "Gainper") %>%
  mutate(
    variable = gsub(coll("ha"), "", variable),
    variable = gsub(coll("Ha"), "", variable),
    variable = gsub(coll("per"), "", variable),

    # translation
   variable = i18n()$t(variable),
   attribute = i18n()$t(attribute), # TODO : à mettre dans la fonction 'set_up_main_results_by_attribute_table' ?

    # order
    Essence = factor(attribute, levels = rev(standing_trees_grouped_species_order)),
   variable = factor(
     variable,
     levels = c(
       i18n()$t("N"), i18n()$t("G"), i18n()$t("V"),
       i18n()$t("AcctG"), i18n()$t("AcctV"), i18n()$t("Vc"), i18n()$t("Vp")
     )
   ),

    # define label settings
    label_y = 0.5, # position
    label_str = variable # label string
  ) %>%
  arrange(variable, Essence)

# -- theme sizes
  # TODO : faire une liste size pour tout le document ?
  # theme_sizes <- list(
  #   title = 7,
  #   text = 6,
  #   axis_title_x = 9,
  #   axis_text_x = 7,
  #   legend_text = 7
  # )

  # -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)
  
  # -- plot
var <- if (eval_econ) NULL else {
  unique(with(pie_chart_table, variable[!variable %in% c("Vc", "Vp", "Gain")]))
}

  # -- plot
build_pie_chart(
  table = pie_chart_table,
  var = var,
  x = "variable",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  y_axis_name = i18n()$t("Part relative des essences"),
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier


\subsection{\Sexpr{i18n()$t("Composition en essences par classe de diamètre")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:standing_trees_species-class_distribution} \Sexpr{i18n()$t("fournit une illustration de la répartition des précomptables sur les principales essences, en nombre de tiges et en surface terrière à l'hectare, de manière absolue et relative.")}

<<standing_trees_species-class_distribution, size = 'footnotesize', include = T, eval = T, fig.height = 5, fig.cap = i18n()$t("Composition en essences des peuplements inventoriés : répartition de la densité de tiges et de la surface terrière en absolu et en relatif"), fig.pos = "H", dev = "cairo_pdf">>=

plot_table <-
  gfForetFpied_EssRegClasse %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%

  # rename
  rename(Essence = EssReg) %>%

  select(NumForet, Cycle, Foret, Essence, Classe, Nha, Gha, Vha) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  arrange(Essence, Classe) %>%
  group_by(Classe) %>%
  mutate(
    Nha_Max = sum(Nha, na.rm=T),
    Gha_Max = sum(Gha, na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(
    Essence = factor(
      Essence,
      levels = rev(standing_trees_grouped_species_order)
    )
  ) %>%
  arrange(Essence)

# -- plots settings 1+2 : densité de tiges
# axis max and min values
X_max = max(plot_table$Classe)
X_min = min(plot_table$Classe)
Y_max = max(plot_table$Nha_Max)
# security
Y_max = ifelse(Y_max == 0, 20, Y_max)
# label
label = paste0(i18n()$t("N"), " = ", round(sum(plot_table$Nha), 0), i18n()$t(" tiges/ha"))

# increment scale (y)
increment_value <- find_increment_value(Y_max)


  # -- plots 1+2 : densité de tiges
p1 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes(Classe, Nha, fill = Essence),
    stat = "identity", position = "stack"
  ) +
  geom_label(
    data.frame(
      x = c(X_max * 0.9),
      y = c(Y_max * 1.0),
      label = label
    ),
    mapping = aes(x, y, label = label),
    size = 2,
    col = "black", position = "dodge",
    label.padding = unit(0.1, "lines"), alpha = 1
  ) +
	labs(x  =  "", y = paste0(i18n()$t("N"), " ", i18n()$t("(tiges/ha)"))) +
  scale_fill_manual(
    name = i18n()$t("Essences"),
    values = colour_aes_for_grouped_species
  ) +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  scale_x_continuous(
    limits = c(X_min - 3, X_max * 1.1),
    breaks = seq(X_min, X_max * 1.3, 10),
    expand = c(0, 0)
  ) +
  guides(
    fill = guide_legend(
      nrow = ifelse(
        length(unique(plot_table$Essence)) > 7,
        round(length(unique(plot_table$Essence)) / 7, 0), 1
      ),
      byrow = T)
  ) +
  MyTheme1 +
  theme(
    legend.direction = "horizontal",
    legend.position = "bottom",
    legend.key.size = unit(0.5, 'cm'),
    legend.text = element_text(size = 6)
  )
p2 <-
  ggplot(plot_table, aes(Classe, Nha, fill = Essence)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = colour_aes_for_grouped_species) +
  scale_y_continuous(
    name = i18n()$t("Part de la densité"),
    labels = percent
  ) +
  scale_x_continuous(
    limits = c(X_min - 3, X_max * 1.1),
    breaks = seq(X_min, X_max * 1.3, 10),
    expand = c(0, 0)
  ) +
  labs(x  =  "", fill = "") +
  MyTheme1


# -- plots settings 3+4 : surface terrière
# axis max values
Y_max = max(plot_table$Gha_Max)
# security
Y_max = ifelse(Y_max == 0, 2, Y_max)
# label
label = paste0(i18n()$t("G"), " = ", round(sum(plot_table$Gha), 1), i18n()$t(" m2/ha"))

# increment scale (y)
increment_value <- find_increment_value(Y_max) # increment_value <- 0.5

# -- plots 3+4 : surface terrière
p3 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes(Classe, Gha, fill = Essence),
    stat = "identity", position = "stack"
  ) +
  geom_label(
    data.frame(
      x = c(X_max * 0.9),
      y = c(Y_max * 1.0),
      label = label
    ),
    mapping = aes(x, y, label = label),
    size = 2,
    col = "black", position = "dodge",
    label.padding = unit(0.1, "lines"), alpha = 1
  ) +
  labs(x  =  "", y = paste0(i18n()$t("G"), " ", i18n()$t("(m2/ha)"))) +
  scale_fill_manual(
    name = i18n()$t("Essences"),
    values = colour_aes_for_grouped_species
  ) +
  scale_x_continuous(
    limits = c(17, X_max * 1.1),
    breaks = seq(20, X_max * 1.3, 10),
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, max(plot_table$Gha_Max) * 1.3, increment_value)
  ) +
  MyTheme1

p4 <-
  ggplot(plot_table, aes(Classe, Gha, fill = Essence)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = colour_aes_for_grouped_species) +
  scale_x_continuous(
    limits = c(17, X_max * 1.1),
    breaks = seq(20, X_max * 1.3, 10),
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    name = i18n()$t("Part de la surface terrière"),
    labels = percent
  ) +
  labs(x  =  "", fill = "") +
  MyTheme1

# final plot
mylegend <- g_legend(p1)
grid.arrange(
  arrangeGrob(
    p1 + theme(legend.position = "none"),
    p2 + theme(legend.position = "none"),
    p3 + theme(legend.position = "none"),
    p4 + theme(legend.position = "none"),
    nrow = 2, widths = rep(1, 2)
  ),
  mylegend, nrow = 2, heights = c(9, 2)
)
@
\FloatBarrier

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsection{\Sexpr{i18n()$t("Evolution de la composition")}}

\Sexpr{i18n()$t("Les figures")} \ref{fig:evol_G_by_species_plot}, \ref{fig:evol_Vc_by_species_plot} \Sexpr{i18n()$t("et")} \ref{fig:evol_Vp_by_species_plot} \Sexpr{i18n()$t("illustrent respectivement l'évolution de la surface terrière, de la valeur de consommation et de la valeur potentielle au cours du temps, déclinées par essence.")}\\
\Sexpr{i18n()$t("La partie gauche des figures représente l'importance relative de chaque essence pour les différentes variables. La partie droite des figures présente l'évolution des variables des principales essences (essences représentant au moins ")}\Sexpr{threshold_ba * 100}\Sexpr{i18n()$t("\\% de la surface terrière).")}

<<evol_G-Vc-Vp_by_species_tables, eval = eval_evol, include = eval_evol>>=
# -- ranges
if (last_cycle > 2) {
range_alpha <- c(1, rep(0.3, last_cycle - 2), 1)
}
if (last_cycle == 2) {
  range_alpha <- c(1, 1)
}
range_size <- c(2, rep(1, last_cycle - 2), 2)
range_shape <- c(6, rep(1, last_cycle - 2), 2)

# sorted years
sorted_years <-
  with(Cycles %>% filter(NumForet == forest_num) %>% arrange(Cycle), Annee)
# => range names
names(range_alpha) <- names(range_size) <- names(range_shape) <- sorted_years


# -- main table
table <-
  gfForetFpied_EssReg %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%

  rename("Essence" = "EssReg") %>%

  select(Annee, Essence, Gha, VcHa, VpHa) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  mutate(Essence = factor(Essence, levels = grouped_species_order)) %>%
  arrange(Annee, Essence)


# -- table for pie chart
pie_chart_table <-
  table %>%
  pivot_longer(
    cols = c("Gha", "VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  ) %>%

  # calcul totaux
  group_by(Annee, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share and label, sort species
  mutate(
    # share
    share = value / total,

    # sort species
    Essence = factor(
      Essence,
      levels = grouped_species_order
    ),

    # year factor
    Annee = factor(Annee),

    # define label settings
    label_y = 0.5, # position
    label_str = Annee # label string
  ) %>%
  arrange(Annee, variable, Essence)


# -- table for scatter plot
scatter_plot_table <-
  table %>%
  mutate(Annee = factor(Annee, levels = sorted_years)) %>%
  filter(Essence %in% grouped_majority_species) %>%
  mutate(Essence = factor(Essence, levels = grouped_majority_species)) %>%
  arrange(Essence)

# # -- theme sizes
# theme_sizes <- list(
#   title = 7,
#   text = 7,
#   axis_title_x = 7,
#   axis_text_x = 7,
#   legend_text = 5
# )
# -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 7),
    axis.title.x = list(size = 7),
    axis.text.x = list(size = 7),
    legend.text = list(size = 5),
    legend.position = "bottom",
    legend.direction = "vertical", # "horizontal"
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)
@

<<evol_G_by_species_plot, fig.height = 4.5, fig.cap = i18n()$t("Evolution de la surface terrière par essence entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table,
  var = "Gha",
  x = "Annee",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des essences sur la surface terrière\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,
  var = "Gha",
  attribute = "Essence",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_grouped_species,

  # labels
  y_axis_name = paste0(i18n()$t("G"), " (m2/ha)"),
  scale_name = i18n()$t("Années d'inventaire"),
  colour_scale_name = NULL, # i18n()$t("Essences principales :")
  plot_title = i18n()$t("Evolution de la surface terrière (pour les essences principales)\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier

<<evol_Vc_by_species_plot, fig.height = 4.5, fig.cap = i18n()$t("Evolution de la valeur de consommation par essence entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table,
  var = "VcHa",
  x = "Annee",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des essences sur la valeur de consommation\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,
  var = "VcHa",
  attribute = "Essence",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_grouped_species,

  # labels
  y_axis_name = paste0(i18n()$t("Vc"), " (euros/ha)"),
  scale_name = i18n()$t("Années d'inventaire"),
  colour_scale_name = NULL, # i18n()$t("Essences principales :")
  plot_title = i18n()$t("Evolution de la valeur de consommation (pour les essences principales)\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier

<<evol_Vp_by_species_plot, fig.height = 4.5, fig.cap = i18n()$t("Evolution de la valeur potentielle par essence entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table,
  var = "VpHa",
  x = "Annee",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des essences sur la valeur potentielle\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,
  var = "VpHa",
  attribute = "Essence",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_grouped_species,

  # labels
  x_axis_name = NULL,
  y_axis_name = paste0(i18n()$t("Vp"), " (euros/ha)"),
  scale_name = i18n()$t("Années d'inventaire"),
  colour_scale_name = NULL, # i18n()$t("Essences principales :")
  plot_title = i18n()$t("Evolution de la valeur potentielle (pour les essences principales)\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier

}{}

\section{\Sexpr{i18n()$t("Analyse de la structure")}}\label{Chap_Structure}
\Sexpr{i18n()$t("Le tableau")} \ref{standing_trees_diam_cat_distribution_table} \Sexpr{i18n()$t("présente les résultats sur les individus précomptables, répartis selon les différentes catégories de diamètre.")}

<<standing_trees_diam_cat_distribution_table, results = 'asis', fig.pos = "H">>=
  # -- preparation
table <-
  gfForetFpied_Cat %>% mutate(
    Cat = factor(Cat, levels = c("PER", "PB", "BM", "GB", "TGB"))
  )
  # --

attribute = "Cat"
attribute_name = paste0("\\textbf{", i18n()$t("Catégories de diamètre"), "}")
label = "standing_trees_diam_cat_distribution_table"
caption = i18n()$t("Résultats d'analyse dendrométrique et économique des tiges de franc-pied répartis par catégorie de diamètre.\\\\\\scriptsize{PB (Petits Bois) = diamètre compris entre 17.5 cm et 27.5 cm\\\\BM (Bois Moyens) = diamètre compris entre 27.5 cm et 47.5 cm\\\\GB (Gros Bois) = diamètre compris entre 47.5 cm et 67.5 cm\\\\TGB (Très Gros Bois) = diamètre supérieur à 67.5cm.}")

main_results_by_diam_cat <- set_up_main_results_by_attribute_table(
  table = table,
  attribute = attribute,
  forest_num = forest_num,
  last_cycle = last_cycle#,
  # label = label,
  # caption = caption
)

# -- print table
table <-
  main_results_by_diam_cat$print_table %>%

  # translation
  mutate(
    attribute = as.character(attribute),
    attribute = i18n()$t(attribute)
  ) %>%

# rename & translation
  rename(
    !!i18n()$t("\\textbf{N\\hspace{1.4cm}\\scriptsize{(tiges/ha)}}") := "Nha",
    !!i18n()$t("\\textbf{G\\hspace{1.4cm}\\scriptsize{(m2/ha)}}") := "Gha",
    !!i18n()$t("\\textbf{V\\hspace{1.4cm}\\scriptsize{(m3/ha)}}") := "Vha",
    !!i18n()$t("\\textbf{Vc\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VcHa",

    !!attribute_name := "attribute"
  )

if (last_cycle > 1) {
  table <-
    table %>%
    rename(
      !!i18n()$t("\\textbf{AcctG\\hspace{1.4cm}\\scriptsize{(m2/ha/an)}}") := "AcctGper",
      !!i18n()$t("\\textbf{AcctV\\hspace{1.4cm}\\scriptsize{(m3/ha/an)}}") := "AcctVper",
      !!i18n()$t("\\textbf{Vp\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VpHa",
      !!i18n()$t("\\textbf{Gain\\hspace{1.4cm}\\scriptsize{(\\euro/ha/an)}}") := "Gainper"
    )
}

# -- remove economic variables (T/F)
if (!eval_econ) table <- table[, !str_detect(names(table), "euro")]

  # -- print table settings
  digits_param = rep(0, ncol(table) + 1)

  # -- print table
  print(
    xtable(
      table,
      digits = digits_param,
      align = c(
        "M{0cm}|", "|M{2.2cm}",
        rep("|M{1.4cm}", ncol(table) - 2),
        "|M{1.7cm}|"
      ),
      caption = caption,
      label = label),
    caption.placement = "bottom",
    include.rownames = F,
    hline.after = c(-1:nrow(table)),
    sanitize.text.function = function(x) {return(x)},
    size = "\\footnotesize"
  )
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:contribution_by_diam_cat_line_plot} \Sexpr{i18n()$t("permet de visualiser la structure des peuplements sous différents angles.")}\\

<<contribution_by_diam_cat_line_plot, size = 'footnotesize', fig.pos = 'H', fig.height = 3, fig.cap = i18n()$t("Contribution des différentes catégories de diamètre aux variables dendrométriques et économiques.")>>=

  # -- table units (plot settings)
units_table <- tibble(
  var = c("N", "G", "V", "Vc", "Vp", "Gain"),
  units_label = c("tiges/ha", "m2/ha", "m3/ha", "euros/ha", "euros/ha", "euros/ha/an")
)

# -- variables
vars <- c("Nha", "Vha")
# -- add economic variables (T/F)
if (eval_econ) vars <- c(vars, "VcHa", "Gain")

  # -- plot table
  plot_table <-
    main_results_by_diam_cat$plot_table %>%
    filter(variable %in% vars) %>%
    mutate(
      # attribute character
      attribute = as.character(attribute),

      variable = gsub(coll("ha"), "", variable),
      variable = gsub(coll("Ha"), "", variable),
      variable = gsub(coll("per"), "", variable),

      # translation
      Cat = i18n()$t(attribute),
      variable = i18n()$t(variable),

      # order
      Cat = factor(Cat, levels = names(rev(colour_aes_for_diameter_category))),
      variable = factor(
        variable,
        levels = i18n()$t(c("N", "G", "V", "AcctG", "AcctV", "Vc", "Vp", "Gain"))
      ),

    # define label settings
    # label_y = 0.5, # position
    label_str = variable # label string
    ) %>%
    arrange(variable, Cat)

  # total for each variable
  total_values_by_variable <- with(
    plot_table %>% select(variable, total) %>% distinct, {
      values <- total
      names(values) <- variable
      values
    })

# -- plot settings
# units
y_unit <- with(units_table, units_label[match(names(total_values_by_variable), i18n()$t(var))])

# axis max values
Y_max = with(plot_table, max(value / total * 100, na.rm = T))
# security
Y_max = ifelse(Y_max == 0, 100, Y_max)

# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plot
ggplot() +
  geom_line(
    plot_table,
    mapping = aes(
      x = Cat, y = value / total,
      color = variable, group = variable
    )
  ) +
  scale_color_manual(
    name = i18n()$t("Variables"),
    label = paste0(
      names(total_values_by_variable), " - Total = ",
      round(total_values_by_variable, 0), i18n()$t(paste0(" ", y_unit))
    ),
    values = c("red", "limegreen", "blue", "black")
  ) +
  scale_y_continuous(
    expand = c(0, 0),
    labels = percent_format(accuracy = 1),
    limits = c(0, Y_max * 1.1 / 100),
    breaks = seq(0, 1, increment_value / 100)
  ) +
  # scale_x_discrete("") +
  labs(
    x = NULL,
    y = i18n()$t("Contribution des différentes catégories de diamètre\r\nà la valeur totale de chaque variable")
  ) +
  MyTheme1 +
  theme(
    legend.position = "bottom",
    legend.background = element_rect(colour = "gray50", size = 0.2)
  )
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:standing_trees_diam_cat_distribution_pie_chart} \Sexpr{i18n()$t("illustre la répartition des principales composantes dendrométriques et économiques entre les différentes catégories de diamètre.")}

<<standing_trees_diam_cat_distribution_pie_chart, size = 'footnotesize', fig.height = 4, fig.cap = i18n()$t("Importance relative des différentes catégories de diamètre"), fig.pos = "H">>=
  # -- table
  pie_chart_table <-
    main_results_by_diam_cat$plot_table %>%
    filter(variable != "Gainper") %>%
    mutate(
      # attribute character
      attribute = as.character(attribute),

      variable = gsub(coll("ha"), "", variable),
      variable = gsub(coll("Ha"), "", variable),
      variable = gsub(coll("per"), "", variable),

      # translation
      Cat = i18n()$t(attribute),
      variable = i18n()$t(variable),

      # order
      Cat = factor(Cat, levels = names(colour_aes_for_diameter_category)),
      variable = factor(
        variable,
        levels = i18n()$t(c("N", "G", "V", "AcctG", "AcctV", "Vc", "Vp"))
      ),

    # define label settings
    label_y = 0.5, # position
    label_str = variable # label string
    ) %>%
    arrange(variable, Cat)

# -- theme sizes
  # # TODO : faire une liste size pour tout le document ?
  # theme_sizes <- list(
  #   title = 7,
  #   text = 6,
  #   axis_title_x = 9,
  #   axis_text_x = 7,
  #   legend_text = 7
  # )

    # -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)
  
  # -- plot
var <- if (eval_econ) NULL else {
  unique(with(pie_chart_table, variable[!variable %in% c("Vc", "Vp", "Gain")]))
}

# -- plot
build_pie_chart(
  table = pie_chart_table,
  var = var,
  x = "variable",
  y = "value",
  attribute = "Cat",
  fill_scale_range = colour_aes_for_diameter_category,
  fill_scale_name = i18n()$t("Catégories\r\nde diamètre :"),
  y_axis_name = i18n()$t("Part relative des catégories de diamètre"),
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier


<<CalculTGB, eval = F, include = F>>=
if (last_cycle > 1) {
  t1 <- filter(gfForetFpied_ClasseReg1, Cycle==last_cycle & Gha > 0) %>%
    mutate(Reg1=ifelse(Reg1=="D","D","ABC")) %>%
    select(Classe,Reg1,Nha,Gha,Vha,AcctGper,AcctVper)
  t2 <- filter(gfForetFpied_ClasseReg1, Cycle==last_cycle & Gha > 0) %>%
    mutate(Reg1=ifelse(Reg1=="D","D","ABC")) %>%
    select(Classe,Reg1,VcHa,VpHa,Gainper)

  HistD <- merge(t1,t2)
  HistQual <- HistD %>%
    rename(Qual=Reg1,
           N=Nha,
           V=Vha,
           Vc=VcHa,
           Vp=VpHa) %>%
    arrange(Qual)
  VcTGB <- sum(HistQual$Vc[which(HistQual$Classe>=70)])/sum(HistQual$Vc)
} else {
t1 <- filter(gfForetFpied_ClasseReg1, Cycle==last_cycle & Gha > 0) %>%
  mutate(Reg1=ifelse(Reg1=="D","D","ABC")) %>%
  select(Classe,Reg1,Nha,Gha,Vha)
t2 <- filter(gfForetFpied_ClasseReg1, Cycle==last_cycle & Gha > 0) %>%
  mutate(Reg1=ifelse(Reg1=="D","D","ABC")) %>%
  select(Classe,Reg1,VcHa)

HistD <- merge(t1,t2)
HistQual <- HistD %>%
  rename(Qual=Reg1,
         N=Nha,
         V=Vha,
         Vc=VcHa) %>%
  arrange(Qual)
VcTGB <- sum(HistQual$Vc[which(HistQual$Classe>=70)])/sum(HistQual$Vc)
}
@
\FloatBarrier


\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsection{\Sexpr{i18n()$t("Evolution")}}

\Sexpr{i18n()$t("Les figures")} \ref{fig:evol_G_by_cat_plot} \Sexpr{i18n()$t("et")} \ref{fig:evol_Vc_by_cat_plot} \Sexpr{i18n()$t("illustrent respectivement l'évolution de la surface terrière et de la valeur de consommation au cours du temps, déclinées par catégorie de diamètre.")}\\
\Sexpr{i18n()$t("La partie gauche des figures représente l'importance relative de chaque catégorie de diamètre pour les différentes variables. La partie droite des figures présente l'évolution des variables par catégorie de diamètre.")}

<<evol_G-Vc_by_cat_tables, eval = eval_evol, include = eval_evol>>=
# -- ranges
# colour_aes_for_diameter_category <- c("Gray15", "Gray40", "Gray60", "Gray80", "Gray100")
# names(colour_aes_for_diameter_category) <- c("TGB", "GB", "BM", "PB", "PER")
# sorted_cat <- c("PER", "PB", "BM", "GB", "TGB") # TODO : ordre à enregistrer 1 fois pour toutes

# # Attention doublons : ranges définies plus haut déjà
# if (last_cycle > 2) {
# range_alpha <- c(1, rep(0.3, last_cycle - 2), 1)
# }
# if (last_cycle == 2) {
#   range_alpha <- c(1, 1)
# }
# range_size <- c(2, rep(1, last_cycle - 2), 2)
# range_shape <- c(6, rep(1, last_cycle - 2), 2)
#
# # sorted years
# sorted_years <-
#   with(Cycles %>% filter(NumForet == forest_num) %>% arrange(Cycle), Annee)
# # => range names
# names(range_alpha) <- names(range_size) <- names(range_shape) <- sorted_years


# -- main table
table <-
  gfForetFpied_Cat %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  select(Annee, Cat, Gha, VcHa, VpHa) %>%
  mutate(
    # translation
    Cat = i18n()$t(Cat),

    # order
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%
  arrange(Annee, Cat)


# -- table for pie chart
pie_chart_table <-
  table %>%
  pivot_longer(
    cols = c("Gha", "VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  ) %>%

  # calcul totaux
  group_by(Annee, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share and label, sort categories
  mutate(
    # share
    share = value / total,

    # sort cat
    Cat = factor(
      Cat,
      levels = names(colour_aes_for_diameter_category)
    ),

    # year factor
    Annee = factor(Annee),

    # define label settings
    label_y = 0.5, # position
    label_str = Annee # label string
  ) %>%
  arrange(Annee, variable, Cat)


# -- table for scatter plot
scatter_plot_table <-
  table %>%
  mutate(Annee = factor(Annee, levels = sorted_years))

# -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 7),
    axis.title.x = list(size = 7),
    axis.text.x = list(size = 7),
    legend.text = list(size = 5),
    legend.position = "bottom",
    legend.direction = "horizontal",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)
@

<<evol_G_by_cat_plot, fig.height = 4, fig.cap = i18n()$t("Evolution de la surface terrière des catégories de diamètre entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table,
  var = "Gha",
  x = "Annee",
  y = "value",
  attribute = "Cat",
  fill_scale_range = colour_aes_for_diameter_category,
  fill_scale_name = i18n()$t("Catégories de diamètre :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des catégories de diamètre sur la surface terrière\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,
  var = "Gha",
  attribute = "Cat",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_diameter_category,

  # labels
  x_axis_name = NULL, # i18n()$t("Catégories de diamètre")
  y_axis_name = paste0(i18n()$t("G"), " (m2/ha)"),
  scale_name = i18n()$t("Années d'inventaire"),
  colour_scale_name = NULL, # i18n()$t("Catégories de diamètre")
  plot_title = i18n()$t("Evolution de la surface terrière des catégories de diamètre\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier

<<evol_Vc_by_cat_plot, fig.height = 4, fig.cap = i18n()$t("Evolution de la valeur de consommation des catégories de diamètre entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table,
  var = "VcHa",
  x = "Annee",
  y = "value",
  attribute = "Cat",
  fill_scale_range = colour_aes_for_diameter_category,
  fill_scale_name = i18n()$t("Catégories de diamètre :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des catégories de diamètre sur la valeur de consommation\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,
  var = "VcHa",
  attribute = "Cat",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_diameter_category,

  # labels
  x_axis_name = NULL, # i18n()$t("Catégories de diamètre"),
  y_axis_name = paste0(i18n()$t("Vc"), " (euros/ha)"),
  scale_name = i18n()$t("Années d'inventaire"),
  colour_scale_name = NULL, # i18n()$t("Catégories de diamètre")
  plot_title = i18n()$t("Evolution de la valeur de consommation des catégories de diamètre\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier
}{}


\section{\Sexpr{i18n()$t("Analyse de la qualité")}}

\subsection{\Sexpr{i18n()$t("A l'échelle du peuplement")}}
\label{subsec:Qual_Foret}

\Sexpr{i18n()$t("Le tableau")} \ref{standing_trees_quality_distribution_table} \Sexpr{i18n()$t("fournit les principales caratéristiques dendrométriques par qualité.")} \Sexpr{i18n()$t("Il est complété par la figure")} \ref{fig:diam_classe-qual1_bar_charts_V1} \Sexpr{i18n()$t("qui détaille l'importance relative des qualités par classe de diamètre.")}

<<standing_trees_quality_distribution_table, results = 'asis', fig.pos = "H">>=
table <-
  gfForetFpied_Reg1 %>% mutate(
    Reg1 = factor(Reg1, levels = names(colour_aes_for_qual1))
  )
attribute = "Reg1"
attribute_name = "\\textbf{Qualités}"
label = "standing_trees_quality_distribution_table"
caption = i18n()$t("Résultats d'analyse dendrométrique et économique des tiges de franc-pied répartis par qualité (précomptables uniquement)")

main_results_by_qual1 <- set_up_main_results_by_attribute_table(
  table = table,
  attribute = attribute,
  forest_num = forest_num,
  last_cycle = last_cycle#,
  # label = label,
  # caption = caption
)

# -- print table
table <-
  main_results_by_qual1$print_table %>%

  # rename
  rename(
    !!i18n()$t("\\textbf{N\\hspace{1.4cm}\\scriptsize{(tiges/ha)}}") := "Nha",
    !!i18n()$t("\\textbf{G\\hspace{1.4cm}\\scriptsize{(m2/ha)}}") := "Gha",
    !!i18n()$t("\\textbf{V\\hspace{1.4cm}\\scriptsize{(m3/ha)}}") := "Vha",
    !!i18n()$t("\\textbf{Vc\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VcHa",

    !!i18n()$t(attribute_name) := "attribute"
  )

if (last_cycle > 1) {
  table <-
    table %>%
    rename(
      !!i18n()$t("\\textbf{AcctG\\hspace{1.4cm}\\scriptsize{(m2/ha/an)}}") := "AcctGper",
      !!i18n()$t("\\textbf{AcctV\\hspace{1.4cm}\\scriptsize{(m3/ha/an)}}") := "AcctVper",
      !!i18n()$t("\\textbf{Vp\\hspace{1.4cm}\\scriptsize{(\\euro/ha)}}") := "VpHa",
      !!i18n()$t("\\textbf{Gain\\hspace{1.4cm}\\scriptsize{(\\euro/ha/an)}}") := "Gainper"
    )
}

# -- remove economic variables (T/F)
if (!eval_econ) table <- table[, !str_detect(names(table), "euro")]

  # -- print table settings
  digits_param = rep(0, ncol(table) + 1)

  # -- print table
  print(
    xtable(
      table,
      digits = digits_param,
      align = c(
        "M{0cm}|", "|M{2.2cm}",
        rep("|M{1.4cm}", ncol(table) - 2),
        "|M{1.7cm}|"
      ),
      caption = caption,
      label = label),
    caption.placement = "bottom",
    include.rownames = F,
    hline.after = c(-1:nrow(table)),
    sanitize.text.function = function(x) {return(x)},
    size = "\\footnotesize"
  )

# -- phrase part individus A+B
  top_quality <- first(Quals$Reg2)
top_quality_share <-
  gfForetFpied_Reg2 %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Cycle, Reg2, Gha) %>%

  # calcul total par cycle
  group_by(Cycle) %>%
  mutate(total = sum(Gha)) %>%
  ungroup() %>%

  # calcul share
  mutate(share = round(Gha / total * 100, 0)) %>%
  filter(Reg2 == top_quality) %>%
  select(share) %>%
  unlist()

@
\FloatBarrier
\Sexpr{i18n()$t("La proportion de capital de qualité")} \Sexpr{top_quality} \Sexpr{i18n()$t("est de")} \textbf{\Sexpr{paste0(top_quality_share, " \\%")}}.

<<diam_classe-qual1_bar_charts_V1, fig.pos = 'H', fig.height = 4, fig.cap = i18n()$t("Répartition de la surface terrière par qualité et par classe de diamètre (précomptables uniquement)")>>=
# -- table
plot_table <-
  gfForetFpied_ClasseReg1 %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(Classe, Reg1, Nha, Gha, Vha) %>%
  mutate(Reg1 = factor(Reg1, levels = rev(names(colour_aes_for_qual1)) )) %>%
  rename(
    "N" = "Nha",
    "G" = "Gha",
    "V" = "Vha",
    "Qualité" = "Reg1"
  )

plot_table_lim <-
  plot_table %>%
  group_by(Classe) %>%
  summarise(
    G = sum(G, na.rm = T),
    N = sum(N, na.rm = T)
  ) %>%
  ungroup()

# -- plots settings 1+2 : densité de tiges
# axis max values
X_max = max(plot_table$Classe)
Y_max = max(plot_table_lim$N)
# security
Y_max = ifelse(Y_max == 0, 10, Y_max)
# label
label = paste0(i18n()$t("N"), " = ", round(sum(plot_table$N), 0), i18n()$t(" tiges/ha"))

# increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plots 1+2 : densité de tiges
p1 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes(Classe, N, fill = Qualité),
    stat = "identity", position = "stack"
  ) +
  geom_label(
    data.frame(
      x = c(X_max * 0.9),
      y = c(Y_max * 1.0),
      label = label
    ),
    mapping = aes(x, y, label = label),
    size = 2,
    col = "black", position = "dodge",
    label.padding = unit(0.1, "lines"), alpha = 1
  ) +
  scale_fill_manual(
    name = i18n()$t("Qualités de\r\nbille de pied"),
    values = colour_aes_for_qual1
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(0, X_max, 10)
  ) +
  scale_y_continuous(
    limits = c(0, Y_max * 1.1),
    expand = c(0, 0),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  labs(x = "", fill = "", y = paste0(i18n()$t("N"), " ", i18n()$t("(tiges/ha)"))) +
  guides(fill = guide_legend(reverse = T)) +
  MyTheme1 +
  theme(
    legend.title = element_text(size = 9),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

p2 <-
  ggplot(plot_table, aes(Classe, N, fill = Qualité)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(
    name = i18n()$t("Qualités de\r\nbille de pied"),
    values = colour_aes_for_qual1
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(0, X_max, 10)
  ) +
  scale_y_continuous(labels = percent) +
  labs(x = "", fill = "", y = paste0(i18n()$t("Part de "), i18n()$t("N"), " (%)")) +
  guides(fill = guide_legend(reverse = T)) +
  MyTheme1 +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )


# -- plots settings 3+4 : surface terrière
X_max = max(plot_table$Classe)
Y_max = max(plot_table_lim$G)
# security
Y_max = ifelse(Y_max == 0, 10, Y_max)
# label
label = paste0(i18n()$t("G"), " = ", round(sum(plot_table$G), 1), " m2/ha")

  # increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plots 3+4 : surface terrière
p3 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes(Classe, G, fill = Qualité),
    stat = "identity", position = "stack"
  ) +
  geom_label(
    data.frame(
      x = c(X_max * 0.9),
      y = c(Y_max * 1.0),
      label = label
    ),
    mapping = aes(x, y, label = label),
    size = 2,
    col = "black", position = "dodge",
    label.padding = unit(0.1, "lines"), alpha = 1
  ) +
  scale_fill_manual(
    name = i18n()$t("Qualités de\r\nbille de pied"),
    values = colour_aes_for_qual1
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(0, X_max, 10)
  ) +
  scale_y_continuous(
    limits = c(0, Y_max * 1.1),
    expand = c(0, 0),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  labs(x = "", fill = "", y = paste0(i18n()$t("G"), " ", i18n()$t("(tiges/ha)"))) +
  MyTheme1 +
  theme(legend.title = element_text(size = 9))

p4 <-
  ggplot(plot_table, aes(Classe, G, fill = Qualité)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(
    name = i18n()$t("Qualités de\r\nbille de pied"),
    values = colour_aes_for_qual1
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    breaks = seq(0, X_max, 10)
  ) +
  scale_y_continuous(labels = percent) +
  labs(x = "", fill = "", y = paste0(i18n()$t("Part de "), i18n()$t("G"), " (%)")) +
  guides(fill = guide_legend(reverse = T)) +
  MyTheme1 +
  theme(
    legend.position = "bottom",
    legend.direction = "horizontal"
  )

mylegend <- g_legend(p1)

grid.arrange(
  arrangeGrob(
    p1 + theme(legend.position = "none"),
    p2 + theme(legend.position = "none"),
    p3 + theme(legend.position = "none"),
    p4 + theme(legend.position = "none"),
    nrow = 2, heights = rep(1, 2)
  ),
  mylegend, nrow = 2, heights = c(9, 1)
)
@
\FloatBarrier

<<diam_classe-qual1_bar_charts, fig.pos = 'H', fig.height = 4, fig.cap = i18n()$t("Répartition de la surface terrière par qualité et par classe de diamètre (précomptables uniquement)"), eval = F, include = F>>=
# TODO : devrait être adapté pour pouvoir fonctionner avec 'build_relative_histo_plot()'
# -- table units (plot settings)
units_table <- tibble(
  var = c("N", "G", "V", "Vc", "Vp"),
  units_label = c("tiges/ha", "m2/ha", "m3/ha", "euros/ha", "euros/ha")
)

# -- variables
vars <- c("Classe", "Reg1", "Nha", "Gha", "Vha")

# -- table
table <-
  gfForetFpied_ClasseQual1 %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(vars) %>%
  pivot_longer(
    cols = -c("Classe", "Reg1"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(
    variable = gsub("ha", "", variable),
    # variable = gsub("Ha", "", variable),
    variable = factor(variable, levels = c("N", "G", "V", "Vc", "Vp"))
  ) %>%
  group_by(Classe, Reg1, variable) %>%
  summarise(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  pivot_wider(
    id_cols = c("Classe", "Reg1"),
    names_from = "variable",
    values_from = "value"
  ) %>%
  mutate(
    # Classe = factor(Classe, levels = names(colour_aes_for_diameter_category)),
    Reg1 = factor(Reg1, levels = names(colour_aes_for_qual1))
  ) %>%
  arrange(Classe, Reg1)

  # -- totals_table (for y limits)
  totals_by_class <-
    table %>%
    group_by(Classe) %>%
    summarise(N = sum(N), G = sum(G)) %>%
    ungroup()

# -- plots with absolute values
N_absolute_plot <-
  build_absolute_histo_plot(
    table,
    x = "Classe", y = "N",
    x_axis_name = "Classes de diamètre",
    units_table, palette = colour_aes_for_qual1,
    totals_table = totals_by_class
  )
G_absolute_plot <-
  build_absolute_histo_plot(
    table,
    x = "Classe", y = "G",
    x_axis_name = "Classes de diamètre",
    units_table, palette = colour_aes_for_qual1,
    totals_table = totals_by_class)

# -- plots with relative values
N_relative_plot <-
  build_relative_histo_plot(table, x = "Classe", y = "N", palette = colour_aes_for_qual1)
G_relative_plot <-
  build_relative_histo_plot(table, x = "Classe", y = "G", palette = colour_aes_for_qual1)

# -- stack all plots
# legend
mylegend <- g_legend(N_absolute_plot)
  grid.arrange(
    arrangeGrob(
      N_absolute_plot + theme(legend.position = "none"),
      N_relative_plot + theme(legend.position = "none"),
      G_absolute_plot + theme(legend.position = "none"),
      G_relative_plot + theme(legend.position = "none"),
      nrow = 2, heights = rep(1, 2)
    ),
    mylegend, nrow = 2, heights = c(12, 1)
  )
  @

\Sexpr{i18n()$t("La figure")} \ref{fig:diam_cat-qual1_bar_charts} \Sexpr{i18n()$t("illustre les principales variables dendrométriques réparties par catégorie de diamètre et par qualité.")}% pour chaque catégorie de diamètre l'importance (absolue et relative) des qualités. On a décliné cet aperçu pour la densité de tiges, la surface terrière, ainsi que pour les valeurs de consommation et potentielle.

<<diam_cat-qual1_bar_charts, size = 'footnotesize', include = T, eval = T, fig.height = 4, fig.cap = i18n()$t("Répartition de la qualité par catégorie de diamètre"), fig.pos = "H">>=
# -- table units (plot settings)
units_table <- tibble(
  var = c("N", "G", "V", "Vc", "Vp"),
  units_label = c("tiges/ha", "m2/ha", "m3/ha", "euros/ha", "euros/ha")
)

# -- variables
vars <- c("Cat", "Reg1", "Nha", "Gha", "Vha", "VcHa")

# -- table
table <-
  gfForetFpied_CatReg1 %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(vars) %>%
  pivot_longer(
    cols = -c("Cat", "Reg1"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(
    variable = gsub("ha", "", variable),
    variable = gsub("Ha", "", variable),
    variable = factor(variable, levels = c("N", "G", "V", "Vc", "Vp"))
  ) %>%
  group_by(Cat, Reg1, variable) %>%
  summarise(value = sum(value, na.rm = T)) %>%
  ungroup() %>%
  pivot_wider(
    id_cols = c("Cat", "Reg1"),
    names_from = "variable",
    values_from = "value"
  ) %>%
  mutate(
    # translation
    Cat = i18n()$t(Cat),

    Cat = factor(Cat, levels = i18n()$t(rev( names(colour_aes_for_diameter_category) ))),
    Reg1 = factor(Reg1, levels = rev(names(colour_aes_for_qual1)) )
  ) %>%
  arrange(Cat, Reg1)

  # -- totals_table (for y limits)
  totals_by_cat <-
    table %>%
    group_by(Cat) %>%
    summarise(N = sum(N), G = sum(G), Vc = sum(Vc)) %>%
    ungroup()

# -- plots with absolute values
N_absolute_plot <-
  build_absolute_histo_plot(
    table,
    x = "Cat", y = "N",
    x_axis_name = NULL,
    units_table, palette = colour_aes_for_qual1,
    totals_table = totals_by_cat
  )
G_absolute_plot <-
  build_absolute_histo_plot(
    table,
    x = "Cat", y = "G",
    x_axis_name = NULL,
    units_table, palette = colour_aes_for_qual1,
    totals_table = totals_by_cat)

# -- plots with relative values
N_relative_plot <-
  build_relative_histo_plot(table, x = "Cat", y = "N", palette = colour_aes_for_qual1)
G_relative_plot <-
  build_relative_histo_plot(table, x = "Cat", y = "G", palette = colour_aes_for_qual1)

# -- stack all plots
# legend
mylegend <- g_legend(N_absolute_plot)
  grid.arrange(
    arrangeGrob(
      N_absolute_plot + theme(legend.position = "none"),
      N_relative_plot + theme(legend.position = "none"),
      G_absolute_plot + theme(legend.position = "none"),
      G_relative_plot + theme(legend.position = "none"),
      nrow = 2, heights = rep(1, 2)
    ),
    mylegend, nrow = 2, heights = c(12, 1)
  )
@
\FloatBarrier


\subsection{\Sexpr{i18n()$t("Analyse par essence")}}
\Sexpr{i18n()$t("La figure")} \ref{fig:species-qual1_relative_bar_chart} \Sexpr{i18n()$t("illustre la répartition de la surface terrière des individus précomptables des différentes essences (regroupées) par qualité. Elle est complétée par le tableau")} \ref{species-qual1_distribution_table}\Sexpr{i18n()$t(". Les essences sont triées par ordre de surface terrière décroissante.")}

<<species-qual1_relative_bar_chart, size = 'footnotesize', fig.height = 4, fig.cap = i18n()$t("Importance relative des qualités sur la surface terrière des individus précomptables des différentes essences"), fig.pos = "H">>=
  # -- grob settings
  grob_settings <- list(
    layers = list(
      geom_bar = list(),
      geom_label = list(
        label.padding_unit.num = 0.15,
        label.r_unit.num = 0.15,
        fill = "white",
        size = 1.7,
        alpha = 1,
        fontface = "plain"
      )
    ),
    guides = list(
      fill = list(reverse = T)
    ),
    theme = list(
      title = list(size = 7),
      text = list(size = 7),
      axis.title.x = list(size = 9),
      axis.text.x = list(size = 7),
      axis.text.y = list(size = 6),
      legend.text = list(size = 7),
      legend.position = "bottom",
      legend.direction = "horizontal",
      plot.margin_unit.num = c(0.1, 0.3, 0.1, 0.1)
    )
  )


  # -- main table
  table <-
    gfForetFpied_EssRegReg1 %>%
    filter(Cycle == last_cycle & NumForet == forest_num) %>%
    
    # filter empy values
    filter(Gha > 0) %>% 

    # rename
    rename(Essence = EssReg) %>%

    select(Essence, Reg1, Gha, VcHa, VpHa) %>%
    pivot_longer(
      cols = c("Gha", "VcHa", "VpHa"),
      names_to = "variable",
      values_to = "value"
    ) %>%

    # calcul totaux
    group_by(Essence, variable) %>%
    mutate(total = sum(value, na.rm = T)) %>%
    ungroup() %>%

    # get share and label, sort species
    mutate(
      # share
      share = value / total,

      # sort qual1
      Reg1 = factor(
        Reg1,
        levels = rev(names(colour_aes_for_qual1))
      ),

      # translation
      Essence = i18n()$t(Essence),

      # sort species
      Essence = factor(Essence, levels = rev(grouped_species_order)) #rev(standing_trees_species_order)
    ) %>%
    arrange(Essence, variable, desc(Reg1)) %>%

    # calcul cumul share
    group_by(Essence) %>%
    mutate(cumul_share = cumsum(share)) %>%
    ungroup() %>%
    mutate(
      label_y = round(cumul_share - share / 2, 3),
      label_str = ifelse(share > 0.05, paste0(round(share * 100), " %"), NA)
    )

  # -- pie chart plot
  build_pie_chart(
    table = table,
    var = "Gha",
    x = "Essence",
    y = "value",
    attribute = "Reg1",
    fill_scale_range = colour_aes_for_qual1,
    fill_scale_name = i18n()$t("Qualités de\r\nbille de pied"),
    y_axis_name = i18n()$t("Part relative des essences"),
    plot_title = NULL,
    grob_settings = grob_settings,
    pie_chart = F
  )
@
\FloatBarrier

<<species-qual1_distribution_table, results = 'asis', fig.pos = "H">>=
  # -- call 'set_up_results_by_2_attributes_table'
  results_with_attribute1_and_attribute2 <-
    gfForetFpied_EssRegReg1 %>% rename(Essence = EssReg) %>% filter(Gha > 0)
  attribute1 <- "Essence" # row attribute
  attribute2 <- "Reg1" # column attribute
  attribute1_levels <- grouped_species_order
  attribute2_levels <- names(colour_aes_for_qual1)
  var <- "Gha"
  attribute1_name <- i18n()$t("Essences")
  attribute1_total_label <- i18n()$t("\\textbf{Total par essence}")
  attribute2_total_label <- i18n()$t("\\textbf{Total par qualité}")
  table_title <- i18n()$t("Répartition de la surface terrière des qualités par essence")
  table_label <- "species-qual1_distribution_table"

  set_up_results_by_2_attributes_table(
    results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
    forest_num = forest_num,
    last_cycle = last_cycle,
    attribute1 = attribute1,
    attribute2 = attribute2,
    var = var,
    attribute1_name = attribute1_name,
    attribute1_levels = attribute1_levels,
    attribute2_levels = attribute2_levels,
    attribute1_total_label = attribute1_total_label,
    attribute2_total_label = attribute2_total_label,
    table_title = table_title,
    table_label = table_label
  )
@
\FloatBarrier

\subsection{\Sexpr{i18n()$t("Analyse par structure")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:diam_cat-qual1_relative_bar_chart} \Sexpr{i18n()$t("et le tableau")} \ref{diam_cat-qual1_distribution_table} \Sexpr{i18n()$t("illustrent la répartition de la surface terrière de précomptables par catégorie de diamètre, en distinguant les différentes qualités.")}
% \textcolor{red}{Arrangement fait ici : ait choisi de garder l'histogramme montrant la part de chaque qualité dans les différentes Catégories de diamètre + le tableau montrant la part de chaque Catégorie de diamètre dans chaque qualité => 1 histogramme et 1 tableau supprimés}

<<diam_cat-qual1_relative_bar_chart, size = 'footnotesize', fig.height = 2.5, fig.cap = i18n()$t("Importance relative des qualités sur la surface terrière des individus précomptables des différentes catégories de diamètre"), fig.pos = "H">>=
  # -- grob settings
  grob_settings <- list(
    layers = list(
      geom_bar = list(),
      geom_label = list(
        label.padding_unit.num = 0.15,
        label.r_unit.num = 0.15,
        fill = "white",
        size = 1.7,
        alpha = 1,
        fontface = "plain"
      )
    ),
    guides = list(
      fill = list(reverse = T)
    ),
    theme = list(
      title = list(size = 7),
      text = list(size = 7),
      axis.title.x = list(size = 9),
      axis.text.x = list(size = 7),
      axis.text.y = list(size = 6),
      legend.text = list(size = 7),
      legend.position = "bottom",
      legend.direction = "horizontal",
      plot.margin_unit.num = c(0.1, 0.3, 0.1, 0.1)
    )
  )


  # -- table
  table <-
    gfForetFpied_CatReg1 %>%
    filter(Cycle == last_cycle & NumForet == forest_num) %>%
    select(Cat, Reg1, Gha, VcHa, VpHa) %>%
    pivot_longer(
      cols = c("Gha", "VcHa", "VpHa"),
      names_to = "variable",
      values_to = "value"
    ) %>%

    # calcul totaux
    group_by(Cat, variable) %>%
    mutate(total = sum(value, na.rm = T)) %>%
    ungroup() %>%

    # get share and label, sort species
    mutate(
      # share
      share = value / total,

      # sort qual1
      Reg1 = factor(
        Reg1,
        levels = rev(names(colour_aes_for_qual1))
      ),

      # translation
      Cat = i18n()$t(Cat),

      # sort species
      Cat = factor(Cat, levels = names(colour_aes_for_diameter_category))
    ) %>%
    arrange(Cat, variable, desc(Reg1)) %>%

    # calcul cumul share
    group_by(Cat) %>%
    mutate(cumul_share = cumsum(share)) %>%
    ungroup() %>%
    mutate(
      label_y = round(cumul_share - share / 2, 3),
      label_str = ifelse(share > 0.05, paste0(round(share * 100), " %"), NA)
    )

  # -- pie chart plot
  build_pie_chart(
    table = table,
    var = "Gha",
    x = "Cat",
    y = "value",
    attribute = "Reg1",
    fill_scale_range = colour_aes_for_qual1,
    fill_scale_name = i18n()$t("Qualités de\r\nbille de pied"),
    y_axis_name = i18n()$t("Part relative des catégories de diamètre"),
    # plot_title = NULL,
    grob_settings = grob_settings,
    pie_chart = F
  )
@
\FloatBarrier

<<diam_cat-qual1_distribution_table, results='asis', fig.pos = "H">>=
   # -- call 'set_up_results_by_2_attributes_table'
  results_with_attribute1_and_attribute2 <- gfForetFpied_CatReg1
  attribute1 <- "Cat" # row attribute
  attribute2 <- "Reg1" # column attribute
  attribute1_levels <- i18n()$t(rev( names(colour_aes_for_diameter_category) ))
  attribute2_levels <- names(colour_aes_for_qual1)
  var <- "Gha"
  attribute1_name <- i18n()$t("Catégories de diamètre")
  attribute1_total_label <- i18n()$t("\\textbf{Total par catégorie}")
  attribute2_total_label <- i18n()$t("\\textbf{Total par qualité}")
  table_title <- i18n()$t("Répartition de la surface terrière des qualités par catégorie de diamètre")
  table_label <- "diam_cat-qual1_distribution_table"

  set_up_results_by_2_attributes_table(
    results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
    forest_num = forest_num,
    last_cycle = last_cycle,
    attribute1 = attribute1,
    attribute2 = attribute2,
    var = var,
    attribute1_name = attribute1_name,
    attribute1_levels = attribute1_levels,
    attribute2_levels = attribute2_levels,
    attribute1_total_label = attribute1_total_label,
    attribute2_total_label = attribute2_total_label,
    table_title = table_title,
    table_label = table_label
  )
@
\FloatBarrier

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsection{\Sexpr{i18n()$t("Evolution de la qualité")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:evol_G_by_qual1_plot} \Sexpr{i18n()$t("illustre l'évolution de la surface terrière au cours du temps, déclinée par qualité.")}\\
\Sexpr{i18n()$t("La partie gauche de la figure représente l'importance relative de la surface terrière pour les différentes qualités.")}\\
\Sexpr{i18n()$t("La partie droite de la figure présente l'évolution de la surface terrière par qualité.")}

<<evol_G_by_qual1_tables, eval = eval_evol, include = eval_evol>>=
# -- ranges
# colour_aes_for_qual1 <- c("#EDF8E9", "#BAE4B3", "#74C476", "#238B45")
# names(colour_aes_for_qual1) <- c("D", "C", "B", "A")
# sorted_cat <- c("PER", "PB", "BM", "GB", "TGB") # TODO : ordre à enregistrer 1 fois pour toutes

# # Attention doublons : ranges définies plus haut déjà
# if (last_cycle > 2) {
# range_alpha <- c(1, rep(0.3, last_cycle - 2), 1)
# }
# if (last_cycle == 2) {
#   range_alpha <- c(1, 1)
# }
# range_size <- c(2, rep(1, last_cycle - 2), 2)
# range_shape <- c(6, rep(1, last_cycle - 2), 2)
#
# # sorted years
# sorted_years <-
#   with(Cycles %>% filter(NumForet == forest_num) %>% arrange(Cycle), Annee)
# # => range names
# names(range_alpha) <- names(range_size) <- names(range_shape) <- sorted_years


# -- main table
table <-
  gfForetFpied_Reg1 %>%
  filter(NumForet == forest_num) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  select(Annee, Reg1, Gha, VcHa, VpHa) %>%
  mutate(
    Reg1 = factor(
      Reg1,
      levels = names(colour_aes_for_qual1)
    )
  ) %>%
  arrange(Annee, Reg1)


# -- table for pie chart
pie_chart_table <-
  table %>%
  pivot_longer(
    cols = c("Gha", "VcHa", "VpHa"),
    names_to = "variable",
    values_to = "value"
  ) %>%

  # calcul totaux
  group_by(Annee, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share and label, sort categories
  mutate(
    # share
    share = value / total,

    # sort cat
    Reg1 = factor(
      Reg1,
      levels = rev( names(colour_aes_for_qual1) )
    ),

    # year factor
    Annee = factor(Annee),

    # define label settings
    label_y = 0.5, # position
    label_str = Annee # label string
  ) %>%
  arrange(Annee, variable, Reg1)


# -- table for scatter plot
scatter_plot_table <-
  table %>%
  mutate(Annee = factor(Annee, levels = sorted_years))

# -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 7),
    axis.title.x = list(size = 7),
    axis.text.x = list(size = 7),
    legend.text = list(size = 5),
    legend.position = "bottom",
    legend.direction = "horizontal",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)
@

<<evol_G_by_qual1_plot, fig.height = 4, fig.cap = i18n()$t("Evolution de la surface terrière des qualités entre les différents inventaires"), eval = eval_evol, include = eval_evol>>=
# -- pie chart plot
pie_chart_plot <- build_pie_chart(
  table = pie_chart_table, # debug 55 - %>% filter(!is.na(Qual1)),
  var = "Gha",
  x = "Annee",
  y = "value",
  attribute = "Reg1",
  fill_scale_range = colour_aes_for_qual1,
  fill_scale_name = i18n()$t("Qualités :"),
  # y_axis_name = NULL,
  plot_title = i18n()$t("Part relative des catégories de diamètre sur la surface terrière\r\nau cours des différents inventaires"),
  grob_settings = grob_settings
)


# -- scatter plot
scatter_plot <- build_evol_scatter_plot(
  # data
  table = scatter_plot_table,  # debug 55 - %>% filter(!is.na(Qual1)),
  var = "Gha",
  attribute = "Reg1",
  last_cycle = last_cycle,

  # ranges
  alpha_scale_range = range_alpha,
  size_scale_range = range_size,
  shape_scale_range = range_shape,
  colour_scale_range = colour_aes_for_qual1,

  # labels
  x_axis_name = NULL, # i18n()$t("Qualités"),
  y_axis_name = "G (m2/ha)",
  scale_name = NULL, # i18n()$t("Années d'inventaire"),
  plot_title = i18n()$t("Evolution de la surface terrière des catégories de diamètre\r\nau cours des différents inventaires")
)


# -- arrange plots
grid.arrange(
  pie_chart_plot, scatter_plot,
  nrow = 1, widths = rep(1, 2)
)
@
\FloatBarrier
}{}

\section{\Sexpr{i18n()$t("Analyse du renouvellement")}}

\subsection{\Sexpr{i18n()$t("Régénération")}}

\EditIf{\Sexpr{eval_regen}}{TRUE}{

\subsubsection{\Sexpr{i18n()$t("Stades de développement")}}

\Sexpr{i18n()$t("Le tableau")} \ref{seedling_table} \Sexpr{i18n()$t("présente les résultats d'inventaire sur la régénération naturelle.")}

<<seedling_table, fig.pos = 'H', results = 'asis', eval = eval_regen, include = eval_regen>>=
  t_TOT1 <-
    gfForetRege_Rejet %>%
    filter(NumForet == forest_num & Cycle == last_cycle) %>%
    select(
      Rejet, Classe1Ha, Classe2Ha, Classe3Ha,
      Er_Classe1Ha, Er_Classe2Ha, Er_Classe3Ha
    ) %>%
    mutate(
      Essence = "\\cellcolor{LightGray} \\textbf{Total}",
      Total = round(Classe1Ha + Classe2Ha + Classe3Ha, 0)
    ) %>%
    # filter empty rows
    filter(Total > 0) %>%
    mutate(
      Total_Mark = Total,
      Total = paste0(
        "\\cellcolor{DimGray}{\\textcolor{White}{\\textbf{",
        ifelse(Total == 0, "", Total),
        "}}}"
      ),

      Classe1Ha = paste0(
        "\\cellcolor{LightGray} \\textbf{",
        round(Classe1Ha, 0),
        ifelse(
          is.na(Er_Classe1Ha),
          "",
          paste0(" \\textcolor{CornflowerBlue}{(±", round(Er_Classe1Ha, 1), "\\%)}")
        ),
        "}"
      ),
      Classe2Ha = paste0(
        "\\cellcolor{LightGray} \\textbf{",
        round(Classe2Ha, 0),
        ifelse(
          is.na(Er_Classe2Ha),
          "",
          paste0(" \\textcolor{CornflowerBlue}{(±", round(Er_Classe2Ha, 1), "\\%)}")
        ),
        "}"
      ),
      Classe3Ha = paste0(
        "\\cellcolor{LightGray} \\textbf{",
        round(Classe3Ha, 0),
        ifelse(
          is.na(Er_Classe3Ha),
          "",
          paste0(" \\textcolor{CornflowerBlue}{(±", round(Er_Classe3Ha, 1), "\\%)}")
        ),
        "}"
      )
    ) %>%
    select(Essence, Classe1Ha, Classe2Ha, Classe3Ha, Total, Rejet, Total_Mark) #%>%
  # melt(id = "Essence")


t1 <-
  regeneration_main_results_by_grouped_species %>%
  rbind(t_TOT1) %>%
  arrange(Rejet) %>% #, Total_Mark
  mutate(
    Total_Mark = NULL,
    Rejet = ifelse(
      Rejet == 1,
      paste0(
        "\\parbox{2cm}{\\centering ",
        i18n()$t("semis non viable et/ou de rejet de souche"),
        "}"
        ),
      paste0(
        "\\parbox{2cm}{\\centering ",
        i18n()$t("semis viable et de franc-pied"),
        "}"
        )
    )
  ) %>%
  set_multirow_table(6) %>%
  rename(
    !!i18n()$t("Essences") := "Essence",
    !!i18n()$t("Classe 1 (nb/ha)") := "Classe1Ha",
    !!i18n()$t("Classe 2 (nb/ha)") := "Classe2Ha",
    !!i18n()$t("Classe 3 (nb/ha)") := "Classe3Ha",
    !!i18n()$t("Total") := "Total",
    !!i18n()$t("Nature semis") := "Rejet"
  )
names(t1) <- paste0("\\textbf{", names(t1), "}")

# --- Position des lignes du tableau
Expr_add <- c()
pos_add <- list()

# -- cas où 1 seule essence (en viable ou non viable)
pos1 <- which(!is.na(t1[, 6]))
  # non viable
if (dim(regeneration_main_results_by_grouped_species %>% filter(Rejet == 0))[1] == 1) {
  rows_to_enlarge <- pos1[1]
  rows_to_enlarge <- c(rows_to_enlarge, rows_to_enlarge + 1)
  for (i in 1:length(rows_to_enlarge)) {
    pos_add[length(pos_add) + 1] <- list(rows_to_enlarge[i])
    # print(pos_add) debug
  }
  Expr_add <- c(
    Expr_add,
    rep("[1ex]", length(rows_to_enlarge))
  )
}
# viable
table_dim <- dim(regeneration_main_results_by_grouped_species %>% filter(Rejet == 1))[1]
if (table_dim > 0 & table_dim <= 3) {

  rows_to_enlarge <- if (length(pos1) > 1) pos1[2] else pos1
  rows_to_enlarge <- c(rows_to_enlarge : (rows_to_enlarge + table_dim - 1))
  for (i in 1:length(rows_to_enlarge)) {
    pos_add[length(pos_add) + 1] <- list(rows_to_enlarge[i])
    # print(pos_add) debug
  }
  # TODO : adapter le 1ex au nombre de lignes ?
  Expr_add <- c(
    Expr_add,
    rep("[1ex]", length(rows_to_enlarge))
  )
}

pos1 <- which(!is.na(t1[, 6]))
pos2 <- 1:dim(t1)[1]
if (length(pos1) > 1) {
pos1 <- pos1[2] - 1
# pos2 <- c(pos2[!pos2 %in% pos1], pos1)
pos2 <- c( setdiff(pos2, pos1), pos1 )

for (i in 1:length(pos2)) {
  pos_add[length(pos_add) + 1] <- list(pos2[i])
  # print(pos_add) # debug
}
Expr_add <- c(
  Expr_add,
  rep("\\cline{1-5}", length(pos2) - 1),
  "\\cmidrule[0.8pt]{1-6}"
)
} else {
  pos1 <- NA

for (i in 1:length(pos2)) {
  pos_add[length(pos_add) + 1] <- list(pos2[i])
  # print(pos_add) # debug
}
  Expr_add <- c(
    Expr_add,
    rep("\\cline{1-5}", length(pos2))
    )
}

# -- print table
print(
  xtable(
    t1,
    caption = i18n()$t("Inventaire de la régénération \\scriptsize{\\\\Classe 1 = hauteur semis < 1.50 m\\\\Classe 2 = hauteur semis > 1.50 m et diamètre < 2.5 cm\\\\Classe 3 = 2.5 cm < diamètre < 7.5 cm}"),
    caption.placement = "top",
    digits = rep(0, dim(t1)[2] + 1),
    align = c(
      "|M{0.5cm}|", "|M{2cm}|", "M{2cm}|", rep("M{2cm}|", dim(t1)[2] - 3),
      "M{2.5cm}|"
    ),
    label = "seedling_table"
  ),
  include.rownames = FALSE,
  include.colnames = TRUE,
  sanitize.text.function = function(x) {return(x)},
  add.to.row = list(pos = pos_add, command = Expr_add),
  size = "\\footnotesize"
)


# ----- Nombre de placettes régénérées :
df <-
  Reges %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, NumPlac, SsPlac, Essence, Class1, Class2, Class3) %>%
  melt(id = c("NumForet", "NumPlac", "SsPlac", "Essence")) %>%
  group_by(NumForet, NumPlac, SsPlac) %>%
  summarise(
    value = sum(value),
    Check = ifelse(value >= 5, 1, 0)
  ) %>%
  ungroup()

Taux = round(sum(df$Check) / length(df$Check) * 100, 1)
@
\FloatBarrier

<<prepare_sentence_seedlings_nb, eval = eval_regen, include = eval_regen>>=
  seedlings_nb_str <-
    if (length(species_to_regenerate) > 1) {
      paste0(i18n()$t("des "), length(species_to_regenerate), i18n()$t(" essences principales."))
    } else {
      i18n()$t("de l'essence principale.")
    }
@

\Sexpr{i18n()$t("La figure")} \ref{fig:seedling_bar_charts} \Sexpr{i18n()$t("présente le nombre de semis")} \Sexpr{seedlings_nb_str}

<<seedling_bar_charts, fig.pos = 'H', fig.width = "\\textwidth", fig.height = 3, fig.cap = i18n()$t("Nombre de semis par classes"), results = 'asis', eval = eval_regen, include = eval_regen>>=

# -- alibi # TODO : à revoir
species_to_regenerate_ALIBI <- data.frame(
  Essence = rep(species_to_regenerate, 3),
  variable = c(
    rep(i18n()$t("Classe 1"), length(species_to_regenerate)),
    rep(i18n()$t("Classe 2"), length(species_to_regenerate)),
    rep(i18n()$t("Classe 3"), length(species_to_regenerate))
  ),
  stringsAsFactors = F)

# -- table
df <-
  gfForetRege_EssRegRejet %>%
  mutate(
    # translation
    Essence = i18n()$t(EssReg)
  ) %>%
  filter(
    NumForet == forest_num & Cycle == last_cycle &
      Rejet == 0 & is.element(Essence, species_to_regenerate)
  ) %>%
  select(Essence, Classe1Ha, Classe2Ha, Classe3Ha) %>%
  rename(
    !!i18n()$t("Classe 1") := "Classe1Ha",
    !!i18n()$t("Classe 2") := "Classe2Ha",
    !!i18n()$t("Classe 3") := "Classe3Ha"
  ) %>%
  melt(id = "Essence") %>%
  mutate(variable = as.character(variable)) %>%
  full_join(
    species_to_regenerate_ALIBI,
    by = c("Essence", "variable")
  ) %>%
  mutate(
    value = ifelse(is.na(value), 0, value),

    Essence = factor(Essence, levels = species_to_regenerate)
  ) %>%
  arrange(Essence)

# -- plot settings
Y_max = max(df$value)
# security
Y_max = ifelse(Y_max == 0, 10, Y_max)

# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plot
ggplot() +
  geom_bar(
    df,
    mapping = aes(variable, value, fill = Essence),
    stat = "identity", position = "dodge",
    width = 0.5, colour = "gray50"
  ) +
  scale_fill_manual(
    name = i18n()$t("Essence"),
    values = colour_aes_for_grouped_species
  ) +
  scale_x_discrete(expand = c(0.1, 0.1)) +
  scale_y_continuous(
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value)
  ) +
  labs(
    x = i18n()$t("Classes de régénération"),
    y = i18n()$t("Nombre de semis à l'hectare")
  ) +
  theme_bw() +
  MyTheme
@
\FloatBarrier


\subsubsection{\Sexpr{i18n()$t("Surface régénérée")}}

\Sexpr{i18n()$t("Le tableau")} \ref{regenerated_area_table} \Sexpr{i18n()$t("présente la surface considérée comme régénérée (fonction du nombre de sous-placettes à n $\\geqslant$ 5 semis).")}\\

<<regenerated_area_table, fig.width="\\textwidth", fig.height=3, eval = eval_regen, include = eval_regen, results = 'asis'>>=

# regenerated area by "Rejet" attribute's value
df1 <-
  Reges %>%
  filter(
    NumForet == forest_num & Cycle == last_cycle & 
      Rejet == 0 & !is.na(EssReg)
  ) %>% #!is.element(Rejet,c("X","x"))
  
  mutate(
    Essence = EssReg, 
    Surf = Class1 + Class2 + Class3
    ) %>%

  # filter Surf > 0
  filter(Surf > 0) %>%

  group_by(NumForet, NumPlac, SsPlac, Essence, Rejet) %>%
  summarise(
    Surf = sum(Surf), 
    Surf = ifelse(Surf >= 5, 1, 0)
    ) %>%
  group_by(Essence, Rejet) %>%
  summarise(Valide = sum(Surf) / sub_plot_nb) %>%
  ungroup() %>%
  mutate(
    # translation
    Essence = i18n()$t(Essence),
    Essence = factor(Essence, levels = c(regen_grouped_species_order))
  ) %>%
  arrange(Essence)

# regenerated area - total
df2 <-
  Reges %>%
  filter(
    NumForet == forest_num & Cycle == last_cycle & Rejet == 0 & !is.na(EssReg)
  ) %>% #!is.element(Rejet,c("X","x"))
  # mutate(Essence="\\cellcolor{LightGray} \\textbf{Total}",
  mutate(
    Essence = "\\rowcolor{LightGray} \\textbf{Total}",
    Surf = Class1 + Class2 + Class3
  ) %>%
  group_by(NumForet, NumPlac, SsPlac, Essence, Rejet) %>%
  summarise(Surf = sum(Surf), Surf = ifelse(Surf >= 5, 1, 0)) %>%
  group_by(Essence, Rejet) %>%
  summarise(Valide = sum(Surf) / sub_plot_nb) %>%
  ungroup()

  df <- rbind(df1, df2) %>%
    data.frame() %>%  # Important que la table soit un data.frame pour faire marcher set_multirow_table correctement (en utilisant str(), vérifier qu'on n'a pas "Classes ‘tbl_df’, ‘tbl’ and 'data.frame'")
    arrange(Essence, Valide) %>%
    mutate(
      Valide = ifelse(
        !is.na(Valide),
        paste0(round(Valide * 100, 0), " \\%"),
        Valide
      ),
      Valide = ifelse(
        Essence == "\\rowcolor{LightGray} \\textbf{Toutes essences confondues}",
        paste0("\\textbf{", Valide, "}"),
        Valide
      )
    ) %>%
    select(Essence, Valide) %>% 
  rename(
      !!paste0("\\textbf{", i18n()$t("Essences"), "}") := "Essence",
      !!paste0("\\textbf{", i18n()$t("Surface"), "}") := "Valide"
    )

  # -- print table
  print(
    xtable(
      df,
      caption = i18n()$t("Surface considérée comme régénérée"),
      # digits=c(0,0,1,rep(0,dim(df)[2]-2)),
      digits = rep(0, ncol(df) + 1),
      # align=c(rep("P{1.5cm}|",dim(t4)[2]),"P{1.5cm}"), #☺c("l|","l|","P{1cm}|","P{1.5cm}|","P{1.5cm}"),
      align = c("|M{0.5cm}|", "|M{2.5cm}|", rep("M{2.5cm}|", ncol(df) - 1)),
      label = "regenerated_area_table"
    ),
    # caption.placement = "top",
    include.rownames = FALSE,
    include.colnames = TRUE,
    sanitize.text.function = function(x) {return(x)},
    # hline.after=c(-1:dim(df)[1]),
    # add.to.row=list(pos=pos_add,
    #                 command=Expr_add),
    size="\\footnotesize"
  )

@
\FloatBarrier


<<browsing_plot, fig.pos = 'H', fig.height = 2, fig.cap = i18n()$t("Importance de l'abroutissement"), results='asis', eval = T, include = T>>=

species_to_regenerate_ALIBI <- data.frame(
  Essence = rep(species_to_regenerate, 1),
  Abroutis = rep(1, length(species_to_regenerate)),
  stringsAsFactors = F
)

t1 <-
  Reges %>%
  filter(
    NumForet == forest_num &
      Cycle == last_cycle # modif Nov 2022 & Rejet == 0
  ) %>%
  select(Abroutis, Essence, Class1) %>%
  full_join(species_to_regenerate_ALIBI, by = c("Abroutis", "Essence")) %>%
  mutate(
    Class1 = ifelse(is.na(Class1), 0, Class1),
    Essence = factor(Essence, levels = species_to_regenerate)
  ) %>%
  filter(!is.na(Essence)) %>%
  arrange(Essence)

# test eval browsing
eval_browsing <- T
# eval_browsing <- with(t1, which(Abroutis == 1 & Class1 > 0))

if (length(eval_browsing) > 0) {
  cat(
    "\\subsubsection{Abroutissement}\n",
    i18n()$t("L'histogramme de la figure"), "\\ref{fig:browsing_plot}", i18n()$t("représente le taux d'abroutissement des semis de classe 1 (hauteur comprise entre 0, 5 m et à 1, 50 m) pour les 4 principales essences.\\\\Cette classe est la seule à être représentée car la plus sensible à l'abroutissement.\\\\")
  )

  t1.m <-
    t1 %>%
    mutate(
      Abroutis = ifelse(
        tolower(Abroutis) == "f" | Abroutis == 0 | is.na(Abroutis),
        "non", "oui"
      ),
      Abroutis = factor(
        Abroutis, levels = c("oui", "non")
      ),
      Class1 = as.numeric(Class1)
    ) %>%
    group_by(Essence, Abroutis) %>%
    summarise(
      Class1 = sum(Class1)
    ) %>%
    group_by(Essence) %>%
    mutate(
      Class1 = ifelse(
        Class1 > 0,
        Class1 / sum(Class1, na.rm = T),
        Class1
      )
    ) %>%
    ungroup() %>%
    arrange(Abroutis) %>%
    gather(variable, value, Class1) %>%
    filter(Abroutis == "oui")

if (dim(t1.m)[1] > 0) {
  ggplot() +
    geom_bar(
      t1.m,
      mapping = aes(
        x = variable,
        y = value,
        fill = Essence
      ),
      stat = "identity",
      position = 'dodge',
      colour = "black",
      width = 0.5
    ) +
  # scale_fill_manual(values=c("black", "white")) +
    ggplot2::geom_text(
      t1.m,
      mapping = aes(
        x = variable,
        y = value,
        group = Essence,
        label = paste0(round(value * 100, 0), " %")),
      vjust = -1, size = 2.5,
      position = position_dodge(width = 0.5)
    ) +
    # geom_vline(xintercept = 1.5, linetype = 2) +
    scale_y_continuous(
      name = "Taux d'abroutissement (%)",
      labels = percent_format(accuracy = 1), limits = c(0, 1)
    ) +
    scale_x_discrete(
      expand = c(0, 1),
      label = c("Classe 1 \n(50 cm < H < 1.50 m)")
    ) +
    scale_fill_manual(
      name = i18n()$t("Essence"),
    values = colour_aes_for_grouped_species
    ) +
    # guides(
    #   fill = guide_legend(title = "Abroutissement", ncol = 2)
    # ) +
    labs(x = "", y = "") +
    MyTheme
}
}
# load(paste0(repSav, "/tables/afiTablesBrutes.Rdata"))
@
\FloatBarrier

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{

\subsubsection{\Sexpr{i18n()$t("Evolution du renouvellement")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:evol_seedlings_line_graph} \Sexpr{i18n()$t("retrace l'évolution au cours du temps des différentes classes de régénération naturelle, toutes essences confondues (semis viables uniquement).")}

<<evol_seedlings_line_graph, fig.pos = 'H', fig.height = 3, fig.cap = i18n()$t("Evolution des différentes classes de régénération (toutes essences confondues)"), results = 'asis', eval = eval_regen, include = eval_regen>>=

# Classe1_Seuil <- 3700
# Classe2_Seuil <- 1500
# Classe3_Seuil <- 250
# Perches_Seuil <- 50

  cycles_tmp <-
  Cycles %>% select(NumForet, Cycle, Annee) %>% filter(NumForet == forest_num)

# -- table
table <-
  gfForetRege_Rejet %>%
  filter(NumForet == forest_num & Rejet == 0) %>% #!is.element(Rejet, c("X", "x"))
  right_join(
    cycles_tmp,
    by = c("NumForet", "Cycle")
  ) %>%
  complete(nesting(NumForet, Foret, Cycle, Annee)) %>%
  select(NumForet, Annee, Classe1Ha, Classe2Ha, Classe3Ha) %>%
  mutate(Total = Classe1Ha + Classe2Ha + Classe3Ha) %>%
  pivot_longer(
    cols = -c("NumForet", "Annee"),
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(
    Annee = factor(Annee),
    variable = gsub("Classe", "Classe ", variable),
    variable = gsub("Ha", "", variable),

    # translation
    variable = i18n()$t(variable)
  )

# -- plot settings
  # units
  # y_unit <- with(units_table, units_label[match(y_var, var)])

# axis max values
  X_max = length(unique(table$Annee))
  Y_max = max(table$value, na.rm = T)
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)

  # increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plot
ggplot() +
  geom_line(
    table,
    mapping = aes(x = Annee, y = value, colour = variable, group = variable)
  ) +
  scale_y_continuous(
    name = i18n()$t("Nombre de semis à l'hectare"),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value),
    expand = c(0, 0)
  )  +
  scale_colour_manual(
    name = i18n()$t("Classes de\r\nrégénération"),
    values = c("darkgreen", "forestgreen", "chartreuse3", "red")
  )  +
  labs(x = i18n()$t("Années d'inventaire"))  +
  theme_bw() +
  MyTheme  +
  theme(
    legend.direction = "horizontal",
    legend.position = "bottom"
  )
@

\Sexpr{i18n()$t("Le tableau")} \ref{evol_seedlings_by_species_table} \Sexpr{i18n()$t("et la figure")} \ref{fig:evol_seedlings_by_species_line_graph} \Sexpr{i18n()$t("présentent l'évolution du nombre de semis")} \Sexpr{seedlings_nb_str}

<<evol_seedlings_by_species_table, fig.pos = 'H', fig.height = 3, results = 'asis', eval = eval_evol & eval_regen, include = eval_evol & eval_regen>>=

# -- tables
# -- plot table (chunks in common)
# rege results by species with rejet == 0
plot_table <-
  gfForetRege_EssRegRejet %>%

  # translation
  mutate(Essence = i18n()$t(EssReg)) %>%

  # filter
  filter(
    NumForet == forest_num & Rejet == 0 &
      Essence %in% species_to_regenerate
  ) %>%

  # join cycles_tmp to get years (+ missing cycle eventually)
  right_join(
    cycles_tmp,
    by = c("NumForet", "Cycle")
  ) %>%

  # # security if year(s) missing
  # mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  # complete(NumForet, Cycle, fill = list(Gha = 0)) %>%
  # mutate(Cycle = as.numeric(Cycle)) %>%
  #
  # # join cycles to get year
  # left_join(
  #   Cycles[, c("NumForet", "Cycle", "Annee")],
  #   by = c("NumForet", "Cycle")
  # ) %>%

  mutate(
  # calculate total
    total = Classe1Ha + Classe2Ha + Classe3Ha,

    # sort species
    Essence = factor(Essence, levels = c(species_to_regenerate)) # regen_grouped_species_order
  ) %>%
  
  # complete missing species and/or year
  complete(Annee, Essence, fill = list(total = 0)) %>% 
  
  select(Annee, Essence, total) %>%
  arrange(Annee, -total)

# -- table
table <-
  plot_table %>%
  mutate(total = round(total, 0)) %>%
  pivot_wider(
    id_cols = "Essence",
    names_from = "Annee",
    values_from = total
    ) %>%
  arrange(Essence)

# -- total
# rege results with rejet == 0
total_table <-
  gfForetRege_Rejet %>%
  filter(NumForet == forest_num & Rejet == 0) %>% # !is.element(Rejet, c("X", "x"))
  # head(5) %>% debug

  # join cycles_tmp to get years (+ missing cycle eventually)
  right_join(
    cycles_tmp,
    by = c("NumForet", "Cycle")
  ) %>%

  # # complete missing cycle/year
  # complete(nesting(NumForet, Disp, Cycle, Annee)) %>%

  mutate(
    # calculate total
    total = round(Classe1Ha + Classe2Ha + Classe3Ha),
    total = ifelse(is.na(total), 0, total),
    total = paste0("\\textbf{", total, "}"),

    # define Essence
    Essence = "\\rowcolor{LightGray} \\textbf{Total}"
  ) %>%

  # sort
  select(Annee, Essence, total) %>%
  arrange(Annee) %>%

  # pivot
  pivot_wider(
    id_cols = "Essence",
    names_from = "Annee",
    values_from = "total"
    )

# final table
final_table <-
  rbind(table, total_table) %>%
  rename(!!i18n()$t("Essences") := "Essence")
names(final_table) <- paste0("\\textbf{", names(final_table), "}")

# -- print table
print(
  xtable(
    final_table,
    digits = c(0, 0, rep(1, dim(final_table)[2] - 1)),
    align = c("M{0cm}", "|M{1.3cm}|", rep("M{1cm}|", dim(final_table)[2] - 2), "M{1cm}|"),
    caption = i18n()$t("Evolution du nombre de semis par essence"),
    label = "evol_seedlings_by_species_table"
  ),
  caption.placement = "bottom",
  hline.after = -1:dim(final_table)[1],
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  size = "\\footnotesize"
)
@

<<evol_seedlings_by_species_line_graph, fig.pos = 'H', fig.height = 3, fig.cap = i18n()$t("Evolution de la régénération viable par essence (essences principales)"), results = 'asis', eval = eval_evol & eval_regen, include = eval_evol & eval_regen>>=

# -- plot table
plot_table <-
  plot_table %>%
  mutate(Essence = as.character(Essence)) %>%
  complete(Annee, Essence, fill = list(total = 0))


# -- plot settings
Y_max = max(plot_table$total)
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)

  # increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plot
ggplot() +
  geom_line(
    plot_table,
    mapping = aes(
      factor(Annee),
      total,
      colour = Essence,
      group = Essence
    )
  ) +
  scale_y_continuous(
    name = i18n()$t("Nombre de semis à l'hectare"),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value),
    expand = c(0, 0)
  ) +
  scale_colour_manual(
    name = i18n()$t("Essences"),
    values = colour_aes_for_grouped_species
  ) +
  labs(x = i18n()$t("Années d'inventaire")) +
  guides(colour = guide_legend(reverse = T)) +
  theme_bw() +
  MyTheme +
  theme(
    legend.direction = "horizontal",
    legend.position = "bottom"
  )
@
\FloatBarrier
}{}

}{
Il n'y a pas de résultats disponibles pour l'inventaire de la régénération.
}

\subsection{\Sexpr{i18n()$t("Sous-étage : perches et taillis")}}

\subsubsection{\Sexpr{i18n()$t("Perches")}}
\EditIf{\Sexpr{eval_Perches}}{TRUE}{
\Sexpr{i18n()$t("Le tableau")} \ref{stems_species_distribution_table} \Sexpr{i18n()$t("présente le nombre de tiges et la surface terrière des perches par essence.")}

<<stems_species_distribution_table, results = 'asis', fig.pos = "H", eval = eval_Perches, include = eval_Perches>>=
# TODO : à rapprocher de la fonction 'print_main_results_table' ?
# -- order stems_results_by_species species
stems_species_order <-
  gfForetPer_EssReg %>%
  # translation
  mutate(Essence = i18n()$t(EssReg)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num & Nha > 0) %>%
  arrange(-Nha) %>%
  select(Essence) %>%
  distinct() %>%
  unlist() %>%
  unname()

# -- stems : stat var table
stems_results_variability <-
  gfForetPer_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(ends_with("Nha"), ends_with("Gha")) %>%
  # select(ends_with("Nha"), ends_with("Gha"), ends_with("Vha")) %>%
  pivot_longer(
    cols = everything(),
    names_to = "variable",
    values_to = "value"
  ) %>%
  # arrondis des valeurs
  mutate(
    value = case_when(
      variable == "Nha" ~ round(value, 0),
      variable == "Gha" & value < 0.1 ~ round(value, 2),
      # variable %in% c("Gha", "Vha") & value < 0.1 ~ 2,
      variable == "Gha" & value >= 0.1 ~ round(value, 1),
      # variable %in% c("Gha", "Vha") & value >= 0.1 ~ 1,

      str_detect(variable, "CV") ~ round(value, 0),
      str_detect(variable, "Er") ~ round(value, 1)
    ),

    # mean label (for separate)
    variable = ifelse(
      !str_detect(variable, "CV") & !str_detect(variable, "Er"),
      paste0("Moy_", variable),
      variable
    )
  ) %>%
  separate(variable, c("stat", "variable"), sep = "_") %>%
  # variables moy, er, cv en colonnes
  pivot_wider(
    names_from = "stat",
    values_from = "value"
  ) %>%
  mutate(
    # build IC
    IC = paste0(
      "\\emph{[", round(Moy - Er * Moy / 100, 1),
      "-", round(Moy + Er * Moy / 100, 1), "]}"
    ),
    # remove mean column
    Moy = NULL,

    variable = gsub("ha", "", variable),
    variable = gsub("per", "", variable),
    variable = gsub("Ha", "", variable),

    # translation
    variable = i18n()$t(variable),

    variable = paste0("\\cellcolor{LightGray} ", variable)
  ) %>%
  # pivot : variables N et G en colonnes
  pivot_longer(
    cols = -c("variable"),
    names_to = "stat",
    values_to = "value",
    values_transform = list(
      value = as.character
    )
  ) %>%
  pivot_wider(
    id_cols = c("stat"),
    names_from = "variable",
    values_from = "value"
  ) %>%

  # format table
  mutate(
    stat = case_when(
      # stat == "Moy" ~ paste0("\\textbf{", i18n()$t("Coefficient de variation (\\%)"), "}"),
      stat == "CV" ~ i18n()$t("Coefficient de variation (\\%)"),
      stat == "Er" ~ i18n()$t("Erreur relative (\\%)"),
      stat == "IC" ~ i18n()$t("\\emph{Intervalle de confiance}")
    )


    # column 'N' -> no need
    # empty = NA
  ) %>%
  # set_multirow_table(1) %>% # TODO : remplacer les numéros de colonne par les noms de colonne

  # rename
  rename(
    # "\\cellcolor{LightGray} Année" = "Annee",
    "\\cellcolor{LightGray} " = "stat"#,
    #   " " = "empty"
  )

# -- stems results table
var = c("Nha", "Gha")
attribute = "Essence"
attribute_name <- paste0("\\textbf{", i18n()$t("Essences"), "}")
table <-
  gfForetPer_EssReg %>%
  mutate(
    # translation
    Essence = i18n()$t(EssReg),
    Essence = factor(Essence, levels = stems_species_order)
  )

stems_results_by_species <- set_up_main_results_by_attribute_table(
  table = table,
  var = var,
  attribute = attribute,
  # attribute_name = attribute_name,
  forest_num = forest_num,
  last_cycle = last_cycle,
  precision_needed = F
)

# -- print table
stems_results_by_species$print_table <-
  stems_results_by_species$print_table %>%

  # rename
  rename(
    !!attribute_name := "attribute",
    !!paste0("\\textbf{", i18n()$t("N"), "\\hspace{2cm}\\scriptsize{", i18n()$t("(tiges/ha)"), "}}") := "Nha",
    !!paste0("\\textbf{", i18n()$t("G"), "\\hspace{2cm}\\scriptsize{", i18n()$t("(m2/ha)"), "}}") := "Gha"
  )

# -- print table settings
digits_param = rep(0, dim(stems_results_by_species$print_table)[2] + 1)

# -- print tables
# 1st table
cat("\\begin{table}[h]\n\\centering")
print(
  xtable(
    stems_results_by_species$print_table,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(stems_results_by_species$print_table)[2]-1)),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  hline.after = -1:dim(stems_results_by_species$print_table)[1],
  floating = F,
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)

# space
cat("\n\\vspace{0.1cm}\n")

# 2nd table
print(
  xtable(
    stems_results_variability,
    caption = NULL,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(stems_results_variability)[2]-1)),
    label = NULL),
  include.rownames = FALSE,
  include.colnames = FALSE,
  sanitize.text.function = function(x){return(x)},
  hline.after = -1:dim(stems_results_variability)[1],
  floating = F,
  size = "\\footnotesize"
)
cat(paste0("\\caption{", i18n()$t("Nombre de tiges et surface terrière des perches, déclinés par essence"), "}\n\\label{stems_species_distribution_table}\n\\end{table}"))
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:stems_bar_charts} \Sexpr{i18n()$t( paste0("apporte des précisions sur la composition en essences des perches", if (eval_econ) " et sur la répartition de la qualité" else "", ".") )}

<<stems_bar_charts, fig.pos = 'H', fig.height = 3, fig.cap = i18n()$t( paste0("Analyse des perches par essence", if (eval_econ) ", qualité" else "", " et classe de diamètre") ), eval = eval_Perches, include = eval_Perches>>=
### -- density by species ###
# -- table
t1 <-
  gfForetPer_EssRegClasse %>%
  filter(Cycle == last_cycle & Nha > 0) %>%

  # rename
  rename(Essence = EssReg) %>%

  select(Essence, Classe, Nha) %>%
  mutate(
    # translation
    Essence = i18n()$t(Essence),

    Essence = factor(Essence, levels = rev(stems_species_order))
  ) %>%
  # arrange(-Nha) %>%
  arrange(Essence)

t1_lim <-
  t1 %>%
  group_by(Classe) %>%
  summarise(Nha = sum(Nha, na.rm = T))

# -- plot settings
# axis max values
  # X_max = length(unique(table$Annee))
  Y_max = max(t1_lim$Nha)
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)

  # increment scale (y)
  increment_value <- find_increment_value(Y_max)
  
  # guide length
  guide_length <- nrow( table %>% distinct(Essence) )

  # -- plot
p1 <-
  ggplot(t1, aes(x = factor(Classe), y = Nha, fill = Essence)) +
  geom_bar(stat = "identity", position = 'stack', width = 0.5) +
  scale_fill_manual(
    name = i18n()$t("Essences"),
    values = colour_aes_for_grouped_species
  ) +
  scale_y_continuous(
    name = i18n()$t("Nombre de tiges à l'hectare"),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.3, increment_value),
    expand = c(0, 0)
  ) +
  labs(
    x = i18n()$t("Classe de diamètre"),
    y = paste0(i18n()$t("N"), i18n()$t("(tiges/ha)"))
  ) +
  guides( fill = guide_legend(
      ncol = ifelse(guide_length > 8, ceiling(guide_length / 11), 1)
      )) +
  MyTheme1 +
  theme(legend.title = element_text(size = 9))

### -- density by qual1 ###
# -- table
t2 <-
  gfForetPer_ClasseReg1 %>%
  filter(Cycle == last_cycle) %>%
  select(Classe, Reg1, Nha) %>%
  mutate(Reg1 = factor(Reg1, levels = names(colour_aes_for_qual1)))

t2_lim <-
  t2 %>%
  group_by(Classe) %>%
  summarise(Nha = sum(Nha, na.rm = T))

# -- plot settings
Y_max = max(t1_lim$Nha)
  # security
  Y_max = ifelse(Y_max == 0, 10, Y_max)

  # increment scale (y)
  increment_value <- find_increment_value(Y_max)

  # -- plot
p2 <-
    ggplot(t2, aes(x = factor(Classe), y = Nha, fill = Reg1)) +
    geom_bar(stat = "identity", position = 'stack', width = 0.5) +
    scale_fill_manual(values = colour_aes_for_qual1, drop = T) +
    scale_y_continuous(
      name = i18n()$t("Nombre de tiges à l'hectare"),
      limits = c(0, Y_max * 1.1),
      breaks = seq(0, Y_max * 1.3, increment_value),
      expand = c(0, 0)
    ) +
    labs(
      x = i18n()$t("Classe de diamètre"),
      y = paste0(i18n()$t("N"), i18n()$t("(tiges/ha)")),
      fill = i18n()$t("Qualité")
    ) +
    MyTheme1 + theme(legend.title = element_text(size = 9))

  # -- arrange grid
if (!eval_econ) {
  p1
} else {
grid.arrange(p1, p2, widths = c(0.56, 0.44), ncol = 2)
}
@

\Sexpr{i18n()$t("La figure")} \ref{fig:stems_var_boxplot} \Sexpr{i18n()$t("illustre la variabilité, entre les placettes, du nombre de tiges et de la surface terrière des perches.")}

<<stems_var_boxplot, fig.pos = 'H', size = 'footnotesize', include = eval_Perches, eval = eval_Perches, fig.height = 2, fig.width = 4.5, fig.cap = i18n()$t("Variabilité des principales caractéristiques dendrométriques pour les perches")>>=
# -- table
boxplot_table <-
  gfPlaPer_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(-NumPlac) %>%
  pivot_longer(
    cols = -c("NumForet", "Cycle"),
    names_to = "variable",
    values_to = "value"
  )

# -- plots
# densité de tiges
p1 <- build_box_plot(table = boxplot_table, var = "Nha", y_axis_name = i18n()$t("(tiges/ha)"))
# surface terrière
p2 <- build_box_plot(table = boxplot_table, var = "Gha", y_axis_name = i18n()$t("(m2/ha)"))

# -- arrange grid
grid.arrange(p1, p2, widths = c(1, 1))
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:stems_species_distribution_pie_chart} \Sexpr{i18n()$t("présente la part de chaque essence en nombre de tiges et surface terrière.")}

<<stems_species_distribution_pie_chart, size = 'footnotesize', fig.height = 3, fig.cap = i18n()$t("Importance relative des différentes essences pour les perches"), fig.pos = "H", eval = eval_Perches, include = eval_Perches>>=
# -- table
pie_chart_table <-
  stems_results_by_species$plot_table %>%
  filter(variable != "Gainper") %>%
  mutate(
    variable = gsub(coll("ha"), "", variable),
    variable = gsub(coll("Ha"), "", variable),
    variable = gsub(coll("per"), "", variable),

    # translation
   variable = i18n()$t(variable),

    # order
    Essence = factor(attribute, levels = stems_species_order),
    variable = factor(
      variable,
      levels = c(i18n()$t("N"), i18n()$t("G"))
    ),

    # define label settings
    label_y = 0.5, # position
    label_str = variable # label string
  ) %>%
  arrange(variable, Essence)

# # -- theme sizes
# theme_sizes <- list(
#   title = 7,
#   text = 6,
#   axis_title_x = 9,
#   axis_text_x = 7,
#   legend_text = 7
# )
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)

# -- plot
build_pie_chart(
  table = pie_chart_table,
  # var = NULL,
  x = "variable",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  y_axis_name = i18n()$t("Part relative des essences"),
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier
}{
\Sexpr{i18n()$t("Aucune perche inventoriée sur ce dispositif en")} \Sexpr{last_year}.
}
\FloatBarrier

% \noindent\textbf{Dégâts de faune}\\

<<dying_trees_bar_chart, fig.height=2, fig.cap= "Importance des dépérissements", results='asis', eval = F, include = F>>=

# -- plot table
table <- 
  Perches %>% 
  filter(NumForet == forest_num & Cycle == last_cycle & !is.na(Caract1)) %>%
  mutate(
    Caract1 = ifelse(Caract1 == "1", "oui", Caract1), 
    Caract1 = factor(Caract1, levels = c("oui", "non"))
    # Essence = factor(Essence, levels = grouped_majority_species)
  ) %>%
  group_by(EssReg, Caract1) %>%
  summarise(Nha = sum(Nha)) %>%
  ungroup() %>%
  mutate(share = Nha / sum(Nha, na.rm = T), variable = "dégâts faune")


if (nrow(table) > 0) {
  cat("L'histogramme de la figure \\ref{fig:wildlife_damage_bar_chart} représente la part de la densité des perches de l'inventaire endommagées par la faune (frottis).\\\\")
  
# -- plot settings
# Y_max
Y_max = max(table$share, na.rm = T)
# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plot
ggplot(table) +
  geom_bar(
    mapping = aes(x = variable, y = share, fill = EssReg), 
    stat = "identity", position = 'dodge', colour = "black", width = 0.5) +
  geom_text(
    mapping = aes(
      x = variable, y = share, group = EssReg, 
      label = paste0(round(share * 100, 0), " %")
    ), 
    vjust = -1, size = 2.5, 
    position = position_dodge(width = 0.5)
  ) +
  scale_y_continuous(labels = percent, limits = c(0, 1)) +
  scale_x_discrete(expand = c(0, 1), label = NULL) +
  scale_fill_manual(values = colour_aes_for_grouped_species) +
  # guides(fill = guide_legend(title = "Dégâts de faune", ncol = 2)) +
  labs(x = "Dégâts de faune", y = "") +
  MyTheme
} else {
  cat("Aucun dégât de faune n'a été relevé sur les perches inventoriées")
}

@
\FloatBarrier

<<wildlife_damage_bar_chart, fig.height=2, fig.cap= "Importance des dégâts de faune", results='asis', eval = F, include = F>>=

# -- plot table
table <- 
  Perches %>% 
  filter(NumForet == forest_num & Cycle == last_cycle & !is.na(Caract1)) %>%
  mutate(
    Caract1 = ifelse(Caract1 == "1", "oui", Caract1), 
    Caract1 = factor(Caract1, levels = c("oui", "non"))
    # Essence = factor(Essence, levels = grouped_majority_species)
  ) %>%
  group_by(EssReg, Caract1) %>%
  summarise(Nha = sum(Nha)) %>%
  ungroup() %>%
  mutate(share = Nha / sum(Nha, na.rm = T), variable = "dégâts faune")


if (nrow(table) > 0) {
  cat("L'histogramme de la figure \\ref{fig:wildlife_damage_bar_chart} représente la part de la densité des perches de l'inventaire endommagées par la faune (frottis).\\\\")
  
# -- plot settings
# Y_max
Y_max = max(table$share, na.rm = T)
# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plot
ggplot(table) +
  geom_bar(
    mapping = aes(x = variable, y = share, fill = EssReg), 
    stat = "identity", position = 'dodge', colour = "black", width = 0.5) +
  geom_text(
    mapping = aes(
      x = variable, y = share, group = EssReg, 
      label = paste0(round(share * 100, 0), " %")
    ), 
    vjust = -1, size = 2.5, 
    position = position_dodge(width = 0.5)
  ) +
  scale_y_continuous(labels = percent, limits = c(0, 1)) +
  scale_x_discrete(expand = c(0, 1), label = NULL) +
  scale_fill_manual(values = colour_aes_for_grouped_species) +
  # guides(fill = guide_legend(title = "Dégâts de faune", ncol = 2)) +
  labs(x = "Dégâts de faune", y = "") +
  MyTheme
} else {
  cat("Aucun dégât de faune n'a été relevé sur les perches inventoriées")
}

@
\FloatBarrier


\subsubsection{\Sexpr{i18n()$t("Taillis")}}
\EditIf{\Sexpr{Eval_Taillis}}{TRUE}{

\Sexpr{i18n()$t("Le tableau")} \ref{coppice_species_distribution_table} \Sexpr{i18n()$t("présente le nombre de tiges et la surface terrière du taillis par essence.")}

<<coppice_species_distribution_table, results = 'asis', fig.pos = "H", eval = Eval_Taillis, include = Eval_Taillis>>=
# -- order coppice species
coppice_species_order <-
  gfForetTaillis_EssReg %>%
  # translation
  mutate(Essence = i18n()$t(EssReg)) %>%
  filter(Cycle == last_cycle & NumForet == forest_num & Nha > 0) %>%
  arrange(-Nha) %>%
  select(Essence) %>%
  distinct() %>%
  unlist() %>%
  unname()

# -- coppice : stat var table
coppice_results_variability <-
  gfForetTaillis_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(ends_with("Nha"), ends_with("Gha")) %>%
  # select(ends_with("Nha"), ends_with("Gha"), ends_with("Vha")) %>%
  pivot_longer(
    cols = everything(),
    names_to = "variable",
    values_to = "value"
  ) %>%
  # arrondis des valeurs
  mutate(
    value = case_when(
      variable == "Nha" ~ round(value, 0),
      variable == "Gha" & value < 0.1 ~ round(value, 2),
      # variable %in% c("Gha", "Vha") & value < 0.1 ~ 2,
      variable == "Gha" & value >= 0.1 ~ round(value, 1),
      # variable %in% c("Gha", "Vha") & value >= 0.1 ~ 1,

      str_detect(variable, "CV") ~ round(value, 0),
      str_detect(variable, "Er") ~ round(value, 1)
    ),

    # mean label (for separate)
    variable = ifelse(
      !str_detect(variable, "CV") & !str_detect(variable, "Er"),
      paste0("Moy_", variable),
      variable
    )
  ) %>%
  separate(variable, c("stat", "variable"), sep = "_") %>%
  # variables moy, er, cv en colonnes
  pivot_wider(
    names_from = "stat",
    values_from = "value"
  ) %>%
  mutate(
    # build IC
    IC = paste0(
      "\\emph{[", round(Moy - Er * Moy / 100, 1),
      "-", round(Moy + Er * Moy / 100, 1), "]}"
    ),
    # remove mean column
    Moy = NULL,

    variable = gsub("ha", "", variable),
    variable = gsub("per", "", variable),
    variable = gsub("Ha", "", variable),

    # translation
    variable = i18n()$t(variable),

    variable = paste0("\\cellcolor{LightGray} ", variable)
  ) %>%
  # pivot : variables N et G en colonnes
  pivot_longer(
    cols = -c("variable"),
    names_to = "stat",
    values_to = "value",
    values_transform = list(
      value = as.character
    )
  ) %>%
  pivot_wider(
    id_cols = c("stat"),
    names_from = "variable",
    values_from = "value"
  ) %>%

  # format table
  mutate(
    stat = case_when(
      # stat == "Moy" ~ paste0("\\textbf{", i18n()$t("Coefficient de variation (\\%)"), "}"),
      stat == "CV" ~ i18n()$t("Coefficient de variation (\\%)"),
      stat == "Er" ~ i18n()$t("Erreur relative (\\%)"),
      stat == "IC" ~ i18n()$t("\\emph{Intervalle de confiance}")
    )


    # column 'N' -> no need
    # empty = NA
  ) %>%
  # set_multirow_table(1) %>% # TODO : remplacer les numéros de colonne par les noms de colonne

  # rename
  rename(
    # "\\cellcolor{LightGray} Année" = "Annee",
    "\\cellcolor{LightGray} " = "stat"#,
    #   " " = "empty"
  )

# -- coppice results table
var = c("Nha", "Gha")
attribute = "Essence"
attribute_name = paste0("\\textbf{", i18n()$t("Essences"), "}")
table <-
  gfForetTaillis_EssReg %>%
  mutate(
    # translation
    Essence = i18n()$t(EssReg),
    Essence = factor(Essence, levels = coppice_species_order)
  )

coppice_results_by_species <- set_up_main_results_by_attribute_table(
  table = table,
  var = var,
  attribute = attribute,
  # attribute_name = attribute_name,
  forest_num = forest_num,
  last_cycle = last_cycle,
  precision_needed = F
)

# -- print table
coppice_results_by_species$print_table <-
  coppice_results_by_species$print_table %>%

  # rename
  rename(
    !!attribute_name := "attribute",
    !!paste0("\\textbf{", i18n()$t("N"), "\\hspace{2cm}\\scriptsize{", i18n()$t("(tiges/ha)"), "}}") := "Nha",
    !!paste0("\\textbf{", i18n()$t("G"), "\\hspace{2cm}\\scriptsize{", i18n()$t("(m2/ha)"), "}}") := "Gha"
  )

# -- print table settings
digits_param = rep(0, dim(coppice_results_by_species$print_table)[2] + 1)

# -- print tables
# 1st table
cat("\\begin{table}[h]\n\\centering")
print(
  xtable(
    coppice_results_by_species$print_table,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(coppice_results_by_species$print_table)[2]-1)),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  hline.after = -1:dim(coppice_results_by_species$print_table)[1],
  floating = F,
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)

# space
cat("\n\\vspace{0.1cm}\n")

# 2nd table
print(
  xtable(
    coppice_results_variability,
    caption = NULL,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(coppice_results_variability)[2]-1)),
    label = NULL),
  include.rownames = FALSE,
  include.colnames = FALSE,
  sanitize.text.function = function(x){return(x)},
  hline.after = -1:dim(coppice_results_variability)[1],
  floating = F,
  size = "\\footnotesize"
)
cat(paste0("\\caption{", i18n()$t("Nombre de tiges et surface terrière du taillis, déclinés par essence"), "}\n\\label{coppice_species_distribution_table}\n\\end{table}"))
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:coppice_var_boxplot} \Sexpr{i18n()$t("illustre la variabilité, entre les placettes, du nombre de tiges et de la surface terrière du taillis.")}

<<coppice_var_boxplot, fig.pos = 'H', size = 'footnotesize', fig.height = 2, fig.width = 3, fig.cap = i18n()$t("Variabilité des principales caractéristiques dendrométriques pour le taillis"), eval = Eval_Taillis, include = Eval_Taillis>>=
# -- table
boxplot_table <-
  gfPlaTaillis_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(-NumPlac) %>%
  pivot_longer(
    cols = -c("NumForet", "Cycle"),
    names_to = "variable",
    values_to = "value"
  )

# -- plots
# densité de tiges
p1 <- build_box_plot(table = boxplot_table, var = "Nha", y_axis_name = i18n()$t("(tiges/ha)"))
# surface terrière
p2 <- build_box_plot(table = boxplot_table, var = "Gha", y_axis_name = i18n()$t("(m2/ha)"))

# -- arrange grid
grid.arrange(p1, p2, widths = c(1, 1))
@
\FloatBarrier

\Sexpr{i18n()$t("La figure")} \ref{fig:coppice_species_distribution_pie_chart} \Sexpr{i18n()$t("présente la part de chaque essence en nombre de tiges et surface terrière.")}

<<coppice_species_distribution_pie_chart, size = 'footnotesize', fig.height = 3, fig.cap = i18n()$t("Importance relative des différentes essences pour le taillis"), fig.pos = "H", eval = Eval_Taillis, include = Eval_Taillis>>=
# -- table
pie_chart_table <-
  coppice_results_by_species$plot_table %>%
  filter(variable != "Gainper") %>%
  mutate(
    variable = gsub(coll("ha"), "", variable),
    variable = gsub(coll("Ha"), "", variable),
    variable = gsub(coll("per"), "", variable),

    # translation
   variable = i18n()$t(variable),

    # order
    Essence = factor(attribute, levels = rev(coppice_species_order)),
    variable = factor(
      variable,
      levels = c(i18n()$t("N"), i18n()$t("G"))
    ),

    # define label settings
    label_y = 0.5, # position
    label_str = variable # label string
  ) %>%
  arrange(variable, Essence)

# # -- theme sizes
# theme_sizes <- list(
#   title = 7,
#   text = 6,
#   axis_title_x = 9,
#   axis_text_x = 7,
#   legend_text = 7
# )
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)

# -- plot
build_pie_chart(
  table = pie_chart_table,
  # var = NULL,
  x = "variable",
  y = "value",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_grouped_species,
  fill_scale_name = i18n()$t("Essences :"),
  y_axis_name = i18n()$t("Part relative des essences"),
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier
}{
\Sexpr{i18n()$t("Aucun élément de taillis inventorié sur ce dispositif en")} \Sexpr{last_year}.
}
\FloatBarrier

% \EditIf{\Sexpr{eval_evol}}{TRUE}{
\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{
\subsubsection{\Sexpr{i18n()$t("Evolution du sous-étage")}}

\Sexpr{i18n()$t("Le tableau")} \ref{evolution_perches_taillis} \Sexpr{i18n()$t("retrace l'évolution des principales composantes dendrométriques des perches et du taillis au cours des différents inventaires.")}

<<evolution_perches_taillis, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=


##### Perches #####
if (nrow( Perches[which(Perches$NumForet == forest_num), ] ) > 0) {
  # -- table : total by year
  totals_by_year <-
    gfForetPer_ %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Cycle, Gha) %>%

  # security if year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(NumForet, Cycle, fill = list(Gha = 0)) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join year
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  arrange(Annee, -Gha) %>%
  mutate(
    Gha = round(Gha, ifelse(Gha < 0.1, 2, 1)),
    # print expr
    Gha = paste0("\\cellcolor{LightGray} \\textbf{", Gha, "}"),
    Essence = "\\cellcolor{LightGray} \\textbf{G Total}",
    # create empty column population
    Population = NA
  ) %>%
  select(Population, Annee, Essence, Gha) %>%
  pivot_wider(
    id_cols = c("Population", "Essence"),
    names_from = "Annee",
    values_from = "Gha"
  )

  # -- table : total by year and qual2
  totals_by_year_and_qual2 <-
  gfForetPer_Reg2 %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Reg2, Cycle, Gha) %>%

  # security if species/year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(
    NumForet, Cycle, Reg2,
    fill = list(Gha = 0)
  ) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join year
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  arrange(Annee, -Gha) %>%
  group_by(Annee) %>%
  mutate(Gha_tot = sum(Gha)) %>%
  group_by(Annee, Reg2) %>%
  mutate(
    Gha_part = ifelse(Gha_tot > 0, round(Gha / Gha_tot * 100), 0)
  ) %>%
  ungroup() %>%
  mutate(
    Gha = round(Gha, ifelse(Gha < 0.1, 2, 1)),
    Gha = ifelse(Gha_part > 0, Gha, ""),
    # print expr
    Gha = ifelse(
      Gha != "",
      paste0(
        Gha, " \\scriptsize{\\textcolor{CornflowerBlue}{(", Gha_part, "\\%)}}"
      ),
      Gha
    ),
    # create empty column population
    Population = NA,
    Reg2 = factor(Reg2, levels = c("A+B", "C+D"))
  ) %>%
  select(Population, Annee, Reg2, Gha) %>%
    arrange(Reg2) %>%
    rename(Essence = Reg2) %>%
  pivot_wider(
    id_cols = c("Population", "Essence"),
    names_from = "Annee",
    values_from = "Gha"
  )

  # -- table : total by year and species
totals_by_year_and_species <-
  gfForetPer_EssReg %>%
  # translation
  mutate(Essence = i18n()$t(EssReg)) %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Essence, Cycle, Gha) %>%

  # security if species/year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(
    NumForet, Cycle, Essence,
    fill = list(Gha = 0)
  ) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join year
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  arrange(Annee, -Gha) %>%
  group_by(Annee) %>%
  mutate(Gha_tot = sum(Gha)) %>%
  group_by(Annee, Essence) %>%
  mutate(
    Gha_part = ifelse(Gha_tot > 0, round(Gha / Gha_tot * 100), 0)
  ) %>%
  ungroup() %>%
  mutate(
    Gha = round(Gha, ifelse(Gha < 0.1, 2, 1)),
    Gha = ifelse(Gha_part > 0, Gha, ""),
    # print expr
    Gha = ifelse(
      Gha != "",
      paste0(
        Gha, " \\scriptsize{\\textcolor{CornflowerBlue}{(", Gha_part, "\\%)}}"
      ),
      Gha
    ),
    # create empty column population
    Population = NA
  ) %>%
  select(Population, Annee, Essence, Gha) %>%
  pivot_wider(
    id_cols = c("Population", "Essence"),
    names_from = "Annee",
    values_from = "Gha"
  )

# -- stack tables
stems_table <- rbind(
  totals_by_year_and_qual2,
  totals_by_year_and_species,
  totals_by_year
) %>%
  mutate(
    Essence = gsub("A+B", "G (A+B)", Essence),
    Essence = gsub("C+D", "G (C+D)", Essence)
  ) %>%
  rename(!!i18n()$t("Essence") := "Essence")

# -- renaming
# column 'Population'
pos_NAME <- which(names(stems_table) != "Population")
names(stems_table)[which(names(stems_table) == "Population")] <-
  paste0(
    "\\multirow{",
    nrow(stems_table) + 2,
    "}{*}{\\rotatebox{90}{", i18n()$t("Perches"), "}}"
  )
# others columns
names(stems_table)[pos_NAME] <-
  paste0("\\textbf{", names(stems_table)[pos_NAME], "}")

# -- commands
rows_list <- list()
for (i in 0:nrow(stems_table)) {
  rows_list[length(rows_list) + 1] <- i
}
commands_list = rep(
  paste0("\\cline{2-", dim(stems_table)[2], "}\n"),
  nrow(stems_table) + 1
)

# -- print table
cat("\\begin{table}[H]\n\\centering")
print(
  xtable(
    stems_table,
    digits = c(0, 0, rep(1, dim(stems_table)[2]-1)),
    align = c(
      "M{0cm}", "|M{.5cm}", "|M{1.5cm}|",
      rep("M{1cm}|", dim(stems_table)[2] - 2)
    ),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  floating = F,
  hline.after = c(-1, nrow(stems_table)),
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  size = "\\footnotesize",

  # adding commands
  add.to.row = list(
    pos = rows_list,
    command = commands_list
  )
)

} else {
  cat("\\begin{table}[H]\n\\centering")
}

##### Taillis #####
if (nrow( Taillis %>% filter(NumForet == forest_num) ) > 0) {
  # -- table : total by year
totals_by_year <-
  gfForetTaillis_ %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Cycle, Gha) %>%

  # security if year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(NumForet, Cycle, fill = list(Gha = 0)) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join year
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  arrange(Annee, -Gha) %>%
  mutate(
    Gha = round(Gha, ifelse(Gha < 0.1, 2, 1)),
    # print expr
    Gha = paste0("\\cellcolor{LightGray} \\textbf{", Gha, "}"),
    Essence = "\\cellcolor{LightGray} \\textbf{G Total}",
    # create empty column population
    Population = NA
  ) %>%
  select(Population, Annee, Essence, Gha) %>%
  pivot_wider(
    id_cols = c("Population", "Essence"),
    names_from = "Annee",
    values_from = "Gha"
  )

# -- table : total by year and species
totals_by_year_and_species <-
  gfForetTaillis_EssReg %>%
  # translation
  mutate(Essence = i18n()$t(EssReg)) %>%
  filter(NumForet == forest_num) %>%
  select(NumForet, Essence, Cycle, Gha) %>%

  # security if species/year(s) missing
  mutate(Cycle = factor(Cycle, levels = 1:last_cycle)) %>%
  complete(
    NumForet, Cycle, Essence,
    fill = list(Gha = 0)
  ) %>%
  mutate(Cycle = as.numeric(Cycle)) %>%

  # join year
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  arrange(Annee, -Gha) %>%
  group_by(Annee) %>%
  mutate(Gha_tot = sum(Gha)) %>%
  group_by(Annee, Essence) %>%
  mutate(
    Gha_part = ifelse(Gha_tot > 0, round(Gha / Gha_tot * 100), 0)
  ) %>%
  ungroup() %>%
  mutate(
    Gha = round(Gha, ifelse(Gha < 0.1, 2, 1)),
    Gha = ifelse(Gha_part > 0, Gha, ""),
    # print expr
    Gha = ifelse(
      Gha != "",
      paste0(
        Gha, " \\scriptsize{\\textcolor{CornflowerBlue}{(", Gha_part, "\\%)}}"
      ),
      Gha
    ),
    # create empty column population
    Population = NA
  ) %>%
  select(Population, Annee, Essence, Gha) %>%
  pivot_wider(
    id_cols = c("Population", "Essence"),
    names_from = "Annee",
    values_from = "Gha"
  )

# -- stack tables
coppice_table <- rbind(
  totals_by_year_and_species,
  totals_by_year
) %>%
  rename(!!i18n()$t("Essence") := "Essence")

# -- renaming
# column 'Population'
pos_NAME <- which(names(coppice_table) != "Population")
names(coppice_table)[which(names(coppice_table) == "Population")] <-
  paste0(
    "\\multirow{",
    nrow(coppice_table) + 2,
    "}{*}{\\rotatebox{90}{", i18n()$t("Taillis"), "}}"
  )
# others columns
names(coppice_table)[pos_NAME] <-
  paste0("\\textbf{", names(coppice_table)[pos_NAME], "}")

# -- commands
rows_list <- list()
for (i in 0:nrow(coppice_table)) {
  rows_list[length(rows_list) + 1] <- i
}
commands_list = rep(
  paste0("\\cline{2-", dim(coppice_table)[2], "}\n"),
  nrow(coppice_table) + 1
)

# -- print table
cat("\\hspace{0.5cm}\n")
print(
  xtable(
    coppice_table,
    digits = c(0, 0, rep(1, dim(coppice_table)[2]-1)),
    align = c(
      "M{0cm}", "|M{.5cm}", "|M{1.5cm}|",
      rep("M{1cm}|", dim(coppice_table)[2] - 2)
    ),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  floating = F,
  hline.after = c(-1, nrow(coppice_table)),
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  size = "\\footnotesize",

  # adding commands
  add.to.row = list(
    pos = rows_list,
    command = commands_list
  )
)
}

cat(paste0(
  "\\caption{", i18n()$t("Evolution du sous-étage"),
  "}\\\n\\label{evolution_perches_taillis}\n\\end{table}"
))
@

\subsection{\Sexpr{i18n()$t("Passage à la futaie")}}
\Sexpr{i18n()$t("Le tableau")} \ref{Tab_PF} \Sexpr{i18n()$t("présente le nombre de tiges passées à la futaie au cours de la dernière période.")}
\FloatBarrier
<<Tab_PF, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=

# -- periods_table
periods_table <- tibble(
  NumForet = forest_num,
  initial_cycles = c(1:(last_cycle - 1), 1),
  Cycle = c(2:last_cycle, last_cycle)
) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet" = "NumForet", "initial_cycles" = "Cycle")
  ) %>%
  left_join(
    Cycles[, c("NumForet", "Cycle", "Annee")],
    by = c("NumForet", "Cycle")
  ) %>%
  mutate(
    period = paste0(Annee.x, " - ", Annee.y),
    Cycle = ifelse(Cycle == last_cycle & initial_cycles == 1, Inf, Cycle),
    time_span = Annee.y - Annee.x
  ) %>%
  select(NumForet, Cycle, period, time_span)
if (nrow(periods_table) == 2) {
  periods_table$Cycle <- c(2, Inf)
}

##### fonction pour obtenir le tableau de passage à la futaie (par période et selon 1 attribut) #####
get_promoted_stems_table <- function(
  table = NULL,
  forest_num = NULL,
  last_cycle = NULL,
  attribute = NULL,
  attribute_order = NULL,
  attribute_name = NULL
) {
  # table <- gfForetFpied_EssenceCatCoupe # debug
  # attribute = "Essence"
  # attribute_order = main_species_order

  # -- security check
  if (is.null(attribute)) stop("Attribut non défini")

  # -- build table of promoted stems by attribute and cycle
  table <-
    table %>%
    # select disp, cycle & PB
    filter(NumForet == forest_num & Cycle > 1 & Cat == "PB") %>%

    # define attribute column
    rename("attribute" = attribute) %>%

    mutate(
      # change Coupe col
      Coupe = gsub("/E", "", Coupe),
      Coupe = gsub("E", "", Coupe),
      Coupe = ifelse(Coupe == "", NA, Coupe),

      # translation
      attribute = i18n()$t(attribute),

      # factor (to sort and complete table)
      attribute = factor(attribute, levels = attribute_order)
    ) %>%

    # sort
    arrange(Cycle, attribute) %>%

    # filter PF
    filter(Coupe == "PF") %>%

    # complete missing values (security ?)
    complete(attribute, Cycle, fill = list(Coupe = "PF"))

  # -- build table of promoted stems by attribute and period
  promoted_stems_by_attribute_and_period <-
    table %>%

    # sum Nha (= PF)
    group_by(Cycle, attribute, Coupe) %>%
    summarise(Nha = sum(Nha, na.rm = T)) %>%
    ungroup() %>%

    # join periods table
    left_join(periods_table, by = "Cycle") %>%

    # calculate PF by year
    mutate(
      Nha = Nha / time_span,
      Nha = ifelse(Nha == 0, NA, round(Nha, 1))
    ) %>%
    select(attribute, period, Nha)

  # cas où plusieurs cycles (au moins 3 - possibilité de distinguer les cycles et le total)
  if (last_cycle > 2) {
    # -- total table - build table of promoted stems by attribute (for whole period)
    promoted_stems_by_attribute <-
      table %>%
      # set Cycle to whole period
      mutate(Cycle = Inf) %>%

      # sum Nha (= PF)
      group_by(Cycle, attribute, Coupe) %>%
      summarise(Nha = sum(Nha, na.rm = T)) %>%
      ungroup() %>%

      # join periods table
      left_join(periods_table, by = "Cycle") %>%

      # calculate PF by year
      mutate(
        Nha = Nha / time_span,
        Nha = ifelse(
          Nha == 0,
          "\\cellcolor{LightGray}",
          paste0("\\cellcolor{LightGray} \\textbf{", round(Nha, 1), "}")
        )
      ) %>%
      select(attribute, period, Nha)

    promoted_stems_by_attribute <- rbind(
      promoted_stems_by_attribute_and_period,
      promoted_stems_by_attribute
    )
  } else promoted_stems_by_attribute <- promoted_stems_by_attribute_and_period

  # -- total table - build table of promoted stems by period (without attribute)
  promoted_stems_by_period <-
    table %>%

    # sum Nha (= PF)
    group_by(Cycle, Coupe) %>%
    summarise(Nha = sum(Nha, na.rm = T)) %>%
    ungroup() %>%

    # join periods table
    left_join(periods_table, by = "Cycle") %>%

    # calculate PF by year
    mutate(
      Nha = Nha / time_span,
      Nha = ifelse(Nha == 0, NA, round(Nha, 1)),
      Nha = paste0("\\textbf{", Nha, "}"),

      # set attribute to total
      attribute = "\\rowcolor{LightGray} \\textbf{Total}"
    ) %>%
    select(attribute, period, Nha)

  # cas où plusieurs cycles (au moins 3 - possibilité de distinguer les cycles et le total)
  if (last_cycle > 2) {
    # -- total table - PF through all species through all periods
    promoted_stems <-
      table %>%
      # set Cycle to whole period
      mutate(Cycle = Inf) %>%

      # sum Nha (= PF)
      group_by(Cycle, Coupe) %>%
      summarise(Nha = sum(Nha, na.rm = T)) %>%
      ungroup() %>%

      # join periods table
      left_join(periods_table, by = "Cycle") %>%

      # calculate PF by year
      mutate(
        Nha = Nha / time_span,
        Nha = ifelse(Nha == 0, NA, round(Nha, 1)),
        # Nha = paste0("\\cellcolor{LightGray} \\textbf{", Nha, "}"),

        # set attribute to total
        attribute = "\\rowcolor{LightGray} \\textbf{Total}"
      ) %>%
      select(attribute, period, Nha)

    promoted_stems_total <- rbind(
      promoted_stems_by_period,
      promoted_stems
    )
  } else promoted_stems_total <- promoted_stems_by_period

  # -- stack tables
  final_table <- rbind(
    promoted_stems_by_attribute,
    promoted_stems_total
  ) %>%
    pivot_wider(
      id_cols = "attribute",
      values_from = "Nha",
      names_from = "period"
    ) %>%
    rename(!!attribute_name := "attribute")

  # -- format
  # title font
  names(final_table) <- paste0("\\textbf{", names(final_table), "}")
  # last cell font
  final_table[nrow(final_table), ncol(final_table)] <- paste0(
    "\\cellcolor{DimGray}{\\textcolor{White}{\\textbf{",
    final_table[nrow(final_table), ncol(final_table)], "}}}"
  )

  # -- return from 'get_promoted_stems_table' function
  return(final_table)
}


# -- build tables
  promoted_stems_by_species <- get_promoted_stems_table(
  table = gfForetFpied_EssRegCatCoupe %>% rename(Essence = EssReg),
  forest_num = forest_num,
  last_cycle = last_cycle,
  attribute = "Essence",
  attribute_order = standing_trees_grouped_species_order,
  attribute_name = i18n()$t("Essence")
)

  promoted_stems_by_qual <- get_promoted_stems_table(
  table = gfForetFpied_CatReg2Coupe,
  forest_num = forest_num,
  last_cycle = last_cycle,
  attribute = "Reg2",
  attribute_order = c("A+B", "C+D"),
  attribute_name = i18n()$t("Qualité")
)

  # -- print table
cat("\\begin{table}[h]\n\\centering\n")
print(
  xtable(
    promoted_stems_by_species,
    digits = c(0, rep(0, dim(promoted_stems_by_species)[2])),
    align = c(
      "M{0cm}", "|M{2.5cm}|",
      rep("M{1.5cm}|", dim(promoted_stems_by_species)[2] - 1)
    ),
    label = NULL
  ),
  floating = F,
  hline.after = -1:dim(promoted_stems_by_species)[1],
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)
cat("\\hspace{0.5cm}\n~")
print(
  xtable(
    promoted_stems_by_qual,
    digits = c(0, rep(0, dim(promoted_stems_by_qual)[2])),
    align = c(
      "M{0cm}", "|M{1.5cm}|",
      rep("M{1.5cm}|", dim(promoted_stems_by_qual)[2] - 1)
    ),
    label = NULL
  ),
  floating = F,
  hline.after = -1:dim(promoted_stems_by_qual)[1],
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)
cat(paste0(
  "\\caption{",
  i18n()$t("Nombre de tiges passant à la futaie (en nombre/ha/an) au cours des différentes périodes -  disctinction par essence et par qualité"),
  "}\n\\label{Tab_PF}\n\\end{table}"
))
@
\FloatBarrier


\section{\Sexpr{i18n()$t("Accroissements")}}

\subsection{\Sexpr{i18n()$t("Evolution des accroissements")}}
\Sexpr{i18n()$t("Les tableaux ci-dessous (tableau")} \ref{Tab_Taux}) \Sexpr{i18n()$t(") présentent les différents taux d'accroissements en surface terrière, volume et valeur de consommation, déclinés par essence et par catégorie de diamètre.")}

<<Tab_Taux, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=

##### fonction pour obtenir les prélèvements #####
get_aligned_wood_flows_table <- function(
  table = NULL,
  var = NULL,
  group = NULL
) {
  # var <- c("Gha", "VcHa")
  # print(...)
  groups <- c("Coupe", group)
  # enquo_group <- enquos(...)
  #   print(enquo_group)
  #   # enquos_group <-  # autre possibilité : vars(), as_label pour repasser string
  #   #   if (!is.null(group)) {
  #   #     enquos(Coupe, group)
  #   #   } else {
  #   #     enquos(Coupe)
  #   #   }
  # # enquos_var <- enquos(...)
  # quos_var <- quos(!!parse_exprs(var))
  # # table <- gfForetFpied_EssenceCoupe
  #
  #   x_groups <-  # autre possibilité : vars(), as_label pour repasser string
  #     if (!is.null(group)) {
  #       parse_exprs(c("Coupe", group))
  #     } else {
  #       parse_exprs("Coupe")
  #     }
  #
  #   quo_groups <-  quos(!!parse_exprs(c("Coupe")))# autre possibilité : vars(), as_label pour repasser string
  #     if (!is.null(group)) {
  #       quos(!!parse_exprs(c("Coupe", group)))
  #     } else {
  #       quos(!!parse_exprs(c("Coupe")))
  #     }
  #
  #   group <- c("Coupe")

  # commande utile :
  # rlang::qq_show(!!quo(x))

  # harvested_wood <- # df_E
  harvested_wood <-
    table %>%
    filter(NumForet == forest_num & Cycle < last_cycle) %>%
    mutate(
      # format 'Coupe'
      Coupe = gsub("PF/", "", Coupe),
      Coupe = gsub("PF", "", Coupe),
      Coupe = ifelse(Coupe == "", NA, Coupe),

      # set Cycle = 1
      Cycle = 1,

      # sécurités au cas où prélèvement(s) serai(en)t manquants
      Coupe = factor(Coupe, levels = c("C", "E"))
    ) %>%
    complete(NumForet, !!!syms(groups), fill = list(Cycle = 1)) %>%

    # suppression des valeurs Coupe vides
    filter(!is.na(Coupe)) %>%

    # calcul totals
    select(NumForet, Cycle, groups, var) %>% # var
    pivot_longer(
      cols = var,
      names_to = "variable",
      values_to = "value"
    ) %>%
    group_by(NumForet, Cycle, !!!syms(groups), variable) %>%
    summarise(value = sum(value, na.rm = T)) %>%
    ungroup() %>%
    pivot_wider(
      id_cols = c("NumForet", "variable", group),
      names_from = "Coupe",
      values_from = "value"
    )

  groups <- group
  standing_wood <-
    table %>%
    filter(NumForet == forest_num & is.element(Cycle, c(1, last_cycle))) %>%

    # set Cycle
    mutate(Cycle = ifelse(Cycle == 1, "initial_value", "final_value")) %>%

    # complete missing values
    complete(NumForet, !!!syms(groups), fill = list(Cycle = 1)) %>%

    # calcul totals
    select(NumForet, Cycle, group, var) %>%
    pivot_longer(
      cols = var,
      names_to = "variable",
      values_to = "value"
    ) %>%
    group_by(NumForet, Cycle, !!!syms(groups), variable) %>%
    summarise(value = sum(value, na.rm = T)) %>%
    ungroup() %>%
    pivot_wider(
      id_cols = c("NumForet", "variable", groups),
      names_from = "Cycle",
      values_from = "value"
    )

  # -- joining tables
  table <- left_join(
    standing_wood, harvested_wood,
    by = c("NumForet", "variable")
  ) %>%
    # calcul acct
    mutate(
      acct = final_value - initial_value + (E + C), # value_Tot
      harvested_wood_share = E / acct, # Part_value_Tot_E
      fallen_wood_share = C / acct # Part_value_Tot_C
    )

  # -- return of get_aligned_wood_flows_table function
  return(table)
}

##### function to set up rates table to print (déclinés pour 1 attribut) #####
set_up_rates_results_by_attribute_table <- function(
  table = NULL,
  var = NULL,
  var_acct = NULL,
  attribute = NULL,
  attribute_order = NULL,
  periods_table = NULL,
  forest_num = NULL,
  selected_cycles = NULL,
  prepare_tables = T
) {

  # -- default value -> var to select
  if (is.null(var)) {
    var <- c("Gha", "Vha", "VcHa")
  }
  if (is.null(var_acct)) {
    var_acct <- c("AcctGper", "AcctVper", "Gainper")
  }

  # sécurité
  if (is.null(attribute)) stop("Attribut non défini")

  # -- tables
  if (attribute == "Cat") {
    # fusion des catégories "GB" et "TGB" si valeurs d'acrroissement négatives
    # increment values for very large wood
    inc_values_for_vlw <-
      table %>%
      filter(NumForet == forest_num & Cycle %in% selected_cycles & Cat == "TGB") %>%
      select(AcctVper, AcctGper, Gainper)

    # sécurité
    if (nrow(inc_values_for_vlw) > 0) {
      negative_acct_values <- which(inc_values_for_vlw < 0)
      if (length(negative_acct_values) > 0) {
        table <-
          table %>%
          mutate(Cat = ifelse(Cat %in% c("GB", "TGB"), "GB et TGB", Cat))
        attribute_order <- i18n()$t(c("PB", "BM", "GB et TGB"))
      }
    }
  }

  # -- préparer les tables si variables (cycle n-1) et acct (cycle n) non alignés
  if (prepare_tables == T) { # cond 'prepare_tables == T'
    id_cols <- c("NumForet", "Cycle")
    # rajouter attribute à id_cols si attribute != "period"
    if (attribute != "period") id_cols <- c(id_cols, attribute)

    # table contenant les valeurs des variables non dynamiques (hors acct)
    initial_values_table <-
      table %>%

      # décalage des valeurs de cycle (correspondance entre les valeurs d'accroissement de l'année n et les résultats d'inventaire de l'année n-1)
      mutate(Cycle = Cycle + 1) %>%

      # filter
      filter(Cycle %in% selected_cycles & NumForet == forest_num & Gha > 0) %>%
      select(all_of(c(id_cols, var)))

    # table contenant les valeurs d'accroissement
    acct_values_table <-
      table %>%

      # filter
      filter(Cycle %in% selected_cycles & NumForet == forest_num & Gha > 0) %>%
      select(all_of(c(id_cols, var_acct)))

    # main table
    table <-
      # use full_join to join (cas où essences apparaîtraient au nouvel inventaire)
      full_join(initial_values_table, acct_values_table, by = id_cols)
  } # end of cond 'prepare_tables == T'

  # -- join periods if attribute = "period"
  if (
    attribute == "period" &
    (length(periods_table)[1] > 0 | !is.null(periods_table))
  ) {
    # joining
    table <- table %>% left_join(periods_table, by = c("NumForet", "Cycle")) %>% 
      select(-time_span)
  }

  # -- calcul rates
  table <-
    table %>%

    # remove Cycle column
    select(-NumForet, -Cycle) %>%

    # define attribute column
    rename("attribute" = attribute) %>%

    # pivot
    pivot_longer(
      cols = -"attribute"
    ) %>%

    # format
    mutate(
      # ATTENTION : dans outil PermAFI, correction apportée par VD 28/05/2021 (traitement 44) : il ne faut pas supprimer les valeurs négatives car elles ont une réalité (qualité TGB passant de A- à B par exemple). De toute façon, on utilisera à partir de maintenant le gain "instantané". Ce cas de figure ne devrait alors plus se représenter.
      # value = ifelse(value < 0, 0, value),
      # --> à voir si pertinent dans PermGF
      value = ifelse(value < 0, 0, value),
      variable = case_when(
        name %in% c("Gha", "AcctGper") ~ "G",
        name %in% c("Vha", "AcctVper") ~ "V",
        name %in% c("VcHa", "Gainper") ~ "Vc"
      ),

      name = case_when(
        name %in% c("Gha", "Vha", "VcHa") ~ "value_fix",
        name %in% c("AcctGper", "AcctVper", "Gainper") ~ "value_acct"
      )
    ) %>%

    # security in case acct TGB < 0
    group_by(attribute, name, variable) %>%
    summarise(value = sum(value, na.rm = T)) %>%
    ungroup() %>%

    # pivot
    pivot_wider(
      id_cols = c("attribute", "variable")
    ) %>%

    mutate(
      # calculate Taux
      rate = round(value_acct / value_fix * 100, 1),
      rate = formatC(rate, format = "f", digits = 1),
      rate = case_when(
        value_fix > 0 & value_acct > 0 & rate > 0 ~ paste0(rate, " \\%"),
        value_fix > 0 & value_acct > 0 & rate == 0 ~ "$\\sim$0 \\%"
      ),

      # remove value_fix
      value_fix = NULL
    ) %>%

    # calcul totaux
    group_by(variable) %>%
    mutate(total = sum(value_acct, na.rm = T)) %>%
    ungroup() %>%

    # get share and label
    mutate(
      # digits
      digits = case_when(
        variable == "G" ~ 2,
        variable == "V" ~ 1,
        variable == "Vc" ~ 0
      ),

      # share
      share = round(value_acct / total * 100, digits = 0),
      # label
      label = round(value_acct, digits = digits)
    )


  # format share or not
  if (attribute != "period") {
    table <- table %>%
      mutate(
        share = case_when(
          value_acct > 0 & share > 0 ~
            paste0(" \\scriptsize{\\textcolor{CornflowerBlue}{(", share, "\\%)}}"),
          value_acct > 0 & share == 0 ~
            " \\scriptsize{\\textcolor{CornflowerBlue}{($\\sim$0 \\%)}}"
        ),
        share = ifelse(attribute == "period", "", share)
      )
  } else table <- table %>% mutate(share = "")

  # table - continue
  table <- table %>%
    mutate(
      label = case_when(
        value_acct > 0 & label > 0 ~ paste0(label, share),
        value_acct > 0 & label == 0 ~ paste0("$\\sim$0", share)
      ),

      # remove total, digits, share, value_acct
      total = NULL,
      digits = NULL,
      value_acct = NULL,
      share = NULL,

      # sort attribute & translation
      attribute = i18n()$t(attribute),
      attribute = factor(attribute, levels = attribute_order)
    ) %>%
    arrange(attribute) %>%

    # pivot
    pivot_wider(
      # id_cols = -c("label", "rate"),
      names_from = "variable",
      values_from = c("label", "rate")
    ) %>%

    # remove factor
    mutate(attribute = as.character(attribute)) %>%
    select(attribute, label_G, rate_G, label_V, rate_V, label_Vc, rate_Vc)

  # -- return from set_up_rates_results_by_attribute_table function
  return(table)
}


var <- c("Gha", "Vha", "VcHa")
var_acct <- c("AcctGper", "AcctVper", "Gainper")
selected_cycles <- last_cycle

# -- taux d'accroissement par essence
table <- gfForetFpied_EssReg %>% rename(Essence = EssReg)
attribute <- "Essence"
attribute_order = grouped_species_order

df1 <- set_up_rates_results_by_attribute_table(
  table = table,
  var = var,
  var_acct = var_acct,
  attribute = attribute,
  attribute_order = attribute_order,
  periods_table = periods_table,
  forest_num = forest_num,
  selected_cycles = selected_cycles,
  prepare_tables = T
)

# -- taux par catégorie de diamètre
table = gfForetFpied_Cat
attribute = "Cat"
attribute_order = i18n()$t(c("PB", "BM", "GB", "TGB"))
df2 <- set_up_rates_results_by_attribute_table(
  table = table,
  var = var,
  var_acct = var_acct,
  attribute = attribute,
  attribute_order = attribute_order,
  periods_table = NULL,
  forest_num = forest_num,
  selected_cycles = selected_cycles,
  prepare_tables = T
)

# -- taux par qualité 2
table = gfForetFpied_Reg2
attribute = "Reg2"
attribute_order = i18n()$t(c("A+B", "C+D"))
df3 <- set_up_rates_results_by_attribute_table(
  table = table,
  var = var,
  var_acct = var_acct,
  attribute = attribute,
  attribute_order = attribute_order,
  periods_table = NULL,
  forest_num = forest_num,
  selected_cycles = selected_cycles,
  prepare_tables = T
)

# -- taux par périodes
table = gfForetFpied_
attribute = "period"
attribute_order = unique(periods_table$period) # évite factor duplicated si que 2 passages (et donc doublons de périodes dans la table period_table)
selected_cycles <- c(2:last_cycle)
df4 <- set_up_rates_results_by_attribute_table(
  table = table,
  var = var,
  var_acct = var_acct,
  attribute = attribute,
  attribute_order = attribute_order,
  periods_table = periods_table,
  forest_num = forest_num,
  selected_cycles = selected_cycles,
  prepare_tables = T
)

# -- taux sur l'ensemble de la période (uniquement si Cycle > 3)
# TODO : incohérence des chiffres si changement du nombre de placettes entre les cycles (ex : si 2 cycles et nombre de placettes a changé, alors valeurs de df5 (accroissement recalculé sur la période totale) et valeurs de df4 ne correspondent pas)
if (last_cycle > 2) {
selected_cycles <- NULL
df5 <-
  gfForetFpied_Coupe %>%
  get_aligned_wood_flows_table(
    var = c("Gha", "Vha", "VcHa"),
    group = NULL
  ) %>%
  mutate(Cycle = Inf) %>%

  # rapport au temps écoulé
  left_join(periods_table, by = c("NumForet", "Cycle")) %>%
  mutate(acct = acct / time_span) %>%

  select(NumForet, Cycle, variable, initial_value, acct) %>%
  # NumForet et Cycle ?
  pivot_wider(
    id_cols = c("NumForet", "Cycle"),
    names_from = "variable",
    values_from = c("initial_value", "acct")
  ) %>%
  rename(
    Gha = initial_value_Gha,
    Vha = initial_value_Vha,
    VcHa = initial_value_VcHa,
    AcctGper = acct_Gha,
    AcctVper = acct_Vha,
    Gainper = acct_VcHa
  ) %>%
  set_up_rates_results_by_attribute_table(
    var = var,
    var_acct = var_acct,
    attribute = attribute,
    attribute_order = attribute_order,
    periods_table = periods_table,
    forest_num = forest_num,
    selected_cycles = selected_cycles,
    prepare_tables = F
  )
}


# -- format tableau
# repères des lignes
pos1 <- nrow(df1)
pos2 <- nrow(df2)
pos3 <- nrow(df3)


if (last_cycle > 2) {
# rajout couleur cycle actuel
pos4 <- nrow(df4)
df4[pos4, ] <- lapply(df4[pos4, ], FUN = function(x) paste0("\\textbf{", x, "}"))
df4[pos4, 1] <- paste0("\\rowcolor{LightGray} ", df4[pos4, 1])

# rajout couleur période total
pos5 <- nrow(df5)
df5[pos5, ] <- lapply(df5[pos5, ], FUN = function(x) paste0("\\textbf{\\textcolor{white}{", x, "}}"))
df5[pos5, 1] <- paste0("\\rowcolor{DimGray} ", df5[pos5, 1])

# stack tables
df <- rbind(df1, df2, df3, df4, df5)

# hline.after rows
hline_rows <- c(
  -1:nrow(df),
  pos1,
  pos1 + pos2,
  pos1 + pos2 + pos3,
  pos1 + pos2 + pos3 + pos4
)

} else {
  # rajout couleur période total
pos4 <- nrow(df4)
df4[pos4, ] <- lapply(df4[pos4, ], FUN = function(x) paste0("\\textbf{\\textcolor{white}{", x, "}}"))
df4[pos4, 1] <- paste0("\\rowcolor{DimGray} ", df4[pos4, 1])

# stack tables
df <- rbind(df1, df2, df3, df4)

# hline.after rows
hline_rows <- c(
  -1:nrow(df),
  pos1,
  pos1 + pos2,
  pos1 + pos2 + pos3
)

}

# stack tables
df <-
  df %>%
  rename(
    "\\textbf{}" = "attribute",
    !!paste0("\\textbf{", i18n()$t("Taux G"), "}") := "rate_G",
    !!paste0("\\textbf{", i18n()$t("Taux V"), "}") := "rate_V",
    !!paste0("\\textbf{", i18n()$t("Taux Vc"), "}") := "rate_Vc",

    !!paste0("\\textbf{", i18n()$t("AcctG"), "}") := "label_G",
    !!paste0("\\textbf{", i18n()$t("AcctV"), "}") := "label_V",
    !!paste0("\\textbf{", i18n()$t("Gain"), "}") := "label_Vc"
  )

# -- print table
print(
  xtable(
    df,
    digits = rep(1, ncol(df) + 1),
    align = c("M{0cm}|", "|M{2cm}|", rep("M{1.5cm}|", ncol(df) - 1)),
    caption.placement = "bottom",
    caption = i18n()$t("Taux d'accroissements par essence, par catégorie de diamètre, par qualité, et par périodes d'inventaire\\\\\\footnotesize{Taux G : taux d'accroissement par rapport à la surface terrière\\\\Taux V : taux d'accroissement par rapport au volume\\\\Taux Vc : taux d'accroissement par rapport à la valeur de consommation}"),
    label = "Tab_Taux"
  ),
  floating = T,
  hline.after = hline_rows,
  sanitize.text.function = function(x) return(x),
  include.rownames = FALSE,
  size = "\\footnotesize"
)

@

\FloatBarrier

\subsection{\Sexpr{i18n()$t("Accroissements en diamètre")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:Fig_AccD_Essence} \Sexpr{i18n()$t("présente les accroissements en diamètre des différentes essences.")}

<<Fig_AccD_Essence, fig.height = 4, fig.cap = i18n()$t("Valeurs d'accroissements en diamètre par essence, selon les classes et catégories de diamètre"), fig.pos = 'H', eval = eval_evol, include = eval_evol>>=
df <- Arbres %>%
  filter(NumForet == forest_num & Cycle == last_cycle & Diam >= 17.5)

df_AcctD1 <- left_join(
  df[, c(
    "NumForet", "NumPlac", "NumArbre",
    "Essence", "EssReg", "Azimut", "Dist", "Cycle",
    "Diam1", "Diam2", "Diam", "Classe"
  )],
  AcctD,
  by = c("NumForet", "NumPlac", "NumArbre", "Essence", "Cycle", "Classe")
) %>%
  select(
    NumForet, NumPlac, NumArbre, Cycle,
    Essence, EssReg, Azimut, Dist, Diam, Classe, Acct_Diam
  ) %>%
  filter(Cycle == last_cycle) %>%

  # translation
  mutate(
    Essence = as.character(EssReg),
    Essence = i18n()$t(Essence),
    Essence = factor(Essence, levels = standing_trees_grouped_species_order)
    ) %>%

  arrange(Essence) %>% 
  mutate(Population = "Bois vivant\nde franc-pied")

df_AcctD <-
  df_AcctD1 %>%
  mutate(
    Cat = cut(
      Diam,
      breaks = c(0, 17.5, 27.5, 47.5, 67.5, 200),
      labels = c("PER", "PB", "BM", "GB", "TGB"),
      include.lowest = T, right = F
    ),
    
    # translation
    Cat = as.character(Cat),
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%

  arrange(Cat)

df_AcctD_Bis <-
  df_AcctD %>%
  filter(Essence %in% grouped_majority_species) %>% # morgan - add 'grouped_'
  group_by(Cat, Population, Essence) %>%
  summarise(
    Moy_AcctD = mean(Acct_Diam, na.rm = T),
    Sd_AcctD = sd(Acct_Diam, na.rm = T),
    Mark = factor(0.5)
  ) %>%
  ungroup() %>%
  select(Mark, Population, Essence, Cat, Moy_AcctD, Sd_AcctD) %>%
  # distinct() %>%
  arrange(Cat, Essence)


# -- table pour sortir la moyenne par classe des accroissements courants des précomptables
df_AcctD1_Tot <-
  df_AcctD1 %>%
  group_by(Classe) %>%
  summarise(AcctD = mean(Acct_Diam, na.rm = T)) %>%
  ungroup() %>%
  mutate(Population = "AcctD_Prec")

# -- p_ghost est une figure "fantôme" : elle n'apparaîtra pas dans le rendu final mais elle permet de récupérer la légende correspondant au tracé de la moyenne des AcctD par classe (toutes essences confondues) + dans la figure finale, d'espacer de façon régulière les 3 morceaux de légende (moyenne des AcctD courant (toutes essences confondues), AcctD courants des essences, moyenne des AcctD des catégories de diamètre)
p_ghost <-
  ggplot() +
  geom_path(
    df_AcctD1_Tot,
    mapping = aes(Classe, AcctD, size = Population)
  ) +
  scale_size_manual(
    name = i18n()$t("Moyenne des AcctD\ncourants des précomptables"),
    values = 0.5
  ) +
  guides(
    size = guide_legend(
      nrow = ifelse(
        length(unique(df_AcctD$Essence)) > 5,
        round(length(unique(df_AcctD$Essence))/4, 0),
        1)
    )
  ) +
  MyTheme +
  theme(
    legend.title = element_text(size = 8),
    legend.text = element_text(size = 7),
    legend.position = "bottom",
    legend.direction = "vertical",
    legend.box = "horizontal",
    legend.box.just = "top",
    legend.spacing.y = unit(0, "cm"),
    # legend.background = element_rect(colour = "gray50",
    #                                 size = 0.2),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )

Y = max(df_AcctD$Acct_Diam, na.rm = T)

p1 <-
  ggplot() +
  geom_point(
    df_AcctD,
    mapping = aes(Diam, Acct_Diam, colour = Essence),
    alpha = 1,
    shape = 1
  ) +
  # geom_path(
  #   df_AcctD1_Tot,
  #   mapping = aes(Classe, AcctD, size = Population)
  # ) +

  stat_smooth(
    df_AcctD1_Tot,
    mapping = aes(x = Classe, y = AcctD, group = Population, size = Population),
    geom = "smooth",
    size = 0.5,
    fill = "gray",
    alpha = 0.3
  ) +
  scale_x_continuous(
    name = i18n()$t("Classes de diamètre"),
    limits = c(17.5, max(df_AcctD$Classe, na.rm = T)),
    breaks = seq(10, floor(max(df_AcctD$Classe, na.rm = T)/10 + 0.5) * 10, 10)
  ) +
  scale_y_continuous(
    name = i18n()$t("AcctD (cm/an)"),
    # expand = c(0, 0),
    limits = c(0, Y),
    breaks = seq(0, Y * 1.1, 0.25)
  ) +
  scale_colour_manual(name = i18n()$t("AcctD courants"), values = colour_aes_for_grouped_species) +
  scale_size_manual(
    name = i18n()$t("Moyenne des AcctD\r\ncourants des précomptables"),
    values = 0.5,
    label = "AcctD"
  ) +
  guides(
    colour = guide_legend(
      nrow = ifelse(
        length(unique(df_AcctD$Essence)) > 4,
        ceiling(length(unique(df_AcctD$Essence))/4),
        1
      ),
      byrow = T,
      order = 2
    ),
    size = guide_legend(order = 1)
  ) +
  MyTheme +
  theme(
    legend.title = element_text(size = 8),
    legend.text = element_text(size = 7),
    legend.position = "bottom",
    legend.direction = "vertical",
    legend.box = "horizontal",
    legend.box.just = "top",
    legend.spacing.y = unit(0, "cm"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )


df_AcctD_Ter <-
  df_AcctD_Bis %>% mutate(Sd_AcctD = case_when(Essence %in% grouped_majority_species ~ Sd_AcctD)) # morgan - add 'grouped_'

p2 <-
  ggplot() +
  geom_errorbar(
    df_AcctD_Ter,
    mapping = aes(
      Cat,
      ymin = Moy_AcctD - Sd_AcctD,
      ymax = Moy_AcctD + Sd_AcctD,
      colour = Essence, group = Essence
    ),
    width = 0.4,
    position = position_dodge(0.5)
  ) +
  geom_point(
    df_AcctD_Bis,
    mapping = aes(Cat, Moy_AcctD, colour = Essence, group = Essence),
    position = position_dodge(0.5)
  ) +
  scale_x_discrete(name = i18n()$t("Catégories de diamètre")) +
  scale_y_continuous(
    name = i18n()$t("AcctD (cm/an)"),
    limits = c(0, Y),
    breaks = seq(0, Y * 1.1, 0.25)
  ) +
  scale_colour_manual(
    name = i18n()$t("Moyenne par essence\r\ndes AcctD courants"),
    values = colour_aes_for_grouped_species # morgan
  ) +
  guides(
    colour = guide_legend(
      nrow = ifelse(
        length(unique(df_AcctD_Bis$Essence)) > 3,
        ceiling( length(unique(df_AcctD_Bis$Essence)) / 3 ),
        1
      ),
      byrow = T,
      order = 2
    ),
    size = guide_legend(order = 1)
  ) +
  MyTheme +
  theme(
    legend.title = element_text(size = 8),
    legend.text = element_text(size = 7),
    legend.position = "bottom",
    legend.direction = "vertical",
    legend.box = "vertical",
    legend.box.just = "top",
    legend.spacing.y = unit(0, "cm"),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )

mylegend0 <- g_legend(p_ghost)
mylegend1 <- g_legend(p1)
mylegend2 <- g_legend(p2)

pA <- arrangeGrob(
  p1 + theme(legend.position = "none"),
  p2 + theme(legend.position = "none"),
  nrow = 1, widths = rep(1, 2)
)
pB <- arrangeGrob(
  mylegend1,
  mylegend2,
  nrow = 1, widths = c(1, 1)
)

grid.arrange(
  pA, pB,
  nrow = 2, heights = c(4, 3)
)
@
\FloatBarrier

\Sexpr{i18n()$t("La partie gauche de la figure")} \ref{fig:Fig_AccD_Essence} \Sexpr{i18n()$t("représente la variabilité des accroissements sur le diamètre des arbres ainsi que la moyenne des accroissements courants en diamètre par classe de diamètre.")}\\
\Sexpr{i18n()$t("Dans la partie droite, sont représentés les moyennes des accroissements courants en diamètre des principales essences (essences représentant au moins ")}\Sexpr{threshold_ba * 100}\Sexpr{i18n()$t("\\% du G total des précomptables), avec leur intervalle de confiance.")}\\

<<acct_line_plot_set_up, eval = eval_evol, include = eval_evol>>=
##### fonction pour construire les graphiques linéaire des accroissements #####
build_acct_line_plot_by_Cat <- function(
  table = NULL, y_var = NULL,
  colour_aes = NULL, alpha_aes = NULL,
  plot_title = NULL,
  y_axis_name = NULL,
  # -- plot settings
  Y_max = max(table[, y_var], na.rm = T),
  Y_min =  ifelse( 
    min(table[, y_var], na.rm = T) < 0, min(table[, y_var], na.rm = T), 0 
  ),
  increment_value = NULL
) {
  
  # -- plot
  ggplot() +
    # lines
    geom_line(
      table,
      mapping = aes_string(
        x = "Cat", y = y_var,
        colour = "period",
        group = "period",
        alpha = "period"
      )
    ) +
    # add period labels (on 1st and last 'Cat')
    geom_label_repel(
      table %>% filter(Cat %in% first(Cat) | Cat %in% last(Cat)),
      mapping = aes_string(x = "Cat", y = y_var, label = "period"),
      label.padding = unit(0.15, "lines"),
      size = 1.7,
      colour = "black"
    ) +
    # setting scales
    scale_y_continuous(
      name = y_axis_name,
      breaks = if (!is.null(increment_value)) seq(0, Y_max * 1.3, increment_value) else waiver(),
      limits = c(Y_min, Y_max * 1.1)
    ) +
    scale_colour_manual(
      name = i18n()$t("Périodes d'inventaire"),
      values = colour_aes
    ) +
    scale_alpha_manual(
      name = i18n()$t("Périodes d'inventaire"),
      values = alpha_aes
    ) +
    guides(
      # colour guide
      colour = guide_legend(
        nrow = ifelse(last_cycle > 1, ceiling(last_cycle / 2), 1),
        byrow = T,
        order = 1
      ),
      # alpha guide
      alpha = guide_legend(
        nrow = ifelse(
          last_cycle > 1,
          ceiling(last_cycle / 2), 1
        ),
        byrow = T,
        order = 1
      )
    ) +
    # axis title
    labs(x = i18n()$t("Catégories de diamètre"), title = plot_title) +
    # themes
    theme_bw() +
    theme(
      text = element_text(size = 7),
      title = element_text(size = 8),
      
      strip.background = element_blank(),
      strip.text = element_text(face = "bold"),
      
      legend.spacing.y = unit(0, "cm"),
      legend.position = "bottom",
      legend.direction = "horizontal",
      legend.box = "vertical",
      legend.box.just = "bottom",
      
      plot.title = element_text(hjust = 0.5),
      plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
    )
}

##### acct Diam table (to join with acct_table) #####
# 1/ all species part 1 - Essence + Cat
acctD_table <-
  Arbres %>%
  filter(NumForet == forest_num & Diam >= 17.5 & Cycle != 1) %>%
  left_join(
    AcctD,
    by = c("IdArbre", "NumForet", "NumPlac", "NumArbre", "Essence", "Cycle", "Classe")
  ) %>%
  filter(!is.na(Acct_Diam)) %>%
  mutate(
    Cat = cut(
      Classe,
      breaks = c(0, 17.5, 27.5, 47.5, 67.5, 200),
      labels = c("PER", "PB", "BM", "GB", "TGB"),
      include.lowest = T,
      right = F
    ),
    Cat = as.character(Cat)
  ) %>%
  select(NumForet, Cycle, Cat, Essence, Acct_Diam) %>%

  # translation
  mutate(
    Essence = i18n()$t(Essence),
    Cat = i18n()$t(Cat)
  ) %>%

  # get periods
  right_join(periods_table, by = c("NumForet", "Cycle"))

# 2/ main species only - Cat
main_species_acctD_table <-
  acctD_table %>%
  filter(Essence == main_species) %>%
  # calcul means
  group_by(Cycle, period, Cat) %>%
  summarise(
    acctD_mean = mean(Acct_Diam, na.rm = T)
  ) %>%
  ungroup() %>%

  # format
  mutate(
    period = factor(period),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%
  arrange(period, Cat)

# 3/ all species part 2 - Cat
acctD_table <-
  acctD_table %>%
  # calcul means
  group_by(Cycle, period, Cat) %>%
  summarise(
    acctD_mean = mean(Acct_Diam, na.rm = T)
  ) %>%
  ungroup() %>%

  # format
  mutate(
    period = factor(period),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%
  arrange(period, Cat)

##### acct table for all - Cat #####
acct_table <-
  gfForetFpied_Cat %>%
  select(NumForet, Cycle, Cat, AcctGper, Gainper) %>%
  # get periods
  right_join(
    periods_table %>% filter(Cycle != Inf), # pas besoin de Inf ici
    by = c("NumForet", "Cycle")
  ) %>%

  # format
  mutate(
    period = factor(period),

    # translation
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%

  # join acctD_table
  left_join(acctD_table, by = c("Cycle", "Cat", "period")) %>%
  arrange(period, Cat)

# -- acct table for main species only - Essence + Cat
main_species_acct_table <-
  gfForetFpied_EssenceCat %>%

  # translation
  mutate(
    Essence = i18n()$t(Essence),
    Cat = i18n()$t(Cat)
  ) %>%

  filter(Essence == main_species) %>%
  select(NumForet, Cycle, Cat, AcctGper, Gainper) %>%
  # get periods
  right_join(
    periods_table %>% filter(Cycle != Inf), # pas besoin de Inf ici
    by = c("NumForet", "Cycle")
  ) %>%

  # calcul means
  group_by(Cycle, period, Cat) %>%
  summarise(
    acctG_mean = mean(AcctGper, na.rm = T),
    gain_mean = mean(Gainper, na.rm = T)
  ) %>%
  ungroup() %>%

  # format
  mutate(
    period = factor(period),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%

  # join acctD_table
  left_join(main_species_acctD_table, by = c("Cycle", "Cat", "period")) %>%
  arrange(period, Cat)

##### aesthetics #####
# -- all species
# alpha & colour values
if (last_cycle == 2) {
  colour_aes <- "dodgerblue3"
  alpha_aes <- 1
} else { # cond last_cycle > 2
  colour_aes <- c("dodgerblue3", rep("dodgerblue3", last_cycle - 3), "firebrick3")
  alpha_aes <- c(1, rep(0.3, last_cycle - 3), 1)
} # end of cond last_cycle == 2

# palette names
names(colour_aes) <- with(periods_table %>% filter(Cycle!= Inf), period)
names(alpha_aes) <- names(colour_aes)

# -- main species only
# alpha & colour values
main_species_colour <- colour_aes_for_grouped_species[
  match(grouped_species_order[1], names(colour_aes_for_grouped_species))
  ]
if (last_cycle == 2) {
  main_species_colour_aes <- main_species_colour
  main_species_alpha_aes <- 1
} else { # cond last_cycle > 2
  main_species_colour_aes <- rep(main_species_colour, last_cycle - 1)
  main_species_alpha_aes <- c(1, rep(0.3, last_cycle - 3), 1)
} # end of cond last_cycle == 2

# palette names
names(main_species_colour_aes) <- with(periods_table %>% filter(Cycle!= Inf), period)
names(main_species_alpha_aes) <- names(main_species_colour_aes)

@

\Sexpr{i18n()$t("La figure")} \ref{fig:acctD_line_plot} \Sexpr{i18n()$t("présente l'évolution au cours du temps des accroissements courants en diamètre par catégorie de diamètre.")}% (perches et précomptables inclus).

<<acctD_line_plot, fig.height = 3.5, fig.cap = i18n()$t("Suivi au cours du temps des moyennes des accroissements en diamètre courants par catégorie de diamètre"), fig.pos = 'H', eval = eval_evol, include = eval_evol>>=

# -- plot settings
# Y_max
Y_max = max( c(
  unlist(acct_table[, "acctD_mean"]),
  unlist(main_species_acct_table[, "acctD_mean"])
), na.rm = T)
# increment scale (y)
increment_value <- find_increment_value(Y_max)

# -- plots
# AcctD plot - all species
p1 <- build_acct_line_plot_by_Cat(
  table = acct_table,
  y_var = "acctD_mean",
  colour_aes = colour_aes,
  alpha_aes = alpha_aes,
  plot_title = i18n()$t("Toutes essences"),
  y_axis_name = i18n()$t("Moyenne des acctD courants\r\n(cm/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

# -- AcctD plot - main species only
p2 <- build_acct_line_plot_by_Cat(
  table = main_species_acct_table,
  y_var = "acctD_mean",
  colour_aes = main_species_colour_aes,
  alpha_aes = main_species_alpha_aes,
  plot_title = paste0(i18n()$t("Essence principale"), " : ", main_species),
  y_axis_name = i18n()$t("Moyenne des acctD courants\r\n(cm/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

mylegend1 <- g_legend(p1)
grid.arrange(p1, p2, nrow = 1)
@
\FloatBarrier

\subsection{\Sexpr{i18n()$t("Accroissements en surface terrière")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:acctG_line_plot} \Sexpr{i18n()$t("illustre l'évolution de l'accroissement en surface terrière. Dans la partie gauche sont représentés les accroissements constatés à l'échelle de l'ensemble du dispositif, toutes essences confondues. Dans la partie droite est présenté le détail pour l'essence majoritaire (au regard de la surface terrière).")}

<<acctG_line_plot, fig.height = 3.5, fig.cap = i18n()$t("Suivi au cours du temps des moyennes des accroissements courants en surface terrière par catégorie de bois"), fig.pos = 'H', eval = eval_evol, include = eval_evol>>=

# -- plot settings
# Y_max
Y_max = max( c(
  unlist(acct_table[, "AcctGper"]),
  unlist(main_species_acct_table[, "acctG_mean"])
), na.rm = T)
# increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plots
# AcctG plots - all species
p1 <- build_acct_line_plot_by_Cat(
  table = acct_table,
  y_var = "AcctGper",
  colour_aes = colour_aes,
  alpha_aes = alpha_aes,
  plot_title = i18n()$t("Toutes essences"),
  y_axis_name = i18n()$t("Moyenne des acctG courants\r\n(m2/ha/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

# AcctG plot - main species only
p2 <- build_acct_line_plot_by_Cat(
  table = main_species_acct_table,
  y_var = "acctG_mean",
  colour_aes = main_species_colour_aes,
  alpha_aes = main_species_alpha_aes,
  plot_title = paste0(i18n()$t("Essence principale"), " : ", main_species),
  y_axis_name = i18n()$t("Moyenne des acctG courants\r\n(m2/ha/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

mylegend1 <- g_legend(p1)
grid.arrange(p1, p2, nrow = 1)
@
\FloatBarrier

\subsection{\Sexpr{i18n()$t("Accroissements en valeur")}}

\Sexpr{i18n()$t("La figure")} \ref{fig:gain_line_plot} \Sexpr{i18n()$t("illustre l'évolution de l'accroissement en valeur. Dans la partie gauche sont représentés les accroissements constatés à l'échelle de l'ensemble du dispositif, toutes essences confondues. Dans la partie droite, est présenté le détail pour l'essence majoritaire (au regard de la surface terrière).")}

<<gain_line_plot, fig.height = 3.5, fig.cap = i18n()$t("Suivi au cours du temps des moyennes des accroissements courants en valeur (gain) par catégorie de bois"), fig.pos = 'H', eval = eval_evol, include = eval_evol, dev = "cairo_pdf">>=

# -- plot settings
# Y_max
Y_max = max( c(
  unlist(acct_table[, "Gainper"]),
  unlist(main_species_acct_table[, "gain_mean"])
), na.rm = T)
# increment scale (y)
  increment_value <- find_increment_value(Y_max)

# -- plots
# Gain plots - all species
p1 <- build_acct_line_plot_by_Cat(
  table = acct_table,
  y_var = "Gainper",
  colour_aes = colour_aes,
  alpha_aes = alpha_aes,
  plot_title = i18n()$t("Toutes essences"),
  y_axis_name = i18n()$t("Moyenne des gains courants\r\n(€/ha/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

# Gain plot - main species only
p2 <- build_acct_line_plot_by_Cat(
  table = main_species_acct_table,
  y_var = "gain_mean",
  colour_aes = main_species_colour_aes,
  alpha_aes = main_species_alpha_aes,
  plot_title = paste0(i18n()$t("Essence principale"), " : ", main_species),
  y_axis_name = i18n()$t("Moyenne des gains courants\r\n(€/ha/an)"),
  Y_max = Y_max,
  increment_value = increment_value
)

mylegend1 <- g_legend(p1)
grid.arrange(p1, p2, nrow = 1)
@
\FloatBarrier


\section{\Sexpr{i18n()$t("Gestion passée")}}

\subsection{\Sexpr{i18n()$t("Prélèvements")}}

\Sexpr{i18n()$t("Le tableau")} \ref{harvests_table} \Sexpr{i18n()$t("présente les différents prélèvements effectués sur chaque période.")}

<<harvests_table, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=

##### fonction pour obtenir les taux de prélèvements par groupes #####
get_harvested_shares_table <- function(
  table = NULL,
  group = NULL,
  cycles = last_cycle - 1,
  var = NULL,
  add_total_by_group = F,
  show_share = T,

  font_share = " \\scriptsize{\\textcolor{CornflowerBlue}{(_arg_\\%)}}",
  font_total = "\\textbf{\\textcolor{white}{_arg_}}",

  digits_table = NULL
) {
# table <- gfForetFpied_EssenceCoupe # debug
# group <- "Essence" # debug
# var = c("Gha", "Vha", "VcHa") # debug

# groups
# groups <- c("NumForet", "Cycle", "Coupe", group)
# groups_without_Coupe <- c("NumForet", "Cycle", group)

  # -- split fonts
  # TODO : mettre une sécurité si pas possible d'avoir 2 éléments
  if (!is.null(font_share)) font_share <- str_split(font_share, "_arg_", simplify = T)
    if (!is.null(font_total)) font_total <- str_split(font_total, "_arg_", simplify = T)

# -- harvested table
table <-
  table %>%
  filter(NumForet == forest_num & Cycle %in% cycles) %>%

  # remove NumForet
  select(-NumForet) %>%

  mutate(
    # format 'Coupe'
    Coupe = gsub("PF/", "", Coupe),
    Coupe = gsub("PF", "", Coupe),
    Coupe = ifelse(is.na(Coupe), "", Coupe),

    # sécurités au cas où prélèvement(s) serai(en)t manquants
    Coupe = factor(Coupe, levels = c("E", "C", ""))
  ) %>%
  complete(!!!syms(c("Cycle", "Coupe", group))) %>%

  # pivot
  select(!!!syms(c("Cycle", "Coupe", group)), var) %>%
  pivot_longer(
    cols = var,
    names_to = "variable",
    values_to = "value"
  ) %>%

  # sum (useless ?)
  group_by(!!!syms(c("Cycle", "Coupe", group)), variable) %>%
  summarise(value = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # format
  mutate(variable = factor(variable, levels = var))

# -- total by group
total_by_group <-
  table %>%
  group_by(!!!syms(c("Cycle", group)), variable) %>%
  summarise(total = sum(value, na.rm = T)) %>%
  ungroup()

# -- total share of lost wood (harvested + fallen) by group
total_lost_wood_by_group <-
  table %>%

  # filter only E/C elements
  filter(is.element(Coupe, c("E", "C"))) %>%

  # somme des coupes + chablis
  group_by(!!!syms(c("Cycle", group)), variable) %>%
  summarise(total_lost_wood = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # join total
  left_join(
    total_by_group,
    by = c("Cycle", group, "variable")
    ) %>%

  # calcul part de '(C+E)/total'
  mutate(
    share = round(total_lost_wood / total * 100),

    # label ...
    label = NA,
    label = case_when(
    # ... pour la table total
      is.null(group) ~ paste0(font_total[1], share, font_total[2]),
    # ... pour les autres
      !is.null(group) ~ paste0(share, " \\%")
      ),
    # vide si valeur nulle
    label = case_when(total_lost_wood > 0 ~ label)#,
    # label = if_else(total_lost_wood > 0, label, ""), # another way
  ) %>%

  # remove total & share
  select(-total, -share)

# add total by group ? -> pour le tableau 'harvests_table'
if (add_total_by_group) {
  total_lost_wood_by_group <-
    total_lost_wood_by_group %>%

    # format
    left_join(digits_table, by = c("variable" = "var")) %>%
    mutate(
      # si VcHa/Vha/PU -> 0 digits. cf digits table
      total_lost_wood = round(total_lost_wood, digits),

      # set variable & total_lost_wood to character to pivot
      # label = as.character(label),
      total_lost_wood = as.character(total_lost_wood)
    ) %>%

    # rename label & total_lost_wood
    rename(share = label, total = total_lost_wood) %>%

    # pivot
    pivot_longer(
      cols = c("share", "total"),
      names_to = "Coupe",
      values_to = "label"
    ) %>%
    select(Cycle, group, Coupe, variable, label)
} else {
  total_lost_wood_by_group <-
    total_lost_wood_by_group %>%
    mutate(Coupe = "share") %>%
    select(Cycle, group, Coupe, variable, label)
}

# -- main table
table <-
  table %>%
  # filtre -> éléments C/E uniquement
  filter(is.element(Coupe, c("E", "C"))) %>%

  # calcul des parts des différents membres du groupe
  group_by(Cycle, Coupe, variable) %>%
  mutate(share = round(value / sum(value) * 100)) %>%
  ungroup() %>%

  # format
  left_join(digits_table, by = c("variable" = "var")) %>%
  mutate(value = round(value, digits),
    # precision needed or not
    # digits = case_when(
    #     variable == "Gha" & precision_needed == F ~ digits,
    #     variable == "Gha" & value < 0.1 & precision_needed == T ~ 2,
    # )

    # label ...
    label = NA,
    label = case_when(
      # ... pour la table total
      is.null(group) ~ paste0(font_total[1], value, font_total[2]),
      # ... pour les autres
      !is.null(group) & show_share == T ~
        paste0(value, font_share[1], share, font_share[2]),
      !is.null(group) & show_share == F ~ as.character(value)
    ),
    # replace 0 by NA
    label = case_when(value > 0 ~ label)
  ) %>%
  select(Cycle, Coupe, group, variable, label) %>%

  # stack totals
  rbind(total_lost_wood_by_group)

# cond if group is NULL
table <-
  if (!is.null(group)) {
    table %>% rename("group" = group)
  } else {
    table %>%
      mutate(group = paste0(font_total[1], "Total", font_total[2]))
  }

  # sort
  table <-
    table %>%
    arrange(group, variable, Coupe) %>%
    select(Cycle, Coupe, group, variable, label)

# -- return from 'get_harvested_shares_table'
return(table)
}

# -- variables to use
var <- c("Gha", "Vha", "VcHa", "PU")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 0, 0, 0)
)

lost_wood_shared_by_cat <-
  gfForetFpied_CatCoupe %>%
  mutate(
    # translation
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) )),

    # calculate PU
    PU = VcHa / Vha
  ) %>%

  # get harvested values
  get_harvested_shares_table(
    group = "Cat",
    var = var,
    cycles = 1:(last_cycle - 1),
    show_share = F,
    font_share = NULL,
    font_total = NULL,
    digits_table = digits_table
  ) %>%
  filter(Coupe %in% c("E", "C"))

lost_wood <-
  gfForetFpied_Coupe %>%
  # calculate PU
  mutate(PU = VcHa / Vha) %>%

  # get harvested values
  get_harvested_shares_table(
    group = NULL,
    var = var,
    cycles = 1:(last_cycle - 1),
    add_total_by_group = T,
    show_share = F,
    font_share = NULL,
    font_total = NULL,
    digits_table = digits_table
  )

# -- final table
table <- rbind(
  lost_wood_shared_by_cat,
  lost_wood
) %>%

  # factor & arrange
  mutate(Coupe = factor(Coupe, levels = c("E", "C", "total", "share"))) %>%

  # sort
  arrange(Cycle, Coupe) %>%

  # pivot
  pivot_wider(
    id_cols = c("Cycle", "variable"),
    names_from = c("Coupe", "group"),
    values_from = "label"
  ) %>%

  # join periods
  mutate(Cycle = Cycle + 1) %>%
  left_join(periods_table[, c("Cycle", "period")], by = c("Cycle")) %>%
  select(period, everything(), -Cycle) %>%
  set_multirow_table(1) %>%

  # format total columns (LightGray)
  mutate(
    E_Total = ifelse(
      !is.na(E_Total),
      paste0("\\cellcolor{LightGray}{", E_Total, "}"),
      "\\cellcolor{LightGray}{}"
    ),

    C_Total = ifelse(
      !is.na(C_Total),
      paste0("\\cellcolor{LightGray}{", C_Total, "}"),
      "\\cellcolor{LightGray}"
    ),

    total_Total = ifelse(
      !is.na(total_Total) & total_Total != 0,
      paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{", total_Total, "}}"),
      "\\cellcolor{DimGray}"
    ),

    share_Total = case_when(
      variable != "PU" & !is.na(share_Total) ~
        paste0("\\multicolumn{1}{c|}{ \\scriptsize{", share_Total, " \\%}}"),
      variable != "PU" & is.na(share_Total) ~ "\\multicolumn{1}{c|}{}"
      # variable == "PU" ~ NA sous-entendu
    )
  ) %>%

  # rename
  rename(
    !!paste0("\\multirow{2}{*}{\\parbox{1.4cm}{\\centering \\textbf{", i18n()$t("Périodes"), "}}}") := "period",
    !!paste0("\\multirow{2}{*}{\\parbox{1cm}{\\centering \\textbf{", i18n()$t("Variable"), "}}}") := "variable",
    !!paste0("\\multirow{2}{*}{\\parbox{1.9cm}{\\centering \\textbf{", i18n()$t("Total des prélèvements"), "}}}") := "total_Total",
    !!paste0("\\multicolumn{1}{c|}{\\multirow{2}{*}{\\parbox{1.7cm}{\\centering \\textbf{", i18n()$t("Taux de prélèvement"), "}}}}") := "share_Total"
  )


# -- print set up
# 1.position changement Cycle.
pos_Cycle <- which(!is.na(table[,1]))[-1]

# nombre de lignes et colonnes dans 'table'
nrow <- nrow(table)
ncol <- ncol(table)

# command to add hhline -> hhline permet de mieux gérer les lignes de séparation des cellules du tableau (paramètre '-' : une simple ligne horizontale de la largeur de la colonne ou '|' : une ligne verticale qui coupe une ligne horizontale; entre autres)
command_to_add_hhline <- paste0(
  "\\hhline{|",  paste0(rep("-", ncol), collapse = "") , "|}\n"
)

# initialisation
if (last_cycle > 2) {
  ListPos <- as.list(pos_Cycle - 1)
  command <- rep(command_to_add_hhline, length(pos_Cycle))
} else {
  pos_Cycle <- nrow(table) + 1 # TODO : gérer pos_Cycle d'un bloc ?
  ListPos <- c()
  command <- c()
}

# %%%%%%%%%% %%%%%%%%%% #
# ----- 2.Construction entête :
# -- split names containing "E" or "C" on "_"
# security - check column names containing "E" or "C" (value = 3:ncol-2)
names_to_split_col <- c( grep("E_", names(table)), grep("C_", names(table)) )
# split names
splitted_names <-
  str_split(names(table)[ names_to_split_col ], pattern = "_", simplify = T)


# -- replace values
# replace "E" by "Exploité" & "C" by "Chablis" in splitted_names[,1]
splitted_names[, 1] <- gsub("E", i18n()$t("Exploité"), splitted_names[, 1])
splitted_names[, 1] <- gsub("C", i18n()$t("Chablis"), splitted_names[, 1])

# replace "Total" by "\\cellcolor{LightGray}{Total}" in splitted_names[,1]
splitted_names[, 2] <-
  gsub("Total", "\\\\cellcolor{LightGray}{Total}", splitted_names[, 2])


# -- define table_names (entête)
# add multicolumn (always 5 column)
splitted_names[, 1] <- paste0(
  "\\multicolumn{5}{c|}{\\textbf{", splitted_names[, 1], "}}"
)
# define table_names
table_names <- names(table)
# change table names
table_names[ names_to_split_col ] <- splitted_names[, 1]
# remove duplicated names (<=> multicolumns)
table_names <- table_names[ !duplicated(table_names) ]
# collapse table names
table_names <- paste0(table_names, collapse = " & ")
# add hhline
# N.B : arg '~' = une colonne sans ligne horizontale
table_names <- paste0(
  table_names,
  paste0(
    "\\\\ \n\\hhline{|~~|",
    # line only under multicolumns
    paste0(rep("-", ncol - 4), collapse = ""),
    "|~~|}\n"
  )
)

# -- define 1st row (under table_names)
# changement de names(table)
names(table) <- c("", "", splitted_names[, 2], "", "")
# add multicolumn to the last column -> rajout du trait vertical (hors lignes PU)
names(table)[ncol] <- paste0("\\multicolumn{1}{c|}{", names(table)[ncol], "}")

# %%%%%%%%%% %%%%%%%%%% #
# ----- 3.Commandes :
# -- rajout des hhline pour les lignes du tableau, excepté pour les lignes PU !
pos <- -1
ListPos <- c(ListPos, list(pos))
command=c(command, paste0("\\hline\n", table_names, "\n"))

row_to_add_hhline <- setdiff(1:(nrow - 1), pos_Cycle - 1)
ListPos <- c(ListPos, as.list(row_to_add_hhline))
command <- c(
  command, # initial value
  rep(
    # command to add hhline (+parameters)
    paste0("\\hhline{|~|", paste0(rep("-", ncol - 1), collapse = ""), "|}\n"),
    times = length(row_to_add_hhline
    )
  )
)

# last row
ListPos[length(ListPos) + 1] <- nrow
# add hhline to last line
command <- c(
  command,
  paste0("\\hhline{*{", ncol - 1, "}{-}}")
)

print(
  xtable(
    table,
    digits = rep(0, ncol(table) + 1),
    align = c(
      "M{0cm}|", "|M{1.4cm}", "|M{1cm}",
      rep("|M{0.5cm}", ncol(table) - 4), "|M{1.9cm}|", "M{1.7cm}"
    ),
    caption = i18n()$t("Prélèvements constatés au cours des différents inventaires"),
    label = "harvests_table"
  ),
  caption.placement = "bottom",
  hline.after = F,
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  add.to.row = list(
    pos = ListPos,
    command = command
  ),
  size = "\\footnotesize"
)
@
\FloatBarrier


<<TabCat_Prelvt_PlacAssiette, echo=F, warning=F, size='footnotesize', fig.height=4, fig.cap="Répartition du prélèvement en volume et en valeur par catégories de diamètre (placettes d'inventaire passées en coupe)", fig.pos="H", results='asis',eval=Eval_Geneve, include=Eval_Geneve>>=

# --- Détection des placettes passées en coupe :
Plac_COUPE <- filter(gfPlaFpied_Coupe,
                     NumForet==forest_num &
                       is.element(Coupe,c("E","PF/E","C"))) %>%
  select(NumPlac) %>%
  distinct() %>%
  unlist() %>%
  unname()

Prelvt_ALIBI0 <- expand.grid(Cycle=c(1:(last_cycle-1)),
                            Cat=c("Total"),
                            Coupe=c("C","E")) %>%
  data.frame() %>%
  mutate(Coupe=as.character(Coupe),
         Cat=as.character(Cat))

# --- Table Total (distinction sur Coupe)
t_Tot1 <- filter(gfForetGroupe2Den_Coupe,
            NumForet==forest_num &
              is.element(Coupe,c("E","PF/E","C")) &
              Groupe2=="Coupe") %>%
  # mutate(Cat="Total",
  #        Cycle=paste0("\\textbf{",Cycle,"}"),
  #        Coupe=paste0("\\textbf{",Coupe,"}"),
  #        Cat=paste0("\\textbf{",Cat,"}"),
  #        Gha=paste0("\\textbf{",Gha,"}"),
  #        VcHa=paste0("\\textbf{",VcHa,"}")) %>%
  mutate(Coupe=as.character(Coupe),
         Cat="Total") %>%
  full_join(Prelvt_ALIBI0) %>%
  select(Cycle,Cat,Coupe,Gha,Vha,VcHa)

# Prelvt_ALIBI <- data.frame(Cycle=rep(1:(last_cycle-1),12),
#                       Cat=sort(rep(c("PB","BM","GB","TGB"),(last_cycle-1)*3)),
#                       Coupe=sort(rep(c("C","E"),(last_cycle-1)*3)),
#                       stringsAsFactors=F)# %>%
Prelvt_ALIBI <- expand.grid(Cycle=c(1:(last_cycle-1)),
                            Cat=names(colour_aes_for_diameter_category)[-1],
                            Coupe=c("C","E")) %>%
  data.frame() %>%
  mutate(Coupe=as.character(Coupe),
         Cat=as.character(Cat))
  # mutate(Cat=factor(Cat,levels=c("PB","BM","GB","TGB"))) %>%
  # arrange(Cycle,Cat)

t0 <- filter(gfForetGroupe2Den_CatCoupe,
            NumForet==forest_num &
              is.element(Coupe,c("E","PF/E","C")) &
              Groupe2=="Coupe") %>%
  select(Cycle,Cat,Coupe,Gha,Vha,VcHa) %>%
  mutate(Coupe=as.character(Coupe)) %>%
  # mutate(Cycle=as.character(Cycle),
  #        Coupe=as.character(Coupe),
  #        Cat=as.character(Cat),
  #        Gha=as.character(Gha),
  #        VcHa=as.character(VcHa)) %>%
  full_join(t_Tot1) %>%
  full_join(Prelvt_ALIBI) %>%
  mutate(Coupe=gsub("PF/","",Coupe),
         # Cycle=paste0("Cycle",Cycle),
         Cat=factor(Cat,levels=c(names(colour_aes_for_diameter_category)[-1],"Total"))) %>%
  group_by(Cycle,Cat,Coupe) %>%
  summarise(VcHa=sum(VcHa,na.rm=T),
            Gha=sum(Gha,na.rm=T),
            Vha=sum(Vha,na.rm=T),
            PU=VcHa/Vha) %>%
  ungroup() %>%
  melt(id=c("Cycle","Cat","Coupe")) %>%
  mutate(value=ifelse(variable=="Gha",
                      round(value,1),
                      round(value,0)),
         value=ifelse(value==0 | is.na(value),
                      "",value),
         value=ifelse(Cat=="Total",
                      ifelse(value!=0 & !is.na(value),
                             paste0("\\cellcolor{LightGray}{",
                                               value,
                                               "}"),
                             "\\cellcolor{LightGray}{}"),
                      value),
         # value=ifelse(Cat=="Total",
         #              paste0("\\textbf{",value,"}"),
         #              value),
         variable=factor(variable,levels=c("Gha","Vha","VcHa","PU")),
         Coupe=ifelse(Coupe=="E","Exploité","Chablis"),
         Coupe=factor(Coupe,levels=c("Exploité","Chablis"))) %>%
  dcast(Cycle + variable ~ Coupe + Cat,
        value.var="value") %>%
  # mutate(Coupe=ifelse(Coupe=="E","Exploité","Chablis"),
  #        Coupe=factor(Coupe,levels=c("Exploité","Chablis"))) %>%
         # Coupe=ifelse(Cat=="Total",
         #              paste0("\\textbf{",Coupe,"}"),Coupe),
         # Cat=ifelse(Cat=="Total",
         #            "\\rowcolor{LightGray} \\textbf{Total}",Cat),
         # Cat=factor(Cat,levels=c("PER","PB","BM","GB","TGB",
         #                         "\\rowcolor{LightGray} \\textbf{Total}")),
         # Coupe=factor(Coupe,levels=c("Exploité","\\textbf{Exploité}",
         #                             "Chablis","\\textbf{Chablis}"))) %>%
  arrange(Cycle,variable)# %>%
  # mutate(Coupe=ifelse(Cat=="Total",
  #                     paste0("\\textbf{",Coupe,"}"),Coupe),
  #        Cat=ifelse(Cat=="Total",
  #                   "\\rowcolor{LightGray} Total",Cat)) %>%
  # set_multirow_table(1)





# %%%%%%%%%%%%%%%%%%%%%%%%% TOTAUX


# Prelvt_ALIBI2 <- data.frame(Cycle=rep(1:(last_cycle-1)),
#                       Coupe=rep("Total",last_cycle-1),
#                       stringsAsFactors=F)
Prelvt_ALIBI2 <- expand.grid(Cycle=c(1:(last_cycle-1)),
                            Coupe=c("Total")) %>%
  data.frame() %>%
  mutate(Coupe=as.character(Coupe))

# -- Total (tous prélèvements confondus)
t_Tot <- filter(gfForetGroupe2Den_Coupe,
                NumForet==forest_num &
                  is.element(Coupe,c("E","PF/E","C")) &
              Groupe2=="Coupe") %>%
  mutate(Coupe="Total") %>%
  select(Cycle,Coupe,Gha,Vha,VcHa) %>%
  full_join(Prelvt_ALIBI2) %>%
  group_by(Cycle,Coupe) %>%
  summarise(Gha=round(sum(Gha,na.rm=T),1),
            Vha=round(sum(Vha,na.rm=T)),
            VcHa=round(sum(VcHa,na.rm=T))) %>%
  ungroup() %>%
  mutate(PU=VcHa/Vha,
         PU=ifelse(is.na(PU),0,round(PU,0)),
         VcHa=ifelse(VcHa!=0,
                     paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{",
                            VcHa,
                            "}}"),
                     "\\cellcolor{DimGray}"),
         Gha=ifelse(Gha!=0,
                    paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{",
                           Gha,
                           "}}"),
                    "\\cellcolor{DimGray}"),
         Vha=ifelse(Vha!=0,
                    paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{",
                           Vha,
                           "}}"),
                    "\\cellcolor{DimGray}"),
         PU=ifelse(PU!=0,
                   paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{",
                          PU,
                          "}}"),
                   "\\cellcolor{DimGray}")) %>%
  melt(id=c("Cycle","Coupe")) %>%
  # mutate(value=ifelse(Cat=="Total",
  #                     paste0("\\textbf{\\textcolor{White}{",value,"}}"),
  #                     value),
  #        variable=factor(variable,levels=c("Gha","VcHa"))) %>%
  mutate(variable=factor(variable,levels=c("Gha","Vha","VcHa","PU"))) %>%
  dcast(Cycle + variable ~ Coupe,
        value.var="value")

# command_Total1 <- unlist(unname(t_Tot[1,]))
# command_Total1 <- command_Total1[which(!duplicated(command_Total1))]
# command_Total1 <- paste0(command_Total1,
#                          collapse=" & ")

# %%%%%%%%%% %%%%%%%%%% #
# Prelvt_ALIBI3 <- data.frame(Cycle=rep(1:(last_cycle-1)),
#                       Coupe=rep("Taux",last_cycle-1),
#                       stringsAsFactors=F)
Prelvt_ALIBI3 <- expand.grid(Cycle=c(1:(last_cycle-1)),
                            Coupe=c("Taux")) %>%
  data.frame() %>%
  mutate(Coupe=as.character(Coupe))

# -- Taux de prélèvement (tous prélèvements confondus)
t_Prelvt <- filter(gfForetGroupe2Den_Coupe,
            NumForet==forest_num &
              Groupe2=="Coupe") %>%
  select(Cycle,Coupe,Gha,Vha,VcHa) %>%
  mutate(Coupe=gsub("PF/","",Coupe),
         Coupe=gsub("PF","",Coupe),
         Coupe=gsub("C","E",Coupe),
         Coupe=ifelse(Coupe=="E","Taux",Coupe),
         Coupe=ifelse(Coupe=="",NA,Coupe),
         Coupe=as.character(Coupe)) %>%
  full_join(Prelvt_ALIBI3) %>%
  group_by(Cycle,Coupe) %>%
  summarise(VcHa=sum(VcHa,na.rm=T),
            Gha=sum(Gha,na.rm=T),
            Vha=sum(Vha,na.rm=T)) %>%
  # ungroup() %>%
  group_by(Cycle) %>%
  mutate(Gha_Tot=sum(Gha),
         Vha_Tot=sum(Vha),
         VcHa_Tot=sum(VcHa)) %>%
  ungroup() %>%
  filter(Coupe=="Taux") %>%
  mutate(Gha_Part=round(Gha/Gha_Tot*100,0),
         Vha_Part=round(Vha/Vha_Tot*100,0),
         VcHa_Part=round(VcHa/VcHa_Tot*100,0),
         PU="",

         Gha_Part=ifelse(Gha_Part!=0,
                         paste0("\\scriptsize{",Gha_Part," \\%}"),
                         ""),
         Gha_Part=paste0("\\multicolumn{1}{c|}{",Gha_Part,"}"),
         Vha_Part=ifelse(Vha_Part!=0,
                         paste0("\\scriptsize{",Vha_Part," \\%}"),
                         ""),
         Vha_Part=paste0("\\multicolumn{1}{c|}{",Vha_Part,"}"),
         VcHa_Part=ifelse(VcHa_Part!=0,
                         paste0("\\scriptsize{",VcHa_Part," \\%}"),
                         ""),
         VcHa_Part=paste0("\\multicolumn{1}{c|}{",VcHa_Part,"}")) %>%
  select(Cycle,Coupe,Gha_Part,Vha_Part,VcHa_Part,PU) %>%
  rename(Gha=Gha_Part,
         Vha=Vha_Part,
         VcHa=VcHa_Part) %>%
  melt(id=c("Cycle","Coupe")) %>%
  mutate(variable=factor(variable,levels=c("Gha","Vha","VcHa","PU"))) %>%
  dcast(Cycle + variable ~ Coupe,
        value.var="value")

# command_Total2 <- unlist(unname(t_Prelvt[1,]))
# command_Total2 <- command_Total2[which(!duplicated(command_Total2))]
# # command_Total2[which(command_Total2=="Taux")] <- "\\multicolumn{2}{|c|}{\\cellcolor{DimGray} \\textbf{\\textcolor{White}{Taux de prélèvement total}}}"
# command_Total2[which(command_Total2=="Taux")] <- "\\multicolumn{2}{|c|}{\\textbf{Taux de prélèvement total}}"
# command_Total2 <- paste0(command_Total2,
#                          collapse=" & ")
#
# command_Total <- paste0("\\hline\\hline\n",command_Total1,
#                         "\\\\\n\\hline\n",
#                         command_Total2,
#                         "\\\\")

# ListPos[length(ListPos)+1]=dim(t0)[1]
# command=c(command,command_Total)

# remplacement des Cycles par les année + ajout de multicolumn
CyclesPrelvt_DF <- data.frame(Cycle_Ante=1:(last_cycle-1),
                              Cycle_Courant=2:last_cycle,
                              stringsAsFactors=F) %>%
  mutate(Annee_Ante=Cycles_Disp$Annee[match(Cycle_Ante,Cycles_Disp$Cycle)],
         Annee_Courant=Cycles_Disp$Annee[match(Cycle_Courant,Cycles_Disp$Cycle)],

         Periodes=paste0(Annee_Ante,"-",Annee_Courant))

t0 <- left_join(t0,t_Tot) %>%
  left_join(t_Prelvt) %>%
  left_join(CyclesPrelvt_DF[,c("Cycle_Ante","Periodes")],
            by=c("Cycle"="Cycle_Ante")) %>%
  mutate(variable=as.character(variable),
         variable=ifelse(variable=="Gha",
                         "G",variable),
         variable=ifelse(variable=="Vha",
                         "V",variable),
         variable=ifelse(variable=="VcHa",
                         "Vc",variable)) %>%
  select(one_of("Periodes",
                names(t0)[which(!names(t0) %in% c("Cycle","Periodes"))],
                "Total","Taux")) %>%
  set_multirow_table(1)

# %%%%%%%%%% %%%%%%%%%% #
# -- 0.Position Total
# pos_Total <- which(t0$Cat=="\\rowcolor{LightGray} \\textbf{Total}")-1
ListPos <- list()
command=c()
# for (i in 1:length(pos_Total)) {
#   ListPos[length(ListPos)+1] <- pos_Total[i]
#   command <- c(command,"\\hline\n")
# }


# %%%%%%%%%% %%%%%%%%%% #
ListPos <- list()
command=c()
# -- 1.Position changement Cycle.
# Rajout de \\cmidpoint[0.8pt]{1)dim(t0)[2]}
pos_Cycle <- which(!is.na(t0$Periodes))[-1]

if (last_cycle > 2) {
  for (i in 1:length(pos_Cycle)) {
    ListPos[length(ListPos)+1] <- pos_Cycle[i]-1
    command <- c(command,"\\midrule[0.5pt]\n")
  }
} else {
  pos_Cycle <- dim(t0)[1]+1
}


t0 <- rename_(t0,
              "\\multirow{2}{*}{\\parbox{1.4cm}{\\centering \\textbf{Périodes}}}"="Periodes",
              " & \\multirow{2}{*}{\\parbox{1cm}{\\centering \\textbf{Variable}}}"="variable",
              " & \\multirow{2}{*}{\\parbox{1.9cm}{\\centering \\textbf{Total des prélèvements}}}"="Total",
              " & \\multicolumn{1}{c|}{\\multirow{2}{*}{\\parbox{1.7cm}{\\centering \\textbf{Taux de prélèvement}}}}"="Taux")

# %%%%%%%%%% %%%%%%%%%% #
# -- 2.Construction entête :
Ligne1 <- str_sub(names(t0)[3:(dim(t0)[2]-2)],
                  str_locate(names(t0)[3:(dim(t0)[2]-2)],"_")[,1]+1,-1)
# Ligne1 <- gsub("VcHa","Vc",Ligne1)
# Ligne1 <- gsub("Gha","G",Ligne1)
# Ligne1 <- paste0("& & ",paste0(Ligne1,collapse=" & "))

names(t0)[3:(dim(t0)[2]-2)] <- str_sub(names(t0)[3:(dim(t0)[2]-2)],
                                   1,
                                   str_locate(names(t0)[3:(dim(t0)[2]-2)],"_")[,1]-1)



# Entete_Annees <- paste0(CyclesPrelvt_DF$Annee_Ante,
#                         " - ",
#                         CyclesPrelvt_DF$Annee_Courant)
# names(t0)[3:dim(t0)[2]] <- Entete_Annees

# ajout de multicolumn
pos_Dupl <- which(duplicated(names(t0)))
names(t0)[pos_Dupl-1] <- paste0(" & \\multicolumn{5}{c|}{\\textbf{",
                                names(t0)[pos_Dupl-1],"}}")
names(t0)[pos_Dupl] <- ""
Entete <- paste0(paste0(names(t0),collapse=""),
                 paste0("\\\\ \n\\cline{3-",dim(t0)[2]-2,"}"))

names(t0) <- c("","",Ligne1,"","")
names(t0)[which(names(t0)=="Total")] <- paste0("\\cellcolor{LightGray}{",
                                               names(t0)[which(names(t0)=="Total")],
                                               "}")
names(t0)[dim(t0)[2]] <- paste0("\\multicolumn{1}{c|}{",
                                names(t0)[dim(t0)[2]],"}")
# %%%%%%%%%% %%%%%%%%%% #
# -- 3.Position pour rajout \\cline{1-1}\\cline{3-dim(t0)[2]} : séparation pour un même mode de prélèvement
pos <- -1
ListPos <- c(ListPos,list(pos))
command=c(command,paste0("\\hline\n",Entete,"\n"))
# command=paste0("\\cline{3-",dim(t0)[2],"}\\\\\n",
#                # paste0(rep("&",dim(t0)[2]-1),collapse=" "),
#                Ligne1,
#                "\n\\\\ \\cline{1-1}\\cline{3-",dim(t0)[2],"}\n")

for (i in (1:(dim(t0)[1]))[-c(pos_Cycle)]) {
  ListPos[length(ListPos)+1] <- i-1
  command <- c(command,paste0("\\cline{2-",dim(t0)[2],"}\n"))
}

# %%%%%%%%%% %%%%%%%%%% #

ListPos[length(ListPos)+1] <- dim(t0)[1]
command <- c(command,paste0("\\cline{1-",dim(t0)[2]-1,"}"))



print(xtable(t0,
             # digits=rep(0,dim(t1)[2]+1),
             digits=rep(0,dim(t0)[2]+1),
             align=c("M{0cm}|","|M{1.4cm}","|M{1cm}",
                     rep("|M{0.5cm}",dim(t0)[2]-4),"|M{1.9cm}|","M{1.7cm}"),
             caption = "Prélèvements constatés sur la période (placettes d'inventaire passées en coupe)",
             label   = "TabCat_Prelvt_Plac_Assiette"),
      caption.placement = "bottom",
      hline.after=F,
      sanitize.text.function=function(x){return(x)},
      include.rownames=F,
      add.to.row=list(
            pos=ListPos,
            command=command),
      size="\\footnotesize")

@
\FloatBarrier

\Sexpr{i18n()$t("Le tableau")} \ref{harvests_and_increments_table} \Sexpr{i18n()$t("présente les prélèvements mis en regard avec les niveaux d'accroissement.")}\\
\Sexpr{i18n()$t("La figure")} \ref{fig:harvest_bar_chart} \Sexpr{i18n()$t("représente la part de l'accroissement prélevé en termes de surface terrière et de valeur.")}

<<harvests_and_increments_table, results = 'asis',eval = F, include = F>>=

# -- variables to use
var <- c("Gha", "Vha", "VcHa")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 0, 0)
)


# last_cycle = 5 # debug 55 - pas de qual au cycle 1
table <-
  gfForetFpied_Coupe %>%
  filter(NumForet == forest_num) %>% 
  # debug 55 - pas de qual au cycle 1
  # filter(Cycle > 1) %>%
  # mutate(Cycle = Cycle - 1) %>% 
  # debug 55 - pas de qual au cycle 1 - end

  get_aligned_wood_flows_table(
    var = c("Gha", "Vha", "VcHa"),
    group = NULL
  ) %>%
  mutate(Cycle = Inf) %>%

  # join periods_table to get time_span
  left_join(periods_table, by = c("NumForet", "Cycle")) %>%

  # calculate results vars
  mutate(
    # all_lost_wood_share = (harvested_wood_share + fallen_wood_share) * 100, # part d'accroissement prélevée -> à récalculer avec "E" et "C" et l'accroissement car problème si changement du nombre de placettes.
    acct = acct / time_span,
    
    # inc_rate = acct / initial_value * 100,
    # fallen_wood_share = fallen_wood_share * 100, # part de chablis dans le total des prélèvements -> à récalculer avec "E" et "C" et l'accroissement car problème si changement du nombre de placettes.

    # class factor to sort variable
    variable = factor(variable, levels = c("Gha", "Vha", "VcHa"))
  ) %>%
  arrange(variable)

# -- Attention : incohérence des chiffres au cycle 2 si changement du nombre de placettes entre les cycles (ex : si 2 cycles et nombre de placettes a changé, alors valeurs d'accroissement calculés par arbres (et pondérés par le poids des placettes) diffèrent des valeurs d'accroissement recalculées avec les prélèvements et l'état initial et final (valeurs tout de même très proches) => on remplace les valeurs d'accroissement par celles annoncées dans tableaux/figures précédentes.
if (last_cycle == 2) {
  acct_table <- 
    gfForetFpied_ %>% 
    filter(Cycle == last_cycle) %>% 
    select(NumForet, AcctGper, AcctVper, Gainper) %>% 
    pivot_longer(
      cols = -c("NumForet"), 
      names_to = "variable", 
      values_to = "acct"
    ) %>% 
    mutate(
      variable = case_when(
        variable == "AcctGper" ~ "Gha", 
        variable == "AcctVper" ~ "Vha",
        variable == "Gainper" ~ "VcHa"
      )
    )
  
  table <- table %>% select(-acct) %>% left_join(acct_table, by = join_by(NumForet, variable))
}

table <- 
  table %>% 
  mutate(
    inc_rate = acct / initial_value * 100, 
    harvest = (E + C), # total des prélèvements
    harvest_rate = harvest / initial_value * 100, # taux de prélèvement
    harvest = harvest / time_span, # prélèvement / an
    all_lost_wood_share = (harvest / acct) * 100, # part d'accroissement prélevée
    fallen_wood_share = (C / time_span) / acct * 100 # part de chablis dans le total des prélèvements
    ) %>%
  
  # select
  select(
    variable, acct, inc_rate, harvest, harvest_rate,
    all_lost_wood_share, fallen_wood_share
    ) %>%

  # pivot
  pivot_longer(cols = -"variable") %>%

  mutate(
    # round values
    label = case_when(
      name == "acct" & variable == "Gha" ~ round(value, 2),
      name == "acct" & variable == "Vha" ~ round(value, 1),
      name == "acct" & variable == "VcHa" ~ round(value, 0),

      name == "inc_rate" ~ round(value, 1),
      name == "harvest_rate" ~ round(value, 0),

      name == "harvest" & variable == "Gha" ~ round(value, 2),
      name == "harvest" & variable == "Vha" ~ round(value, 1),
      name == "harvest" & variable == "VcHa" ~ round(value, 0),

      name == "all_lost_wood_share" ~ round(value, 0),
      name == "fallen_wood_share" ~ round(value, 0)
    ),
    label = ifelse(value > 0 & label == 0, "$\\sim$0", label),

    # add "\\%"
    label = ifelse(
      name %in% c("inc_rate", "harvest_rate", "all_lost_wood_share", "fallen_wood_share"),
      paste0(label, " \\%"),
      label
    ),

    # format names
    value = NULL,
    name = case_when(
      name == "acct" ~ i18n()$t("Accroissement"),
      name == "inc_rate" ~ i18n()$t("Taux d'accroissement"),
      name == "harvest_rate" ~ i18n()$t("Taux de prélèvement"),
      name == "harvest" ~ i18n()$t("Prélèvement"),
      name == "all_lost_wood_share" ~ i18n()$t("\\% Acct prélevé"),
      name == "fallen_wood_share" ~ i18n()$t("dont chablis")
    )
  ) %>%

  # pivot variable
  pivot_wider(
    id_cols = "name",
    names_from = "variable",
    values_from = "label"
  ) %>%

  # rename
  rename(
    " " = "name",
    !!paste0("\\textbf{", i18n()$t("Surface terrière (m2/ha/an)"), "}") := i18n()$t("Gha"),
    !!paste0("\\textbf{", i18n()$t("Volume (m3/ha/an)"), "}") := i18n()$t("Vha"),
    !!paste0("\\textbf{", i18n()$t("Valeur (\\euro/ha/an)"), "}") := i18n()$t("VcHa")
  )

# -- print table
print(
  xtable(
    table,
    digits = rep(0, ncol(table) + 1),
    align = c("M{0cm}|", "|M{3.5cm}", "|M{2.5cm}", "|M{2.5cm}", "|M{2.5cm}|"),
    caption.placement = "bottom",
    caption =
      paste0(
        i18n()$t("Accroissements et prélèvements en surface terrière, volume et valeur sur la période "),
        period
      ),
    label = "harvests_and_increments_table"
  ),
  # floating=F,
  hline.after = -1:nrow(table),
  sanitize.text.function = function(x) return(x),
  include.rownames = FALSE,
  size = "\\footnotesize"
)
# last_cycle = 6 # debug 55 - pas de qual au cycle 1
@

<<harvests_and_increments_table_bis, results = 'asis',eval = eval_evol, include = eval_evol>>=

# -- variables to use
var <- c("Gha", "Vha", "VcHa")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 0, 0)
)


# last_cycle = 5 # debug 55 - pas de qual au cycle 1
table <-
  gfForetFpied_Coupe %>%
  filter(NumForet == forest_num) %>% 
  # debug 55 - pas de qual au cycle 1
  # filter(Cycle > 1) %>%
  # mutate(Cycle = Cycle - 1) %>% 
  # debug 55 - pas de qual au cycle 1 - end

  get_aligned_wood_flows_table(
    var = c("Gha", "Vha", "VcHa"),
    group = NULL
  ) %>%
  mutate(Cycle = Inf) %>%

  # join periods_table to get time_span
  left_join(periods_table, by = c("NumForet", "Cycle")) %>%

  # calculate results vars
  mutate(
    # all_lost_wood_share = (harvested_wood_share + fallen_wood_share) * 100, # part d'accroissement prélevée -> à récalculer avec "E" et "C" et l'accroissement car problème si changement du nombre de placettes.
    acct = acct / time_span,
    
    # inc_rate = acct / initial_value * 100,
    # fallen_wood_share = fallen_wood_share * 100, # part de chablis dans le total des prélèvements -> à récalculer avec "E" et "C" et l'accroissement car problème si changement du nombre de placettes.

    # class factor to sort variable
    variable = factor(variable, levels = c("Gha", "Vha", "VcHa"))
  ) %>%
  arrange(variable)

# -- Attention : incohérence des chiffres au cycle 2 si changement du nombre de placettes entre les cycles (ex : si 2 cycles et nombre de placettes a changé, alors valeurs d'accroissement calculés par arbres (et pondérés par le poids des placettes) diffèrent des valeurs d'accroissement recalculées avec les prélèvements et l'état initial et final (valeurs tout de même très proches) => on remplace les valeurs d'accroissement par celles annoncées dans tableaux/figures précédentes.
# if (last_cycle == 2) {
#   acct_table <- 
#     gfForetFpied_ %>% 
#     filter(Cycle == last_cycle) %>% 
#     select(NumForet, AcctGper, AcctVper, Gainper) %>% 
#     pivot_longer(
#       cols = -c("NumForet"), 
#       names_to = "variable", 
#       values_to = "acct"
#     ) %>% 
#     mutate(
#       variable = case_when(
#         variable == "AcctGper" ~ "Gha", 
#         variable == "AcctVper" ~ "Vha",
#         variable == "Gainper" ~ "VcHa"
#       )
#     )
#   
#   table <- table %>% select(-acct) %>% left_join(acct_table, by = join_by(NumForet, variable))
# }

table <- 
  table %>% 
  mutate(
    inc_rate = acct / initial_value * 100, 
    harvest = (E + C), # total des prélèvements
    harvest_rate = harvest / initial_value * 100, # taux de prélèvement
    harvest = harvest / time_span, # prélèvement / an
    all_lost_wood_share = (harvest / acct) * 100, # part d'accroissement prélevée
    fallen_wood_share = (C / time_span) / acct * 100 # part de chablis dans le total des prélèvements
    ) %>%
  
  # select
  select(
    variable, acct, inc_rate, harvest, harvest_rate,
    all_lost_wood_share, fallen_wood_share
    ) %>%

  # pivot
  pivot_longer(cols = -"variable") %>%

  mutate(
    # round values
    label = case_when(
      name == "acct" & variable == "Gha" ~ round(value, 2),
      name == "acct" & variable == "Vha" ~ round(value, 1),
      name == "acct" & variable == "VcHa" ~ round(value, 0),

      name == "inc_rate" ~ round(value, 1),
      name == "harvest_rate" ~ round(value, 0),

      name == "harvest" & variable == "Gha" ~ round(value, 2),
      name == "harvest" & variable == "Vha" ~ round(value, 1),
      name == "harvest" & variable == "VcHa" ~ round(value, 0),

      name == "all_lost_wood_share" ~ round(value, 0),
      name == "fallen_wood_share" ~ round(value, 0)
    ),
    label = ifelse(value > 0 & label == 0, "$\\sim$0", label),

    # add "\\%"
    label = ifelse(
      name %in% c("inc_rate", "harvest_rate", "all_lost_wood_share", "fallen_wood_share"),
      paste0(label, " \\%"),
      label
    ),

    # format names
    value = NULL,
    name = case_when(
      name == "acct" ~ i18n()$t("Accroissement"),
      name == "inc_rate" ~ i18n()$t("Taux d'accroissement"),
      name == "harvest_rate" ~ i18n()$t("Taux de prélèvement"),
      name == "harvest" ~ i18n()$t("Prélèvement"),
      name == "all_lost_wood_share" ~ i18n()$t("\\% Acct prélevé"),
      name == "fallen_wood_share" ~ i18n()$t("dont chablis")
    )
  ) %>%

  # pivot variable
  pivot_wider(
    id_cols = "name",
    names_from = "variable",
    values_from = "label"
  ) %>%

  # rename
  rename(
    " " = "name",
    !!paste0("\\textbf{", i18n()$t("Surface terrière (m2/ha/an)"), "}") := i18n()$t("Gha"),
    !!paste0("\\textbf{", i18n()$t("Volume (m3/ha/an)"), "}") := i18n()$t("Vha"),
    !!paste0("\\textbf{", i18n()$t("Valeur (\\euro/ha/an)"), "}") := i18n()$t("VcHa")
  )

# -- print table
print(
  xtable(
    table,
    digits = rep(0, ncol(table) + 1),
    align = c("M{0cm}|", "|M{3.5cm}", "|M{2.5cm}", "|M{2.5cm}", "|M{2.5cm}|"),
    caption.placement = "bottom",
    caption =
      paste0(
        i18n()$t("Accroissements et prélèvements en surface terrière, volume et valeur sur la période "),
        period
      ),
    label = "harvests_and_increments_table"
  ),
  # floating=F,
  hline.after = -1:nrow(table),
  sanitize.text.function = function(x) return(x),
  include.rownames = FALSE,
  size = "\\footnotesize"
)
# last_cycle = 6 # debug 55 - pas de qual au cycle 1
@


<<harvests_and_increments_table_by_plot, results = 'asis',eval = F, include = F>>=


##### fonction pour obtenir les prélèvements #####
get_aligned_wood_flows_by_plot_table <- function(
  table = NULL,
  var = NULL,
  group = NULL
) {
  # var <- c("Gha", "VcHa")
  # print(...)
  groups <- c("Coupe", group)
  # enquo_group <- enquos(...)
  #   print(enquo_group)
  #   # enquos_group <-  # autre possibilité : vars(), as_label pour repasser string
  #   #   if (!is.null(group)) {
  #   #     enquos(Coupe, group)
  #   #   } else {
  #   #     enquos(Coupe)
  #   #   }
  # # enquos_var <- enquos(...)
  # quos_var <- quos(!!parse_exprs(var))
  # # table <- gfForetFpied_EssenceCoupe
  #
  #   x_groups <-  # autre possibilité : vars(), as_label pour repasser string
  #     if (!is.null(group)) {
  #       parse_exprs(c("Coupe", group))
  #     } else {
  #       parse_exprs("Coupe")
  #     }
  #
  #   quo_groups <-  quos(!!parse_exprs(c("Coupe")))# autre possibilité : vars(), as_label pour repasser string
  #     if (!is.null(group)) {
  #       quos(!!parse_exprs(c("Coupe", group)))
  #     } else {
  #       quos(!!parse_exprs(c("Coupe")))
  #     }
  #
  #   group <- c("Coupe")

  # commande utile :
  # rlang::qq_show(!!quo(x))

  # harvested_wood <- # df_E
  harvested_wood <-
    table %>%
    filter(NumForet == forest_num & Cycle < last_cycle) %>%
    mutate(
      # format 'Coupe'
      Coupe = gsub("PF/", "", Coupe),
      Coupe = gsub("PF", "", Coupe),
      Coupe = ifelse(Coupe == "", NA, Coupe),

      # set Cycle = 1
      Cycle = 1,

      # sécurités au cas où prélèvement(s) serai(en)t manquants
      Coupe = factor(Coupe, levels = c("C", "E"))
    ) %>%
    complete(NumForet, NumPlac, !!!syms(groups), fill = list(Cycle = 1)) %>%

    # suppression des valeurs Coupe vides
    filter(!is.na(Coupe)) %>%

    # calcul totals
    select(NumForet, NumPlac, Cycle, groups, var) %>% # var
    pivot_longer(
      cols = var,
      names_to = "variable",
      values_to = "value"
    ) %>%
    group_by(NumForet, NumPlac, Cycle, !!!syms(groups), variable) %>%
    summarise(value = sum(value, na.rm = T)) %>%
    ungroup() %>%
    pivot_wider(
      id_cols = c("NumForet", "NumPlac", "variable", group),
      names_from = "Coupe",
      values_from = "value"
    )

  groups <- group
  standing_wood <-
    table %>%
    filter(NumForet == forest_num & is.element(Cycle, c(1, last_cycle))) %>%

    # set Cycle
    mutate(Cycle = ifelse(Cycle == 1, "initial_value", "final_value")) %>%

    # complete missing values
    complete(NumForet, NumPlac, !!!syms(groups), fill = list(Cycle = 1)) %>%

    # calcul totals
    select(NumForet, NumPlac, Cycle, group, var) %>%
    pivot_longer(
      cols = var,
      names_to = "variable",
      values_to = "value"
    ) %>%
    group_by(NumForet, NumPlac, Cycle, !!!syms(groups), variable) %>%
    summarise(value = sum(value, na.rm = T)) %>%
    ungroup() %>%
    pivot_wider(
      id_cols = c("NumForet", "NumPlac", "variable", groups),
      names_from = "Cycle",
      values_from = "value"
    )

  # -- joining tables
  table <- left_join(
    standing_wood, harvested_wood,
    by = c("NumForet", "NumPlac", "variable")
  ) %>%
    # calcul acct
    mutate(
      acct = final_value - initial_value + (E + C), # value_Tot
      harvested_wood_share = E / acct, # Part_value_Tot_E
      fallen_wood_share = C / acct # Part_value_Tot_C
    )

  # -- return of get_aligned_wood_flows_table function
  return(table)
}

# -- variables to use
var <- c("Gha", "Vha", "VcHa")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 0, 0)
)

# last_cycle = 5 # debug 55 - pas de qual au cycle 1
table <-
  gfPlaFpied_Coupe %>%
  filter(NumForet == forest_num) %>% 
  # debug 55 - pas de qual au cycle 1
  # filter(Cycle > 1) %>%
  # mutate(Cycle = Cycle - 1) %>% 
  # debug 55 - pas de qual au cycle 1 - end

  get_aligned_wood_flows_by_plot_table(
    var = c("Gha", "Vha", "VcHa"),
    group = NULL
  ) %>%
  mutate(Cycle = Inf) %>%

  # join periods_table to get time_span
  left_join(periods_table, by = c("NumForet", "Cycle")) %>%

  # calculate results vars
  mutate(
    all_lost_wood_share = (harvested_wood_share + fallen_wood_share) * 100,
    acct = acct / time_span,
    harvest = (E + C) / time_span,
    inc_rate = acct / initial_value * 100,
    harvest_rate = harvest / initial_value * 100,
    fallen_wood_share = fallen_wood_share * 100,

    # class factor to sort variable
    variable = factor(variable, levels = c("Gha", "Vha", "VcHa"))
  ) %>%
  arrange(variable) %>%

  # select
  select(
    NumPlac, variable, acct, inc_rate, harvest, harvest_rate,
    all_lost_wood_share, fallen_wood_share
    ) %>%

  # pivot
  pivot_longer(cols = -c("NumPlac", "variable")) %>%

  mutate(
    # round values
    label = case_when(
      name == "acct" & variable == "Gha" ~ round(value, 2),
      name == "acct" & variable == "Vha" ~ round(value, 1),
      name == "acct" & variable == "VcHa" ~ round(value, 0),

      name == "inc_rate" ~ round(value, 1),
      name == "harvest_rate" ~ round(value, 1),

      name == "harvest" & variable == "Gha" ~ round(value, 2),
      name == "harvest" & variable == "Vha" ~ round(value, 1),
      name == "harvest" & variable == "VcHa" ~ round(value, 0),

      name == "all_lost_wood_share" ~ round(value, 0),
      name == "fallen_wood_share" ~ round(value, 0)
    ),
    label = ifelse(value > 0 & label == 0, "$\\sim$0", label),

    # add "\\%"
    label = ifelse(
      name %in% c("inc_rate", "harvest_rate", "all_lost_wood_share", "fallen_wood_share"),
      paste0(label, " \\%"),
      label
    ),

    # format names
    value = NULL,
    name = case_when(
      name == "acct" ~ i18n()$t("Accroissement"),
      name == "inc_rate" ~ i18n()$t("Taux d'accroissement"),
      name == "harvest_rate" ~ i18n()$t("Taux de prélèvement"),
      name == "harvest" ~ i18n()$t("Prélèvement"),
      name == "all_lost_wood_share" ~ i18n()$t("\\% Acct prélevé"),
      name == "fallen_wood_share" ~ i18n()$t("dont chablis")
    )
  ) %>%

  # pivot variable
  pivot_wider(
    id_cols = c("NumPlac", "name"),
    names_from = "variable",
    values_from = "label"
  ) %>% 
  filter(name == "Accroissement")

  # rename
  rename(
    " " = "name",
    !!paste0("\\textbf{", i18n()$t("Surface terrière (m2/ha/an)"), "}") := i18n()$t("Gha"),
    !!paste0("\\textbf{", i18n()$t("Volume (m3/ha/an)"), "}") := i18n()$t("Vha"),
    !!paste0("\\textbf{", i18n()$t("Valeur (\\euro/ha/an)"), "}") := i18n()$t("VcHa")
  )

@



<<harvest_bar_chart, fig.height = 3, fig.width = 4, fig.cap = paste0( i18n()$t("Répartition du prélèvement en volume et en valeur (période "), Cycles_Disp$Annee[Cycles_Disp$Cycle == 1], "-", Cycles_Disp$Annee[Cycles_Disp$Cycle == last_cycle], ")" ), results = 'asis', eval = eval_evol, include = eval_evol>>=

# -- table des prélèvements

# -- table
# last_cycle = 5 # debug 55 - pas de qual au cycle 1

table <-
  gfForetFpied_Coupe %>%
   # debug 55 - pas de qual au cycle 1
  # filter(NumForet == forest_num & Cycle > 1) %>%
  # mutate(Cycle = Cycle - 1) %>% 
   # debug 55 - pas de qual au cycle 1 - end
  
  get_aligned_wood_flows_table(
    var = c("Vha", "VcHa"),
    group = NULL
    ) %>%
  select(
    NumForet, variable,
    harvested_wood_share,
    fallen_wood_share
    ) %>%
  pivot_longer(
    cols = -c("NumForet", "variable"),
    names_to = "Coupe",
    values_to = "value"
  ) %>%

  # format
  mutate(
    Coupe = ifelse(
      Coupe == "harvested_wood_share", i18n()$t("Exploité"), i18n()$t("Chablis")
      ),
    Coupe = factor(Coupe, levels = c(i18n()$t("Exploité"), i18n()$t("Chablis"))),

    variable = ifelse(variable == "Vha", i18n()$t("Volume"), i18n()$t("Valeur")),
    variable = factor(variable, levels = c(i18n()$t("Volume"), i18n()$t("Valeur")))
  )

# -- colour aesthetics
# colour values
colour_aes <- c("darkgoldenrod", "dodgerblue2")
# palette names
names(colour_aes) <- c(i18n()$t("Exploité"), i18n()$t("Chablis"))

# -- paramètre ordonnée
Y_max <- with(
  table %>% group_by(variable) %>% summarise(value = sum(value, na.rm = T)),
  max(value, na.rm = T)
)
Y_max <- if (Y_max > 1.5) Y_max * 1.1 else 1.5
increment_value <- ifelse(Y_max > 1.3, 0.25, 0.1)

# -- plot
ggplot() +
  geom_bar(
    table,
    mapping = aes(variable, value, fill = Coupe),
    stat = "identity", position = "stack",
    width = .5, colour = "gray50"
  ) +
  geom_hline(
    yintercept = 1,
    colour = "gray30",
    linetype = 2,
    size = 0.5
  ) +
  scale_y_continuous(
    name = i18n()$t("Part de l'accroissement prélevé"),
    limits = c(0, Y_max),
    breaks = seq(0, Y_max * 1.3, increment_value),
    labels = percent_format(accuracy = 1)
  ) +
  scale_fill_manual(name = "", values = colour_aes) +
  theme_bw() + MyTheme +
  theme(
    text = element_text(size = 8),
    title = element_text(size = 9),
    axis.title.x = element_blank(),
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )
# last_cycle = 6 # debug 55 - pas de qual au cycle 1

# TODO - Question : si on veut avoir le prélèvement sur une plus grande période, quelles valeurs considérer ? le prélèvement moyen par an ? sur toute la période ?
@

<<harvesting_rate, size = 'footnotesize', results = 'asis', eval = eval_harvest, include = eval_harvest>>=


# ##### fonction pour obtenir les taux de prélèvements par groupes #####
# get_harvested_shares_table <- function(
#   table = NULL,
#   group = NULL,
#   var = NULL
# ) {
# # table <- gfForetFpied_EssRegCoupe # debug
# # group <- "Essence" # debug
# # var = c("Gha", "Vha", "VcHa") # debug
#
# # groups
# # groups <- c("NumForet", "Cycle", "Coupe", group)
# # groups_without_Coupe <- c("NumForet", "Cycle", group)
#
# # -- harvested table
# table <-
#   table %>%
#   filter(NumForet == forest_num & Cycle == last_cycle - 1) %>%
#   mutate(
#     # format 'Coupe'
#     Coupe = gsub("PF/", "", Coupe),
#     Coupe = gsub("PF", "", Coupe),
#     Coupe = ifelse(is.na(Coupe), "", Coupe),
#
#     # sécurités au cas où prélèvement(s) serai(en)t manquants
#     Coupe = factor(Coupe, levels = c("E", "C", ""))
#   ) %>%
#   complete(!!!syms(c("NumForet", "Cycle", "Coupe", group))) %>%
#
#   # pivot
#   select(!!!syms(c("NumForet", "Cycle", "Coupe", group)), var) %>%
#   pivot_longer(
#     cols = var,
#     names_to = "variable",
#     values_to = "value"
#   ) %>%
#
#   # sum (useless ?)
#   group_by(!!!syms(c("NumForet", "Cycle", "Coupe", group)), variable) %>%
#   summarise(value = sum(value, na.rm = T)) %>%
#   ungroup() %>%
#
#   # format
#   mutate(variable = factor(variable, levels = var))
#
# # -- total by group
# total_by_group <-
#   table %>%
#   group_by(!!!syms(c("NumForet", "Cycle", group)), variable) %>%
#   summarise(total = sum(value, na.rm = T)) %>%
#   ungroup()
#
# # -- total share of lost wood (harvested + fallen) by group
# total_lost_wood_by_group <-
#   table %>%
#
#   # filter only E/C elements
#   filter(is.element(Coupe, c("E", "C"))) %>%
#
#   # somme des coupes + chablis
#   group_by(!!!syms(c("NumForet", "Cycle", group)), variable) %>%
#   summarise(total_lost_wood = sum(value, na.rm = T)) %>%
#   ungroup() %>%
#
#   # join total
#   left_join(
#     total_by_group,
#     by = c("NumForet", "Cycle", group, "variable")
#     ) %>%
#
#   # calcul part de '(C+E)/total'
#   mutate(
#     share = round(total_lost_wood / total * 100),
#
#     # label ...
#     label = NA,
#     label = case_when(
#     # ... pour la table total
#       is.null(group) ~
#         paste0("\\textbf{\\textcolor{white}{", share, " \\%}}"),
#     # ... pour les autres
#       !is.null(group) ~
#         paste0(share, " \\%")
#       ),
#     # vide si valeur nulle
#     label = case_when(total_lost_wood > 0 ~ label),
#     # label = if_else(total_lost_wood > 0, label, ""), # another way
#
#     Coupe = "",
#     Coupe = factor(Coupe, levels = c("E", "C", ""))
#   ) %>%
#   select(NumForet, Cycle, Coupe, group, variable, label)
#
# # -- main table
# table <-
#   table %>%
#   # filtre -> éléments C/E uniquement
#   filter(is.element(Coupe, c("E", "C"))) %>%
#
#   # calcul des parts des différents membres du groupe
#   group_by(Coupe, variable) %>%
#   mutate(share = round(value / sum(value) * 100)) %>%
#   ungroup() %>%
#
#   # format
#   mutate(
#     # si VcHa -> 0 digits
#     value = if_else(
#       value > 0.1 & variable == "VcHa",
#       round(value), value
#     ),
#     # si autre -> 1 digits si > 0.1, 2 digits si <= 0.1
#     value = if_else(
#       value > 0.1 & variable != "VcHa",
#       round(value, 1), round(value, 2)
#     ),
#
#     # label ...
#     label = NA,
#     label = case_when(
#       # ... pour la table total
#       is.null(group) ~
#         paste0("\\textbf{\\textcolor{white}{", value, "}}"),
#       # ... pour les autres
#       !is.null(group) ~
#         paste0(
#           value,
#           " \\scriptsize{\\textcolor{CornflowerBlue}{(",
#           share,
#           "\\%)}}"
#         )
#     ),
#     label = case_when(value > 0 ~ label)
#   ) %>%
#   select(NumForet, Cycle, Coupe, group, variable, label) %>%
#
#   # stack totals
#   rbind(total_lost_wood_by_group)
#
# # cond if group is NULL
# table <-
#   if (!is.null(group)) {
#     table %>% rename("group" = group)
#   } else {
#     table %>%
#       mutate(group = "\\rowcolor{DimGray} \\textbf{\\textcolor{white}{Total}}")
#   }
#
#   # sort
#   table <-
#     table %>%
#     arrange(group, variable, Coupe) %>%
#     select(NumForet, Cycle, Coupe, group, variable, label)
#
# # -- return from 'get_harvested_shares_table'
# return(table)
# }


# -- variables to use
var <- c("Gha", "Vha", "VcHa")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 1, 0)
)

# -- tables
lost_wood_shared_by_species <-
  gfForetFpied_EssRegCoupe %>%
  mutate(
    # rename
    Essence = EssReg,
    # translation
    Essence = i18n()$t(Essence),
    Essence = factor(Essence, levels = standing_trees_grouped_species_order)
  ) %>%
  get_harvested_shares_table(
    group = "Essence",
    var = c("Gha", "Vha", "VcHa"),
    digits_table = digits_table
  )

lost_wood_shared_by_cat <-
  gfForetFpied_CatCoupe %>%
  mutate(
    # translation
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) ))
  ) %>%
  get_harvested_shares_table(
    group = "Cat",
    var = c("Gha", "Vha", "VcHa"),
    digits_table = digits_table
  )
lost_wood_shared_by_qual2 <-
  gfForetFpied_Reg2Coupe %>%
  mutate(Qual2 = factor(Reg2, levels = c("A+B", "C+D"))) %>%
  get_harvested_shares_table(
    group = "Reg2",
    var = c("Gha", "Vha", "VcHa"),
    digits_table = digits_table
  )
lost_wood <- get_harvested_shares_table(
  table = gfForetFpied_Coupe,
  group = NULL,
  var = c("Gha", "Vha", "VcHa"),
  digits_table = digits_table
)

# period
period <-
  lost_wood %>%
  mutate(Cycle = Cycle + 1) %>%
  left_join(periods_table, by = "Cycle") %>%
  select(period) %>%
  distinct() %>%
  unlist() %>%
  unname()


# une fois que les différents tableaux ont été rassemblés

# -- final table
table <- rbind(
  lost_wood_shared_by_species,
  lost_wood_shared_by_cat,
  lost_wood_shared_by_qual2,
  lost_wood
) %>%
  # pivot
  pivot_wider(
    id_cols = c("Cycle", "group"),
    names_from = c("Coupe", "variable"),
    values_from = "label"
  ) %>%

  # rename
  rename(
    !!period := "group",

    !!paste0("\\textbf{", i18n()$t("G Exploité"), "}") := "E_Gha",
    !!paste0("\\textbf{", i18n()$t("V Exploité"), "}") := "E_Vha",
    !!paste0("\\textbf{", i18n()$t("Vc Exploité"), "}") := "E_VcHa",

    !!paste0("\\textbf{", i18n()$t("G Chablis"), "}") := "C_Gha",
    !!paste0("\\textbf{", i18n()$t("V Chablis"), "}") := "C_Vha",
    !!paste0("\\textbf{", i18n()$t("Vc Chablis"), "}") := "C_VcHa",

    !!paste0("\\textbf{", i18n()$t("Taux G prélevé (E + C)"), "}") := "share_Gha",
    !!paste0("\\textbf{", i18n()$t("Taux V prélevé (E + C)"), "}") := "share_Vha",
    !!paste0("\\textbf{", i18n()$t("Taux Vc prélevé (E + C)"), "}") := "share_VcHa"
  ) %>%
  select(-Cycle)

# -- print table
# row color
pos <- which(table[, 1] == "\\textbf{\\textcolor{white}{Total}}")
if (length(pos) > 0) {
  rows_list <- list(pos - 1)
  command <- "\\rowcolor{DimGray} "
} else {
  rows_list <- list(0)
  command <- ""
}

# if (last_cycle > 2) {
pos_LINES <- c(
  -1:nrow(table),

  length(unique(lost_wood_shared_by_species$group)),

  length(unique(lost_wood_shared_by_species$group)) +
    length(unique(lost_wood_shared_by_cat$group)),

  length(unique(lost_wood_shared_by_species$group)) +
    length(unique(lost_wood_shared_by_cat$group)) +
    length(unique(lost_wood_shared_by_qual2$group))
)
# pos_LINES <- unique(pos_LINES)
# }
# if (last_cycle == 2) {
#   pos_LINES <- c(-1:dim(df)[1], pos1, pos1 + pos2, pos1 + pos2 + pos3)
# }

print(
  xtable(
    table,
    digits = rep(1, ncol(table) + 1),
    align = c(
      "M{0cm}|", "|M{2cm}", "|M{1.3cm}", "|M{1.2cm}",
      "|M{1cm}|", "|M{1.3cm}", "|M{1.2cm}", "|M{1cm}|",
      "|M{1.4cm}", "|M{1.2cm}", "|M{1.1cm}|"
    ),
    caption.placement = "bottom",
    caption = i18n()$t("Taux de prélèvements sur la période par essence, par catégorie de diamètre, et par qualité\\\\\\footnotesize{Taux G prélevé : taux de prélèvement par rapport à la surface terrière initiale\\\\Taux V prélevé : taux de prélèvement par rapport au volume initial\\\\Taux Vc prélevé: taux de prélèvement par rapport à la valeur de consommation initiale\\\\E : exploité - C : chablis}"),
    label = "Tab_Prelvt"
  ),
  floating = T,
  table.placement = "H",
  hline.after = pos_LINES,
  add.to.row = list(
      pos = rows_list,
      command = command
    ),
  sanitize.text.function = function(x){return(x)},
  include.rownames = FALSE,
  size = "\\footnotesize"
)
@
\FloatBarrier

}{}


\newpage
\chapter{\Sexpr{i18n()$t("Suivi écologique")}}

<<Comment_3, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3")
cat(Comment$Texte)
@

\EditIf{\Sexpr{eval_dmh}}{TRUE}{
\section{Dendromicrohabitats}

<<Comment_3.1, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3.1")
cat(Comment$Texte)
@

% \textcolor{red}{A revoir : Le protocole AFI prévoit d'inventorier les dendromicrohabitats présents sur les arbres du dispositif. Il s'agit d'éléments permettant d'évaluer le degré de naturalité des forêts (coir codification dans le protocole AFI). Il existe d'autres codification (EFI, ProSilva).}

\subsection{Répartition des dendromicrohabitats}

Le protocole d'inventaire prévoit d'inventorier les dendromicrohabitats présents sur les arbres vivants et morts. Il s'agit de relever tous les éléments (trous de pic, cavités, présence de mousse, ...) permettant d'évaluer le degré de naturalité des forêts.\\

La figure \ref{fig:NotesEco_AFI3} illustre la répartition, par classe de diamètre de ces dendromicrohabitats (DMH) inventoriés dans le cadre de ce suivi.

<<NotesEco_AFI3, echo=F, include=eval_dmh, eval=eval_dmh, fig.pos="H", fig.height=6.5, fig.cap= "Répartition des arbres porteurs de dendromicrohabitats (DMH)", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetFpied_ClasseCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Classe,CodeEcolo,Nha,Gha) %>%
  mutate(Mark=NA,
         Mark=ifelse(is.na(CodeEcolo),
                     0,1),
         Mark=factor(Mark,levels=c(0,1))) %>%
  group_by(NumForet,Classe,Mark) %>%
  summarise(Nha=sum(Nha),
            Gha=sum(Gha)) %>%
  ungroup() %>%
  arrange(Classe,Mark)

df0_text <- group_by(df0,
                     NumForet,Mark) %>%
  summarise(Nha=sum(Nha),
            Gha=sum(Gha)) %>%
  ungroup() %>%
  mutate(Part_Nha=round(Nha/sum(Nha,na.rm=T)*100,0),
         Part_Gha=round(Gha/sum(Gha,na.rm=T)*100,0)) %>%
  filter(Mark==1)
  # arrange(Mark)


Y=group_by(df0,Classe) %>%
  summarise(Nha=sum(Nha)) %>%
  ungroup() %>%
  filter(Nha==max(Nha)) %>%
  select(Nha) %>%
  unlist()

X=max(df0$Classe)
Xmin=min(df0$Classe)

# by_VALUE <- ifelse(Y > 200,
#                    20,10)
Y=ifelse(Y==0,
         10,Y)
# value_by <- ifelse(Y>=5000,
#                    1000,Y/10)
# if (Y >= 1000) {
by_VALUE <- floor(((Y/8+Y/15)/2)/100+0.5)*100
# }
if (Y < 650) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/50+0.5)*50
}
if (Y < 325) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/25+0.5)*25
}
if (Y < 130) {
by_VALUE <- floor(((Y/8+Y/15)/2)/10+0.5)*10
}
if (Y < 65) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/5+0.5)*5
  by_VALUE <- ifelse(by_VALUE==0,
                     5,by_VALUE)
}
if (Y < 40) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/3+0.5)*3
  by_VALUE <- ifelse(by_VALUE==0,
                     3,by_VALUE)
}
if (Y < 27) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/2+0.5)*2
  by_VALUE <- ifelse(by_VALUE==0,
                     2,by_VALUE)
}
if (Y <= 13) {
  by_VALUE <- 1
}

p1 <- ggplot() +
  geom_bar(df0,
           mapping=aes(Classe,Nha,fill=Mark),
           stat="identity",position="stack",
           col="black") +
  scale_fill_manual(name="",
                    values=c("snow","dodgerblue"),
                    label=c("arbres sans DMH",
                            "arbre porteur de DMH")) +
    scale_x_continuous(limits=c(17,X*1.1),
                     breaks=seq(20,X*1.3,5),
                     expand=c(0,0)) +
  scale_y_continuous(name="N (tiges/ha)",
                     limits=c(0,Y*1),
                     breaks=seq(0,Y*1.3,by_VALUE)) +
  annotate("text",
           label=paste("Part des arbres porteurs de DMH = ",df0_text$Part_Nha," %"),
           x=0.7*(max(df0$Classe,na.rm=T)+5), #3
           y=Y*0.8,
           # vjust=c(-1.5,
           #         # -0.7,
           #         0),
           size=2.5,
           fontface='plain',
           color="navyblue") +
  theme_bw() + MyTheme +
  theme(legend.position="bottom",
        legend.direction="horizontal")

Y=group_by(df0,Classe) %>%
  summarise(Gha=sum(Gha)) %>%
  ungroup() %>%
  filter(Gha==max(Gha)) %>%
  select(Gha) %>%
  distinct() %>%
  unlist()
p2 <- ggplot() +
  geom_bar(df0,
           mapping=aes(Classe,Gha,fill=Mark),
           stat="identity",position="stack",
           col="black") +
  scale_fill_manual(name="",
                    values=c("snow","dodgerblue"),
                    label=c("arbres sans DMH",
                            "arbre porteur de DMH")) +
    scale_x_continuous(limits=c(17,X*1.1),
                     breaks=seq(20,X*1.3,5),
                     expand=c(0,0)) +
  scale_y_continuous(name="G (m2/ha)",
                     limits=c(0,Y*1),
                     breaks=seq(0,Y*1.3,0.5)) +
  annotate("text",
           label=paste("Part des arbres porteurs de DMH = ",df0_text$Part_Gha," %"),
           x=0.7*(max(df0$Classe,na.rm=T)+5), #3
           y=Y*0.8,
           # vjust=c(-1.5,
           #         # -0.7,
           #         0),
           size=2.5,
           fontface='plain',
           color="navyblue") +
  theme_bw() + MyTheme


mylegend1 <- g_legend(p1)

grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                         p2 + theme(legend.position="none"),
                         nrow=2),
             mylegend1,nrow=2,heights=c(9, 1))
@
\FloatBarrier


<<Comment_3.1.1, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3.1.1")
cat(Comment$Texte)
@

<<Prepa_CodesEco_New, echo=F, include=eval_dmh, eval=eval_dmh, fig.pos="H", fig.height=4, fig.cap="Dendromicrohabitats par catégories de diamètre.\\\\\\scriptsize{PER (Perches) = diamètre compris entre 7.5 cm et 17.5 cm\\\\PB (Petits Bois) = diamètre compris entre 17.5 cm et 27.5 cm\\\\BM (Bois Moyens) = diamètre compris entre 27.5 cm et 47.5 cm\\\\GB (Gros Bois) = diamètre compris entre 47.5 cm et 67.5 cm\\\\TGB (Très Gros Bois) = diamètre supérieur à 67.5cm.}", comment=NA, message=F, warning=FALSE>>=
# -- Palette
Palette_Code <- CodeEcolos$Couleur
names(Palette_Code) <- CodeEcolos$Descriptif

# -- Seuil
Seuil <- 0.01 #(seuil pour filtrer valeurs trop faible)

# -- Construction table
t <- filter(gfForetCodes_CodeEcolo,
            NumForet==forest_num &
              Cycle==last_cycle) %>%
  select(NumForet,Cycle,CodeEcolo,Nha,NbrePlacettes) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  mutate(Note=CodeEcolos$Descriptif[match(CodeEcolo,toupper(CodeEcolos$Code))]) %>%
  group_by(NumForet,Cycle,Note,NbrePlacettes) %>%
  dplyr::summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup()

# -- Séparation en 2 tables : DMH rares ou non
# - DMH rares
df_DMH1 <- filter(t,
                  Nha <= sum(t$Nha,na.rm=T)*Seuil) %>%
  arrange(Nha) %>%
  mutate(Note=str_wrap(Note,
                       width=50,indent=0,exdent=0),
         Note=factor(Note,
                     levels=Note))
# - DMH fréquents
df_DMH2 <- filter(t,
                  Nha > sum(t$Nha,na.rm=T)*Seuil) %>%
  arrange(Nha) %>%
  mutate(Note=str_wrap(Note,
                       width=50,indent=0,exdent=0),
         Note=factor(Note,
                     levels=Note))

Levels1 <- sort(unique(df_DMH1$Note))
Levels2 <- sort(unique(df_DMH2$Note))

df_DMH_Cat <- filter(gfForetCodes_CatCodeEcolo,
                   NumForet==forest_num &
                     Cycle==last_cycle) %>%
  mutate(CodeEcolo=toupper(CodeEcolo),
         Note=CodeEcolos$Descriptif[match(CodeEcolo,toupper(CodeEcolos$Code))])
# Levels_Cat <- sort(unique(df_DMH1$Note))
Levels_Cat <- sort(unique(df_DMH_Cat$Note))

# -- Paramètres pour équilibrer le paramètre fig.height en fonction du nombre de DMH dans les figures qui suivent
df_Scales <- data.frame(Nb_CodesEco=seq(0,40),
                        Classe_CodesEco=sort(c(rep(c(1,seq(5,35,5)),5),35)),
                        Height_CodesEco=c(sort(rep(seq(1,8),5)),8)) %>%
  mutate(Height_CodesEco=ifelse(Height_CodesEco==1 |
                                  Height_CodesEco==2 |
                                  Height_CodesEco==3,
                                2.5,Height_CodesEco))
Param_CodesEcoRare <- df_Scales$Height_CodesEco[match(length(Levels1),
                                                      df_Scales$Nb_CodesEco)]
Param_CodesEco <- df_Scales$Height_CodesEco[match(length(Levels2),
                                                  df_Scales$Nb_CodesEco)]
Param_CodesEcoCat <- df_Scales$Height_CodesEco[match(length(Levels_Cat),
                                                     df_Scales$Nb_CodesEco)]

if (length(Levels1) == 0) {
  sentence_dmh <- "La figure \\ref{fig:CodesEcoFrequents} illustre la diversité des différents dendromicrohabitats (DMH) inventoriés."
} else {
  sentence_dmh <- "Les figures \\ref{fig:CodesEcoFrequents} et \\ref{fig:CodesEcoRare_bis} illustrent la diversité des différents dendromicrohabitats (DMH) inventoriés.\\
La figure \\ref{fig:CodesEcoFrequents} présente les DMH les plus fréquents, la figure \\ref{fig:CodesEcoRare_bis} les DMH les plus rares."
}


@

\Sexpr{sentence_dmh}
% Les figures \ref{fig:CodesEcoFrequents} et \ref{fig:CodesEcoRare_bis} illustrent la diversité des différents dendromicrohabitats (DMH) inventoriés.\\
% La figure \ref{fig:CodesEcoFrequents} présente les DMH les plus fréquents, la figure \ref{fig:CodesEcoRare_bis} les DMH les plus rares.

<<CodesEcoFrequents, echo=F, fig.pos='H', fig.height=Param_CodesEco, fig.cap="Densité à l'hectare des dendromicrohabitats les plus représentés", comment=NA, message=F, warning=FALSE, eval=eval_dmh, include=eval_dmh>>=

# -- Plot
# DMH2 (codes écolo fréquents)
ggplot() +
  geom_bar(df_DMH2, mapping=aes(Note,Nha),
                 position="identity", stat="identity", fill="skyblue3",
           width=0.5) +
  ggplot2::geom_text(df_DMH2, mapping=aes(Note,Nha,label=round(Nha,1)),
            hjust=-0.5, size=2, col="grey40") +
  coord_flip() +
  theme_bw() +
  labs(y=paste0("Densit\u00E9 \u00E0 l'hectare \n(Seuil : N/ha > ",Seuil*100,"% de la densit\u00E9 totale)"),
       x="Dendromicrohabitats") +
  scale_y_continuous(limits=c(0,max(df_DMH2$Nha)*1.1)) +
  MyTheme + theme(axis.text.x = element_text(size=6),
                    axis.text.y = element_text(size=6))
@

<<CodesEcoRare_bis, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos='H', fig.cap="Densité à l'hectare des dendromicrohabitats les plus rares", comment=NA, message=F, warning=FALSE, fig.height=Param_CodesEcoRare>>=

# -- Plot
# DMH1 (codes écolo rares)
if (dim(df_DMH1)[1] > 0) {
ggplot() +
  geom_bar(df_DMH1, mapping=aes(Note,
                              Nha),
                 position="identity", stat="identity", fill="lightskyblue3",width=0.5) +
  ggplot2::geom_text(df_DMH1, mapping=aes(Note,Nha,label=round(Nha,2)),
            hjust=-0.5, size=2, col="grey40") +
  coord_flip() +
  theme_bw() +
  labs(y=paste0("Densit\u00E9 \u00E0 l'hectare \n(Seuil : N/ha inf\u00E9rieur ou \u00E9gal \u00E0\n ",Seuil*100,"% de la densit\u00E9 totale)"),
       x="Dendromicrohabitats") +
  scale_y_continuous(limits=c(0,max(df_DMH1$Nha)*1.1)) +
    MyTheme + theme(axis.text.x = element_text(size=6),
                    axis.text.y = element_text(size=6))

}
@


% Dans la figure \ref{fig:CodesEcoCat}, on a représenté, dans la partie haute de la figure, la densité de DMH inventoriés, que l'on rapporte ensuite dans la partie basse à la surface terrière des arbres de chaque catégorie de diamètre. Ainsi on s'offre un aperçu du nombre de DMH moyen par arbre dans chacune des catégories de diamètre.
La partie haute de la figure \ref{fig:CodesEcoCat} présente la répartition des DMH en nombre de tiges par catégories de diamètre.\\
La partie basse présente le nombre moyen de DMH par catégories de diamètre.
<<CodesEcoCat, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", fig.height=Param_CodesEcoCat, fig.cap="Dendromicrohabitats par cat\u00E9gories de diam\u00E8tre", comment=NA, message=F, warning=FALSE>>=
# -- Seuil 2
Seuil2 <- 0

# -- Table
t1 <- filter(gfForetCodes_CatCodeEcolo,
                   NumForet==forest_num &
                     Cycle==last_cycle) %>%
  select(NumForet,Cycle,CodeEcolo,Cat,Nha,NbrePlacettes) %>%
  mutate(CodeEcolo=toupper(CodeEcolo),
         Note=CodeEcolos$Descriptif[match(CodeEcolo,toupper(CodeEcolos$Code))]) %>%
  group_by(NumForet,Cycle,Cat,NbrePlacettes) %>%
  mutate(Tot=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  filter(Nha > sum(unique(Tot))*Seuil2) %>%
  arrange(Nha) %>%
  mutate(Note=str_wrap(Note,
                       width=50,indent=0,exdent=0),
         Note=factor(Note,
                     levels=unique(names(Palette_Code))),
         Cat=factor(Cat,
                    levels=names(colour_aes_for_diameter_category))) %>%
  arrange(Cat,Note)

# -- Plot 1
p1 <- ggplot() +
  # geom_histogram(t.m, mapping=aes(Cat, Nha, fill=variable), position="stack", stat="identity")
  geom_bar(t1, mapping=aes(Cat, Nha, fill=Note),
           position="stack", stat="identity", width=0.5) +
  #   scale_fill_colorblind() +
  scale_fill_manual(name="Dendromicrohabitats :",
                    values=Palette_Code) +
  labs(x="", y="Densité de DMH\n(N/ha)") +
  guides(fill=guide_legend(reverse=T,
                           ncol=ifelse(Param_CodesEcoCat <=4 |Param_CodesEcoCat > 12,
                                       2,1))) +
    # guides(fill=guide_legend(reverse=T)) +
  MyTheme + theme(legend.position="right",
                  legend.direction="vertical",
                  legend.text=element_text(size=5))


# -- Plot 2
t2 <- filter(gfForetFpied_CatCodeEcolo,
                   NumForet==forest_num &
                     Cycle==last_cycle) %>%
  select(NumForet,Cycle,CodeEcolo,Cat,Nha,NbrePlacettes) %>%
  group_by(NumForet,Cycle,Cat) %>%
  summarise(Nha_Tot=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  mutate(Cat=factor(Cat,
                    levels=names(colour_aes_for_diameter_category))) %>%
  right_join(t1) %>%
  mutate(Nha_Relatif=Nha/Nha_Tot) %>%
  arrange(Note)



p2 <- ggplot() +
  geom_bar(t2, mapping=aes(Cat, Nha_Relatif, fill=Note),
           position="stack", stat="identity", width=0.5) +
#   scale_fill_colorblind() +
  scale_fill_manual(values=Palette_Code) +
  labs(x="", y="Nbre de DMH\npar arbres porteurs") +
  guides(fill=guide_legend(reverse=T)) +
  MyTheme

mylegend <- g_legend(p1)

grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                         p2 + theme(legend.position="none"),
                         nrow=2),
             mylegend, nrow=1,widths=c(5, 5))

@
\FloatBarrier

% \subsection{Dendromicrohabitats}
<<CodesEco, echo=F, include=F, eval=F, fig.pos="H", fig.height=6, fig.cap= "Densité à l'hectare des dendromicrohabitats", comment=NA, message=F, warning=FALSE>>=
Seuil <- 0.01
t <- filter(gfForetCodes_CodeEcolo, NumForet==forest_num) %>%
  select(NumForet,Cycle,CodeEcolo,Nha) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  separate(CodeEcolo,c("Code","Localisation"),sep=1) %>%
  left_join(NbPlac) %>%
  left_join(CodeEcolos,by=c("Code"="CodeEcolo"))

tLoc1 <- filter(t,is.element(Code,c("S","X","Y","Z","K","T","D"))) %>%
  mutate(Descriptif=str_wrap(Descriptif, width = 30, indent = 0, exdent = 0))
tLoc2 <- filter(t,!is.element(Code,c("S","X","Y","Z","K","T","D"))) %>%
  mutate(Descriptif=ifelse(Localisation==1,
                           paste0(Descriptif," au pied"),
                                  Descriptif),
         Descriptif=ifelse(Localisation==2,
                           paste0(Descriptif," sur le fût"),
                                  Descriptif),
         Descriptif=ifelse(Localisation==3,
                           paste0(Descriptif," dans le pied"),
                                  Descriptif),
         Descriptif=str_wrap(Descriptif, width = 30, indent = 0, exdent = 0))
t <- rbind(tLoc1,tLoc2) %>%
  group_by(NumForet,Cycle,Descriptif) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  arrange(Descriptif) %>%
  mutate(Titre=paste0("Cycle ",Cycle))

ggplot() +
  geom_bar(t, mapping=aes(Descriptif,Nha),
                 position="identity", stat="identity", fill="grey60",
           width=0.5) +
    # str_wrap(as.factor(Descriptif), width = 50, indent = 0, exdent = 0),
                                  # value),
  ggplot2::geom_text(t, mapping=aes(Descriptif,Nha,label=round(Nha,0)),
            hjust=-0.5, size=2, col="grey40") +
  coord_flip() +
  theme_bw() +
  labs(y=paste0("Densité à l'hectare"), # \n(Seuil : N/ha > ",Seuil*100,"% de la densité totale)"
       x="Dendromicrohabitats") +
  scale_y_continuous(limits=c(0,max(t$Nha)*1.1)) +
  facet_wrap(~ Titre) + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                    strip.background = element_rect(fill=NA, colour=NA))
@

<<CodesEco3, echo=F, include=F, eval=F, fig.pos="H", fig.height=6, fig.cap= "Dendromicrohabitats par catégories de diamètre.\\\\ \\vspace{0.2cm}\\footnotesize{PER (Perches) = diamètre compris entre 7.5 cm et 17.5 cm\\\\PB (Petits Bois) = diamètre compris entre 17.5 cm et 27.5 cm\\\\BM (Bois Moyens) = diamètre compris entre 27.5 cm et 47.5 cm\\\\GB (Gros Bois) = diamètre compris entre 47.5 cm et 67.5 cm\\\\TGB (Très Gros Bois) = diamètre supérieur à 67.5cm.}", comment=NA, message=F, warning=FALSE>>=
Seuil <- 0.01
t <- filter(gfForetCodes_CatCodeEcolo,
            NumForet==forest_num) %>%
  select(NumForet,Cycle,CodeEcolo,Cat,Nha) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  separate(CodeEcolo,c("Code","Localisation"),sep=1) %>%
  left_join(NbPlac) %>%
  left_join(CodeEcolos,by=c("Code"="CodeEcolo"))

tLoc1 <- filter(t,is.element(Code,c("S","X","Y","Z","K","T","D"))) %>%
  mutate(Descriptif=str_wrap(Descriptif, width = 30, indent = 0, exdent = 0))
tLoc2 <- filter(t,!is.element(Code,c("S","X","Y","Z","K","T","D"))) %>%
  mutate(Descriptif=ifelse(Localisation==1,
                           paste0(Descriptif," au pied"),
                                  Descriptif),
         Descriptif=ifelse(Localisation==2,
                           paste0(Descriptif," sur le fût"),
                                  Descriptif),
         Descriptif=ifelse(Localisation==3,
                           paste0(Descriptif," dans le pied"),
                                  Descriptif),
         Descriptif=str_wrap(Descriptif, width = 30, indent = 0, exdent = 0))

t <- rbind(tLoc1,tLoc2) %>%
  group_by(NumForet,Cycle,Descriptif,Cat) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  # arrange(Descriptif)
#   group_by(NumForet,Cycle) %>%
#   mutate(Tot=sum(Nha,na.rm=T)) %>%
#   ungroup() %>%
#   filter(Nha > Tot*Seuil2) %>%
  filter(!is.na(Nha)) %>%
  arrange(Cat,Descriptif)
# t.m <- t.m[t.m$Nha > t.m$Tot*Seuil2,]
# t.m <- t.m[order(t.m$Nha),]

p1 <-
  ggplot() +
  # geom_histogram(t.m, mapping=aes(Cat, Nha, fill=variable), position="stack", stat="identity")
geom_bar(t, mapping=aes(Cat, Nha, fill=Descriptif),
         position="stack", stat="identity") +
  # scale_fill_colorblind() +
  labs(x="", y="Cumul dendromicrohabitats (N/ha)") +
  guides(fill=guide_legend(reverse=T)) +
  MyTheme + theme(legend.position="right",
                     legend.direction="vertical")

# Comparaison cumul Nha Note Ecolo par rapport à Nha Note Ecolo (Nbre µHabitats portés par chaque arbre porteur)
t2 <- left_join(t,gfForetFpied_Cat,
                  by=c("NumForet"="NumForet","Cycle"="Cycle","Cat"="Cat")) %>%
  rename_("Nha"="Nha.x",
          "NhaTot"="Nha.y") %>%
  mutate(Relatif2=Nha/NhaTot) %>%
  arrange(Cat,Descriptif)
# temp <- merge(psdrfCodesNGVDispCat[,c("NumForet","Cycle","Cat","Nha")],
#               psdrfCodesTaillisDispCat[,c("NumForet","Cycle","Cat","Nha")],
#               all=T)
# temp <- summaryBy(Nha ~ NumForet + Cycle + Cat, data=temp, FUN=sum, keep.names=T, na.rm=T)
# names(temp)[names(temp) %in% "Nha"] <- "NhaTot"
# t3 <- merge(t.m,temp,all.x=T)
# t3$Relatif2 <- t3$Nha/t3$NhaTot
# t3 <- t3[order(t3$Note),]

p2 <-
  ggplot() +
  geom_bar(t2, mapping=aes(Cat, Relatif2, fill=Descriptif),
           position="stack", stat="identity") +
  # scale_fill_colorblind() +
  labs(x="", y="Nbre dendromicrohabitats/Arbres porteurs") +
  guides(fill=guide_legend(reverse=T)) +
  MyTheme

mylegend <- g_legend(p1)

grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                               p2 + theme(legend.position="none"),
                               nrow=2),
                   mylegend, nrow=1,widths=c(6.5, 3.5))
@
\FloatBarrier

\subsection{Notes écologiques}

<<Comment_3.1.2, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3.1.2")
cat(Comment$Texte)
@

<<NotesEco_AFI, echo=F, eval=eval_note_dmh, include=eval_note_dmh, fig.pos="H", fig.height=3, fig.cap= "Densité à l'hectare des dendromicrohabitats", comment=NA, message=F, warning=FALSE>>=

# # --- Version 1
# df <- filter(gfForetCodes_CodeEcolo,
#              NumForet==forest_num & Cycle==last_cycle) %>%
#   select(NumForet,CodeEcolo,Nha,Gha,Vha)
#
# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))
#
# df <- left_join(df,df_Codes,
#             by=c("CodeEcolo"="Code")) %>%
#   mutate(Note_Tot=Note_AFI*Nha)
#
# Note_Totale <- round(sum(df$Note_Tot),0)



# --- Version 2
df <- filter(gfForetFpied_CodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,CodeEcolo,Nha,Gha,Vha) %>%
  mutate(CodeEcolo=str_replace(CodeEcolo,"0",""),
         CodeEcolo=toupper(CodeEcolo))

Niveaux <- unique(CodeEcolos$Code)
      Niveaux <- c(Niveaux,toupper(Niveaux))
      # ---- Decomposition
      NbCodes <-length(Niveaux)
      # df$CodeEcolo <- str_replace(df$CodeEcolo,"0","")
      # List <- c()
      df2 <- data.frame()
      for (i in 1:dim(df)[1]) {
        # List <- c(List,
        #           list(str_extract(df$CodeEcolo[i], Niveaux)[!is.na(str_extract(df$CodeEcolo[i], Niveaux))]))
                List <- list(str_extract(df$CodeEcolo[i], Niveaux)[!is.na(str_extract(df$CodeEcolo[i], Niveaux))])

                df_temp <- data.frame(Id=rep.int(df$CodeEcolo[i],
                                                 sapply(List, length)),
                                  CodeEcolo=unlist(List),
                                  # Note_Naturaliste=rep.int(NA,
                                  #                          sapply(List, length)),
                                  # Note_Chiroptere=rep.int(NA,
                                  #                         sapply(List, length)),
                                  # Note_Avifaune=rep.int(NA,
                                  #                       sapply(List, length)),
                                  # Note_Entomo=rep.int(NA,
                                  #                     sapply(List, length)),
                                  stringsAsFactors = F)
                df2 <- rbind(df2,df_temp)
      }
      df2 <- distinct(df2)
CodeEcolos <- mutate(CodeEcolos,
                     Code=toupper(Code))


Group_CodeEcolo_DF <- data.frame(Group_CodeEcolo=c("S","X",
                                                   "B","G","H","F","A",
                                                   "P","I","C","E","L",
                                                   "R","T","M","Y"),
                                 Group_CodeEcolo2=c("X","X",
                                                   "B","G","H","F","A",
                                                   "P","I","C","E","L",
                                                   "R","T","M","Y"),
                                 stringsAsFactors=F)
# df3 <- left_join(df2,CodeEcolos,
#                  by=c("CodeEcolo"="Code")) %>%
  # mutate(Mark_Branche=ifelse(str_sub(CodeEcolo,1,1) %in% c("S","X"),
  #                            1,0),
  #        Mark_Mousse=ifelse(str_sub(CodeEcolo,1,1) %in% c("B"),
  #                            1,0),
  #        Mark_Cavite=ifelse(str_sub(CodeEcolo,1,1) %in% c("G"),
  #                            1,0),
  #        Mark_Loge=ifelse(str_sub(CodeEcolo,1,1) %in% c("H"),
  #                            1,0),
  #        Mark_Fente=ifelse(str_sub(CodeEcolo,1,1) %in% c("F"),
  #                            1,0),
  #        Mark_Pic=ifelse(str_sub(CodeEcolo,1,1) %in% c("A"),
#                            1,0),
#        Mark_Pourriture=ifelse(str_sub(CodeEcolo,1,1) %in% c("P"),
#                            1,0),
#        Mark_Blessure=ifelse(str_sub(CodeEcolo,1,1) %in% c("I"),
#                            1,0),
#        Mark_Champi=ifelse(str_sub(CodeEcolo,1,1) %in% c("C"),
#                            1,0),
#        Mark_Ecorce=ifelse(str_sub(CodeEcolo,1,1) %in% c("E"),
#                            1,0),
#        Mark_Lichen=ifelse(str_sub(CodeEcolo,1,1) %in% c("L"),
#                            1,0),
#        Mark_Lierre=ifelse(str_sub(CodeEcolo,1,1) %in% c("R"),
#                            1,0),
#        Mark_Tete=ifelse(str_sub(CodeEcolo,1,1) %in% c("T"),
#                            1,0),
#        Mark_Mort=ifelse(str_sub(CodeEcolo,1,1) %in% c("M"),
#                            1,0),
#        Mark_BigBranche=ifelse(str_sub(CodeEcolo,1,1) %in% c("Y"),
#                               1,0)) %>%
df3 <- mutate(df2,
              Group_CodeEcolo=str_sub(CodeEcolo,1,1),
              Attrbt_CodeEcolo=str_sub(CodeEcolo,2,2),
              # Attrbt_CodeEcolo=ifelse(is.na(Attrbt_CodeEcolo),"",Attrbt_CodeEcolo),
              CountGroup_CodeEcolo=1) %>%
  left_join(Group_CodeEcolo_DF) %>%
  # group_by(Id) %>%
  # mutate(Note_Naturaliste=sum(Naturaliste),
  #        Note_Chiroptere=sum(Chiroptere),
  #        Note_Avifaune=sum(Avifaune),
  #        Note_Entomo=sum(Entomo)) %>%

  # Mark_Mousse=sum(Mark_Mousse),
  # Mark_Branche=sum(Mark_Branche),
  # Mark_Cavite=sum(Mark_Cavite),
  # Mark_Loge=sum(Mark_Loge),
  # Mark_Fente=sum(Mark_Fente),
# Mark_Pic=sum(Mark_Pic),
# Mark_Pourriture=sum(Mark_Pourriture),
# Mark_Blessure=sum(Mark_Blessure),
# Mark_Champi=sum(Mark_Champi),
# Mark_Ecorce=sum(Mark_Ecorce),
# Mark_Lichen=sum(Mark_Lichen),
# Mark_Lierre=sum(Mark_Lierre),
# Mark_Tete=sum(Mark_Tete),
# Mark_Mort=sum(Mark_Mort),
# Mark_BigBranche=sum(Mark_BigBranche)) %>%
group_by(Id,Group_CodeEcolo2) %>%
  mutate(CountGroup_CodeEcolo=sum(CountGroup_CodeEcolo),
         Attrbt_CodeEcolo2=ifelse(CountGroup_CodeEcolo > 1 & !is.na(Group_CodeEcolo2),
                                  max(Attrbt_CodeEcolo),
                                  Attrbt_CodeEcolo)) %>%
  ungroup() %>%
  mutate(CodeEcolo2=ifelse(CountGroup_CodeEcolo > 1 & !is.na(Group_CodeEcolo2),
                           paste0(Group_CodeEcolo2,Attrbt_CodeEcolo2),
                           CodeEcolo)) %>%
    select(Id,CodeEcolo2) %>%
  distinct() %>%
  left_join(CodeEcolos,
                 by=c("CodeEcolo2"="Code")) %>%
  group_by(Id) %>%
    mutate(Note_Naturaliste=sum(Naturaliste),
         Note_Chiroptere=sum(Chiroptere),
         Note_Avifaune=sum(Avifaune),
         Note_Entomo=sum(Entomo),


  Note_AFI=max(Note_Naturaliste,
               Note_Chiroptere,
               Note_Avifaune,
               Note_Entomo)) %>%
  ungroup() %>%
  select(Id,Note_AFI) %>%
  distinct()

NotesAFI_DF <- df3

      df4 <- left_join(df,df3,
                      by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=ifelse(is.na(Note_AFI),
                         0,Note_AFI*Nha))

Note_Totale <- round(sum(df4$Note_Tot),0)

NoteForte_Totale <- filter(gfForetFpied_CodeEcolo,
                  NumForet==forest_num & Cycle==last_cycle) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  select(NumForet,CodeEcolo,Nha) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(Note_AFI > 3) %>%
  mutate(Nha=Nha*Note_AFI)
NoteForte_Totale <- round(sum(NoteForte_Totale$Nha))


df <- filter(gfForetFpied_Reg2CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num & Gha > 0) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
    select(Cycle,Reg2,Gha,Note_AFI) %>%
  # filter(!is.na(Note_AFI)) %>%
  mutate(Population=ifelse(is.na(Note_AFI),
                           "Sans_Valeur",
                           ifelse(Note_AFI > 3,
                           "Valeur_Forte","Valeur")),
         Tot1_Gha=sum(Gha,na.rm=T)) %>%
  group_by(Population) %>%
  mutate(TotPopulation_Gha=sum(Gha,na.rm=T)) %>%
    group_by(Population,Reg2) %>%
    mutate(TotPopulationReg2_Gha=sum(Gha,na.rm=T)) %>%
  ungroup() %>%
    select(Population,Reg2,Tot1_Gha,TotPopulation_Gha,TotPopulationReg2_Gha) %>%
    distinct() %>%
    arrange(Population)


  # ----- Indices :
  # G Total :
G_Tot <- round(unique(df$Tot1_Gha),1)

# G arbres porteurs :
  Porteurs_DF <- filter(df,
                         Population!="Sans_Valeur") %>%
    # select(-one_of("Population","TotPopulationReg2_Gha")) %>%
    select(Reg2,TotPopulationReg2_Gha) %>%
    distinct()
G_Porteurs_Tot <- round(sum(Porteurs_DF$TotPopulationReg2_Gha),1)

# G arbres porteurs avec forte valeur écologique :
PorteursFort_DF <- filter(df,
                         Population=="Valeur_Forte") %>%
    # select(-one_of("Population","TotPopulationReg2_Gha")) %>%
    select(Reg2,TotPopulationReg2_Gha) %>%
    distinct()
G_PorteursFort_Tot <- round(sum(PorteursFort_DF$TotPopulationReg2_Gha),1)

# G arbres porteurs avec forte valeur écologique et bonne qualité :
PorteursFortQual_DF <- filter(df,
                         Population=="Valeur_Forte" &
                           Reg2=="A+B") %>%
    # select(-one_of("Population","TotPopulationReg2_Gha")) %>%
    select(Reg2,TotPopulationReg2_Gha) %>%
    distinct()
G_PorteursFortQual_Tot <- round(sum(PorteursFortQual_DF$TotPopulationReg2_Gha),1)


Indice1=round(Note_Totale/G_Tot,0)
Indice2=round(NoteForte_Totale/G_Tot,0)
Indice3=round(G_Porteurs_Tot*100/G_Tot,0)
Indice4=round(G_PorteursFort_Tot/G_Tot*100,0)
Indice5=round(G_PorteursFortQual_Tot/G_Tot*100,0)
@

La figure ci-dessous illustre la répartition des notes écologiques AFI, tirées de l'analyse de l'inventaire des dendromicrohabitats, entre les différentes essences.

\begin{figure}[H]
 \vspace{-3\baselineskip}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<Tab CompoNotesAFI, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", comment=NA, message=F, warning=FALSE, results='asis'>>=
# --- Répartition des valeurs écologiques par essences
df3 <- filter(gfForetFpied_EssenceCodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(Essence) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  select(Essence,Nha) %>%
  arrange(desc(Nha))

# --- Total 3
df_Tot3 <- filter(gfForetFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  mutate(Essence="\\rowcolor{LightGray} Total") %>%
  select(Essence,Nha)

pos3 <- dim(df3)[1]
ListPos3 <- list(pos3)

t3 <- rbind(df3,df_Tot3) %>%
  rename_("\\textbf{Essences}"="Essence",
          "\\textbf{Points/ha}"="Nha")


# ----- Impression -----
Digits=rep(0,dim(t3)[2]+1)

print(xtable(t3,
             digits=rep(0,dim(t3)[2]+1),
             align=c("M{0cm}|","|M{2.4cm}|",rep("M{2cm}|",dim(t3)[2]-1)),
             caption.placement = "bottom",
             caption = NULL,
             label = NULL),
      floating=F,
      hline.after=c(-1,0,c(1:dim(t3)[1])[-pos3]),
      sanitize.text.function=function(x){return(x)},
      include.rownames=FALSE,
      add.to.row=list(
        pos=ListPos3,
        command=rep("\\cmidrule[0.8pt]{1-2}",length(ListPos3))
        ),
      size="\\footnotesize")
@
\end{subfigure}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<CompoNote_Radar, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", fig.cap=NA, results='asis', comment=NA, message=F, warning=FALSE, out.width="6cm", fig.width=4>>=
df0 <- filter(gfForetFpied_EssenceCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Essence,CodeEcolo,Nha,Gha,Vha) %>%
  mutate(CodeEcolo=toupper(CodeEcolo))

# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))

df1 <- left_join(df0,NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Essence=factor(Essence,
                        levels=names(Palette_Essence)[length(Palette_Essence):1])) %>%
  group_by(NumForet,Essence) %>%
  summarise(Note_Tot=sum(Note_Tot,na.rm=T)) %>%
  ungroup() %>%
  arrange(desc(Essence)) %>%
  mutate(Tot=sum(Note_Tot,na.rm=T),
         Part=Note_Tot/Tot,
         Cumsum=cumsum(Part),
         Pos=Cumsum-Part/2) %>%
arrange(Essence)

ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Essence),
           stat="identity",position="fill",width=1) +
  geom_label(df1,
             mapping=aes("",Pos,label=ifelse(Part>0.06,
                                             paste0(round(Part*100,0)," %"),
                                             NA)),
             # position=position_dodge(width=1),
             label.padding = unit(0.15, "lines"),
             fill="white",
             size=3, alpha=1) +
  scale_fill_manual(name="Essences",
                    values=Palette_Essence) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=T)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain',size=9),
        plot.title=element_text(hjust=0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 9),
    axis.ticks = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.text = element_text(size = 8),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="bottom",
    legend.direction="horizontal",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    # plot.background = element_rect(fill="black"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())
@
 \end{subfigure}
 \vspace{-3\baselineskip}
\caption{Répartition des valeurs écologiques entre les essences}
\label{Compo_NoteAFI}
\end{figure}
\FloatBarrier

La figure ci-dessous illustre la répartition des notes écologiques AFI, tirées de l'analyse de l'inventaire des dendromicrohabitats, entre les différentes catégories de diamètre.

\begin{figure}[h]
 \vspace{-3\baselineskip}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<Tab_CatNotesEco, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", comment=NA, message=F, warning=FALSE, results='asis'>>=

# df <- filter(gfForetFpied_CatReg2CodeEcolo,
#               NumForet==forest_num & Cycle==last_cycle) %>%
#   select(NumForet,Cat,Reg2,CodeEcolo,Nha,Gha,Vha) %>%
#   left_join(NotesAFI_DF,
#             by=c("CodeEcolo"="Id")) %>%
#     mutate(Nha_Tot=Nha*Note_AFI,
#            Cat=factor(Cat,levels=c("PER","PB","BM","GB","TGB")),
#            Reg2=factor(Reg2,c("A+B","C+D"))) %>%
#   # mutate(Population=ifelse(is.na(Note_AFI),
#   #                          "Sans_Valeur",
#   #                          ifelse(Note_AFI > 3,
#   #                                 "Forte_Valeur",
#   #                                 "Avec_Valeur")),
#   #        Population=factor(Population,levels=c("Sans_Valeur",
#   #                                              "Avec_Valeur",
#   #                                              "Forte_Valeur"))) %>%
#   group_by(Cat,Reg2) %>%
#   summarise(Nha_Tot=sum(Nha_Tot,na.rm=T)) %>%
#   ungroup() %>%
#     arrange(Cat,Reg2) %>%
#     dcast(Cat ~ Reg2,
#           value.var="Nha_Tot")
#
# print(xtable(df,
#              # digits=rep(0,dim(t1)[2]+1),
#              digits=c(0,0,1,0,1,0),
#              align=c("M{0cm}|","M{1.2cm}",rep("|M{2cm}",dim(t1)[2]-1)),
#              caption = "Répartition des volumes prélevés et passés à la futaie par catégories de diamètre",
#              label   = "TabCat_Prelvt"),
#       caption.placement = "bottom",
#       hline.after=-1:dim(t1)[1],
#       sanitize.text.function=function(x){return(x)},
#       include.rownames=F,
#       size="\\footnotesize")




# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
t_Base <- filter(gfForetFpied_CatReg2CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(Cat,Reg2) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  group_by(Reg2) %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  ungroup() %>%
  mutate(Nha=paste0("\\footnotesize{",
                    Nha,
                    "} \\scriptsize{\\textcolor{CornflowerBlue}{(",
                    Part_Nha,
                    "\\%)}}"),
                    # ifelse(!is.na(Er_Nha),
                    #        paste0("\\textcolor{Gray}{±",
                    #               Er_Nha,
                    #               "\\%}}"),
                    #        "}")),
         Reg2=factor(Reg2,levels=c("A+B","C+D")),
         Cat=factor(Cat,levels=rev( names(colour_aes_for_diameter_category) ))) %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)

# --- Total
t_TOT1 <- filter(gfForetFpied_Reg2CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num & Gha > 0) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(Reg2) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  group_by(Reg2) %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  ungroup() %>%
  mutate(Nha=ifelse(Nha!=0,
                    paste0("\\textbf{\\footnotesize{",
                    Nha,
                    "} \\scriptsize{\\textcolor{CornflowerBlue}{(",
                    Part_Nha,
                    "\\%)}}}"),
                    ""),
                    # ifelse(!is.na(Er_Nha),
                    #        paste0("\\textcolor{Gray}{±",
                    #               Er_Nha,
                    #               "\\%}}"),
                    #        "}")),
         Reg2=factor(Reg2,levels=c("A+B","C+D")),
         Cat="\\rowcolor{LightGray} \\textbf{Total par qualités}") %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)

# -- Total des essences (colonne total en bout de tableau)
t_TOT2 <- filter(gfForetFpied_CatCodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(Cat) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  # ungroup() %>%
  mutate(Nha=ifelse(Nha!=0,
                    paste0("\\cellcolor{LightGray} \\textbf{\\footnotesize{",
                    Nha,
                    "} \\scriptsize{\\textcolor{Brown}{(",
                    Part_Nha,
                    "\\%)}}}"),
                    "\\cellcolor{LightGray}"),
         Reg2="\\cellcolor{LightGray} \\textbf{Total par catégories}") %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)

# -- Total des totaux
t_TOT3 <- filter(gfForetFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by() %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  mutate(Nha=ifelse(Nha!=0,
                    paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{\\footnotesize{",
                    Nha,
                    "} \\scriptsize{(",
                    Part_Nha,
                    "\\%)}}}"),
                    "\\cellcolor{DimGray}"),
         Cat="\\rowcolor{LightGray} \\textbf{Total par qualités}",
         Reg2="\\cellcolor{LightGray} \\textbf{Total par catégories}") %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)


# --- Total pour arbres dont valeur écolo > 3
t_TOT4 <- filter(gfForetFpied_Reg2CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num & Gha > 0) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI,
         Population=ifelse(Note_AFI > 3,
                           "Valeur_Forte","Valeur"),
         Tot_Nha=sum(Nha,na.rm=T)) %>%
  group_by(Population,Reg2,Tot_Nha) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         # Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  filter(Population=="Valeur_Forte") %>%
  mutate(Nha=ifelse(Nha!=0,
                    paste0("\\footnotesize{",
                    Nha,
                    "} \\scriptsize{\\textcolor{DarkViolet}{(",
                    Part_Nha,
                    "\\%)}}"),
                    ""),
                    # ifelse(!is.na(Er_Nha),
                    #        paste0("\\textcolor{Gray}{±",
                    #               Er_Nha,
                    #               "\\%}}"),
                    #        "}")),
         Reg2=factor(Reg2,levels=c("A+B","C+D")),
         Cat="dont note écolo > 3") %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)

# -- Total toutes qualités confondues
t_TOT5 <- filter(gfForetFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI,
         Population=ifelse(Note_AFI > 3,
                           "Valeur_Forte","Valeur"),
         Tot_Nha=sum(Nha,na.rm=T)) %>%
  group_by(Population,Tot_Nha) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  mutate(Nha=round(Nha,0),

         # Er_Nha=round(Er_Nha,1),

         # Tot_Nha=sum(Nha,na.rm=T),

         Part_Nha=round(Nha/Tot_Nha*100,0)) %>%
  filter(Population=="Valeur_Forte") %>%
  mutate(Nha=ifelse(Nha!=0,
                    paste0("\\cellcolor{LightGray} \\textbf{\\footnotesize{",
                    Nha,
                    "} \\scriptsize{\\textcolor{DarkViolet}{(",
                    Part_Nha,
                    "\\%)}}}"),
                    ""),
                    # ifelse(!is.na(Er_Nha),
                    #        paste0("\\textcolor{Gray}{±",
                    #               Er_Nha,
                    #               "\\%}}"),
                    #        "}")),
         Reg2="\\cellcolor{LightGray} \\textbf{Total par catégories}",
         Cat="dont note écolo > 3") %>%
  select(Cat,Reg2,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  arrange(Cat,Reg2)

t_Base <- rbind(t_Base,t_TOT1,t_TOT2,t_TOT3,t_TOT4,t_TOT5)
# t_Base2 <- rbind(t_Base,t_TOT2)



t1 <- dcast(t_Base,
            Cat ~ Reg2,
          value.var="Nha") %>%
  rename_("Catégories"="Cat")

pos <- which(t1[,"Catégories"]=="dont note écolo > 3")-1
if (length(pos) > 0) {
ListPos <- list(pos)
Command <- rep("\\cmidrule[0.8pt]{1-4}",length(ListPos))
} else {
  pos <- dim(t1)[1]
  ListPos <- list(dim(t1)[1])
  Command <- "\\hline"
}
# ----- Impression -----
Digits=rep(0,dim(t1)[2]+1)

Title <- paste0("Répartition des points écologiques par catégories et qualité")

print(xtable(t1,
             caption=NULL,
             caption.placement="bottom",
             digits=Digits,
             align=c("M{0cm}|","|M{2cm}|",rep("M{1.8cm}|",dim(t1)[2]-1)),
             label = "TabMoyDisp_CatReg2CodeEcolo"),
      hline.after=c(-1,0,c(1:dim(t1)[1])[-pos]),
      sanitize.text.function=function(x){return(x)},
      include.rownames=FALSE,
      floating=F,
      add.to.row=list(
        pos=ListPos,
        command=Command),
      size="\\scriptsize")
@
\end{subfigure}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<CatNote_Radar, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", fig.cap=NA, results='asis', comment=NA, message=F, warning=FALSE, out.width="6cm", fig.width=4>>=
# , out.height="6cm"
# "Répartition de la note AFI par essence"
df0 <- filter(gfForetFpied_CatCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Cat,CodeEcolo,Nha,Gha,Vha) %>%
  mutate(CodeEcolo=toupper(CodeEcolo))

# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))

df1 <- left_join(df0,NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Cat=factor(Cat,levels=names(colour_aes_for_diameter_category))) %>% # [length(Palette_Cat):1]
  group_by(NumForet,Cat) %>%
  summarise(Note_Tot=sum(Note_Tot,na.rm=T)) %>%
  ungroup() %>%
  arrange(desc(Cat)) %>%
  mutate(Tot=sum(Note_Tot,na.rm=T),
         Part=Note_Tot/Tot,
         Cumsum=cumsum(Part),
         Pos=Cumsum-Part/2) %>%
arrange(Cat)



ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Cat),
           stat="identity",position="fill",width=1) +
  geom_label(df1,
             mapping=aes("",Pos,label=ifelse(Part>0.06,
                                             paste0(round(Part*100,0)," %"),
                                             NA)),
             # position=position_dodge(width=1),
             label.padding = unit(0.15, "lines"),
             fill="white",
             size=3, alpha=1) +
  scale_fill_manual(name="Catégories de diamètre",
                    values=colour_aes_for_diameter_category) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=T)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain',size=9),
        plot.title=element_text(hjust=0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 9),
    axis.ticks = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.text = element_text(size = 8),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="bottom",
    legend.direction="horizontal",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    # plot.background = element_rect(fill="black"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())
@


<<CatNote_Radar-todo, eval = F, include = F, fig.cap = NA, results = 'asis', out.width = "6cm", fig.width = 6>>=
Nouvelle version à mettre en place (manque table gfForetBMP_CatCodeEcolo)

# -- table
# "Répartition de la note AFI par essence"
df0 <- bind_rows(
  gfForetFpied_CatCodeEcolo,
  gfForetBMP_CatCodeEcolo
  ) %>%
  filter(Cycle == last_cycle & NumForet == forest_num & Cat != "PER") %>%
  select(NumForet, Cat, CodeEcolo, Nha, Gha, Vha)

df1 <- left_join(
  df0, NotesAFI_DF,
  by = c("CodeEcolo" = "Id")
) %>%
  mutate(
    Note_Tot = Note_AFI * Nha,

    # translate Cat
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = names(colour_aes_for_diameter_category))
    # Cat = factor(Cat, levels = i18n()$t(c("TGB", "GB", "BM", "PB"))) # names(colour_aes_for_diameter_category) # [length(colour_aes_for_diameter_category):1]
  ) %>%
  group_by(NumForet, Cat) %>%
  summarise(Note_Tot = sum(Note_Tot, na.rm = T)) %>%
  ungroup() %>%
  arrange(desc(Cat)) %>%
  mutate(
    Tot = sum(Note_Tot, na.rm = T),
    Part = Note_Tot / Tot,
    Cumsum = cumsum(Part),
    Pos = Cumsum - Part / 2
  ) %>%
  arrange(Cat)


# -- plot
ggplot() +
  geom_bar(
    df1,
    mapping = aes("", Note_Tot, fill = Cat),
    stat = "identity", position = "fill", width = 1
  ) +
  geom_label(
    df1,
    mapping = aes(
      "", Pos,
      label = ifelse(
        Part > 0.06,
        paste0(round(Part * 100, 0), " %"),
        NA)
    ),
    label.padding = unit(0.15, "lines"),
    fill = "white",
    size = 5, alpha = 1
  ) +
  scale_fill_manual(
    name = i18n()$t("Catégories de diamètre"),
    values = colour_aes_for_diameter_category
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  coord_polar(theta = "y") +
  guides(fill = guide_legend(reverse = T)) +
  theme_bw() + MyTheme +
  theme(
    title = element_text(face = 'plain', size = 13),
    plot.title = element_text(hjust = 0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 12),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.text = element_text(size = 13),
    legend.position = "bottom",
    legend.direction = "horizontal",
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border = element_blank()
  )
@

 \end{subfigure}
 \vspace{-3\baselineskip}
\caption{Répartition des valeurs écologiques entre les catégories de diamètre}
\label{Cat_NoteAFI}
\end{figure}
\FloatBarrier


Les éléments de la figure \ref{Tab_NotesEco_Plac} représentent la répartition des notes écologiques AFI, tirées de l'analyse de l'inventaire des dendromicrohabitats, entre les différentes placettes et entre les différentes classes.
\begin{figure}[H]
 % \vspace{-3\baselineskip}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<Boxplot_NotesEco_Plac, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", comment=NA, message=F, warning=FALSE, results='asis', fig.height=5>>=


df1 <- filter(gfPlaFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(NumPlac) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  select(NumPlac,Nha) %>% #,VhaIFN # Nha,Nha,Vha,AcctG,AcctV,VcHa,VpHa,Gain
  # full_join(t) %>%
  mutate(NumPlac=as.numeric(NumPlac)) %>%
  arrange(NumPlac)

# --- Total 1
df_Tot1 <- filter(gfForetFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  mutate(NumPlac="\\rowcolor{LightGray} Moyenne") %>%
  select(NumPlac,Nha)

pos1 <- dim(df1)[1]
ListPos1 <- list(pos1)

t1 <- rbind(df1,df_Tot1) %>%
  rename_("\\textbf{Placettes}"="NumPlac",
          "\\textbf{Points/ha}"="Nha")


# --- Répartition des valeurs écologiques par classes de diamètre
df2 <- filter(gfForetFpied_ClasseCodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  group_by(Classe) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  ungroup() %>%
  select(Classe,Nha)

# --- Total 2
df_Tot2 <- filter(gfForetFpied_CodeEcolo,
             Cycle == last_cycle & NumForet == forest_num) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  filter(!is.na(Note_AFI)) %>%
  mutate(Nha=Nha*Note_AFI) %>%
  summarise(Nha=sum(Nha,na.rm=T)) %>%
  mutate(Classe="\\rowcolor{LightGray} Total") %>%
  select(Classe,Nha)

pos2 <- dim(df2)[1]
ListPos2 <- list(pos2)

t2 <- rbind(df2,df_Tot2) %>%
  rename_("\\textbf{Classes de diamètre}"="Classe",
          "\\textbf{Points/ha}"="Nha")

# # --- Répartition des valeurs écologiques par essences
# df3 <- filter(gfForetFpied_EssenceCodeEcolo,
#              Cycle == last_cycle & NumForet == forest_num) %>%
#   left_join(NotesAFI_DF,
#             by=c("CodeEcolo"="Id")) %>%
#   filter(!is.na(Note_AFI)) %>%
#   mutate(Nha=Nha*Note_AFI) %>%
#   group_by(Essence) %>%
#   summarise(Nha=sum(Nha,na.rm=T)) %>%
#   ungroup() %>%
#   select(Essence,Nha)
#
# # --- Total 3
# df_Tot3 <- filter(gfForetFpied_CodeEcolo,
#              Cycle == last_cycle & NumForet == forest_num) %>%
#   left_join(NotesAFI_DF,
#             by=c("CodeEcolo"="Id")) %>%
#   filter(!is.na(Note_AFI)) %>%
#   mutate(Nha=Nha*Note_AFI) %>%
#   summarise(Nha=sum(Nha,na.rm=T)) %>%
#   mutate(Essence="\\rowcolor{LightGray} Total") %>%
#   select(Essence,Nha)
#
# pos3 <- dim(df3)[1]
# ListPos3 <- list(pos3)
#
# t3 <- rbind(df3,df_Tot3) %>%
#   rename_("\\rowcolor{CornflowerBlue} \\textbf{Essences}"="Essence",
#           "\\textbf{Pointsha}"="Nha")


# ----- Impression -----
# Digits=rep(0,dim(t1)[2]+1)
#
#
# cat("\\begin{table}[h]
#     \\centering")
# print(xtable(t1,
#              digits=rep(0,dim(t1)[2]+1),
#              align=c("M{0cm}|","|M{2.4cm}|",rep("M{2cm}|",dim(t1)[2]-1)),
#              caption.placement = "bottom",
#              caption = NULL,
#              label = NULL),
#       floating=F,
#       hline.after=c(-1,0,c(1:dim(t1)[1])[-pos1]),
#       sanitize.text.function=function(x){return(x)},
#       include.rownames=FALSE,
#       add.to.row=list(
#         pos=ListPos1,
#         command=rep("\\cmidrule[0.8pt]{1-2}",length(ListPos1))
#         ),
#       size="\\footnotesize")
# cat("\\hspace{2cm}")

df1.m <- melt(df1,
              id="NumPlac") %>%
  mutate(variable=paste0(plot_nb," placettes"))

# cat("\\begin{figure}[H]
#  \\vspace{-3\\baselineskip}
# \\begin{subfigure}[c]{0.49\\textwidth}
# \\centering
# ")
ggplot() +
  geom_boxplot(df1.m,mapping=aes(variable,value),
               width=0.5) +
  scale_y_continuous(limits=c(0,max(df1.m$value,na.rm=T)*1.1),
                     breaks=seq(0,max(df1.m$value,na.rm=T)*1.1,
                                250),
                     expand=c(0,0),
                     name="(Points/ha)") +
    # scale_x_continuous(limits=c(0.5,1.5),
    #                  breaks=paste0(plot_nb," placettes"),
    #                  expand=c(0,0)) +
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_text(size=15,colour="navy"), #element_text(hjust=1,angle=0)
        axis.ticks.x=element_blank(),
        axis.line.x=element_blank(),
        axis.text.x=element_text(size=15,colour="springgreen4"),
        axis.text.y=element_text(size=13,colour="navy"))
@
\end{subfigure}
\begin{subfigure}[c]{0.49\textwidth}
\centering
<<Tab_NotesEco_Plac, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", comment=NA, message=F, warning=FALSE, results='asis'>>=
print(xtable(t2,
             digits=rep(0,dim(t2)[2]+1),
             align=c("M{0cm}|","|M{2.4cm}|",rep("M{2cm}|",dim(t2)[2]-1)),
             caption.placement = "bottom",
             caption = NULL,
             label = NULL),
      floating=F,
      hline.after=c(-1,0,c(1:dim(t2)[1])[-pos2]),
      sanitize.text.function=function(x){return(x)},
      include.rownames=FALSE,
      add.to.row=list(
        pos=ListPos2,
        command=rep("\\cmidrule[0.8pt]{1-2}",length(ListPos2))
        ),
      size="\\footnotesize")



# cat("\\end{subfigure}
#  \\vspace{-3\\baselineskip}
# \\caption{Répartition des points écologiques par placettes et classes de diamètre}
# \\label{Tab_NotesEco_Plac}
# \\end{figure}
# \\FloatBarrier
# ")

# cat("~")
# print(xtable(t3,
#              digits=rep(0,dim(t3)[2]+1),
#              align=c("M{0cm}|","|M{2.4cm}|",rep("M{2cm}|",dim(t3)[2]-1)),
#              caption.placement = "bottom",
#              caption = NULL,
#              label = NULL),
#       floating=F,
#       hline.after=c(-1,0,c(1:dim(t3)[1])[-pos3]),
#       sanitize.text.function=function(x){return(x)},
#       include.rownames=FALSE,
#       add.to.row=list(
#         pos=ListPos3,
#         command=rep("\\cmidrule[0.8pt]{1-2}",length(ListPos3))
#         ),
#       size="\\footnotesize")


# cat("\\caption{Répartition des points écologiques par placettes et classes de diamètre}
# \\label{Tab_NotesEco_Plac}
#     \\end{table}")
@
\end{subfigure}
 % \vspace{-3\baselineskip}
\caption{Répartition des points écologiques par placettes et classes de diamètre}
\label{Tab_NotesEco_Plac}
\end{figure}
\FloatBarrier

La note écologique totale est de \textbf{\Sexpr{Note_Totale} points/ha}, dont \textbf{\Sexpr{NoteForte_Totale} points/ha} représentant la part des notes écologique > 3, soit \textbf{\Sexpr{round(NoteForte_Totale/Note_Totale*100,0)} \%}.\\
Indices synthétiques :
\begin{itemize}[label=-]
\item Rapport Note Ecolo sur G/ha : \textbf{\Sexpr{Indice1}}
\item Rapport Note Ecolo > 3 sur G/ha : \textbf{\Sexpr{Indice2}}
\item Individus avec critère écologique particulier : \textbf{\Sexpr{Indice3} \%}
\item Individus avec forte valeur écologique : \textbf{\Sexpr{Indice4} \%}
\item Individus avec forte valeur écologique et forte valeur économique : \textbf{\Sexpr{Indice5} \%}
\end{itemize}


% \textcolor{red}{Propositions de figures en attendant. Mettre à plat la méthode de calcul de la note AFI... Pour l'instant cumul des notations (x3s3 ou b1b2) limité : on prend le plus élevé. A améliorer (si on a s6x3 on revient à une note pour x6 - change rien pour l'instant mais à réfléchir)}

<<NotesEco_AFI2, echo=F, include=F, eval=F, fig.pos="H", fig.height=3, fig.width=3, fig.cap= "Compte des DMH vs densités de tiges de chaque catégorie de diamètre", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetFpied_CatCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,CodeEcolo,Cat,Nha)

# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))

df1 <- left_join(df0,NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=Note_AFI*Nha) %>%
  group_by(NumForet,Cat) %>%
  summarise(Note_Tot=sum(Note_Tot,na.rm=T)) %>%
  ungroup()

# --- Valeurs
df2 <- filter(gfForetFpied_Cat,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Cat,Nha) %>%
  mutate(Cat=factor(Cat,levels=names(colour_aes_for_diameter_category))) %>% #c("TGB","GB","BM","PB","PER")
  arrange(Cat)

ggplot() +
  geom_bar(df2,
           mapping=aes(Cat,Nha),
           stat="identity",position="identity") +
  geom_line(df1,
            mapping=aes(x=Cat,y=Note_Tot,group=1),
            colour="red") +
  theme_bw() + MyTheme
@
\FloatBarrier
% Figure \ref{fig:NotesEco_AFI2} : note obtenue en prenant l'occurence de chaque DMH (densité) et en multipliant par la note AFI que ces DMH représentent respectivement
\FloatBarrier

<<NotesEco_AFI3_Ancien, echo=F, include=F, eval=F, fig.pos="H", fig.height=3, fig.cap= "Comparaison des densités d'arbres porteurs de DMH vs arbres non porteurs de DMH", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetFpied_ClasseCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Classe,CodeEcolo,Nha) %>%
  mutate(Mark=NA,
         Mark=ifelse(is.na(CodeEcolo),
                     0,1),
         Mark=factor(Mark,levels=c(0,1))) %>%
  group_by(NumForet,Classe,Mark) %>%
  summarise(Nha=sum(Nha)) %>%
  ungroup() %>%
  arrange(Classe,Mark)

Y=group_by(df0,Classe) %>%
  summarise(Nha=sum(Nha)) %>%
  ungroup() %>%
  filter(Nha==max(Nha)) %>%
  select(Nha) %>%
  unlist()


ggplot() +
  geom_bar(df0,
           mapping=aes(Classe,Nha,fill=Mark),
           stat="identity",position="stack") +
  scale_fill_manual(name="",
                    values=c("forestgreen","dodgerblue"),
                    label=c("arbres sans DMH",
                            "arbre porteur\nde DMH")) +
  scale_y_continuous(limits=c(0,Y*1),
                     breaks=seq(0,Y*1.3,5)) +
  theme_bw() + MyTheme
@

<<NotesEco_AFI4, echo=F, include=F, eval=F, fig.pos="H", fig.height=3, fig.cap= "Comparaison des densités d'arbres porteurs de DMH vs arbres non porteurs de DMH", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetFpied_ClasseReg1CodeEcolo,
             NumForet==forest_num & Cycle==last_cycle &
               Reg1 %in% c("A","B") & Gha > 0) %>%
  select(NumForet,Classe,CodeEcolo,Gha) %>%
  mutate(Mark=NA,
         Mark=ifelse(is.na(CodeEcolo),
                     0,1),
         Mark=factor(Mark,levels=c(0,1))) %>%
  group_by(NumForet,Classe,Mark) %>%
  summarise(Gha=sum(Gha)) %>%
  ungroup() %>%
  arrange(Classe,Mark)

df2 <- filter(gfForetFpied_Classe,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Classe,Gha) %>%
  arrange(Classe) %>%
  melt(id=c("NumForet","Classe"))

df3 <- filter(gfForetFpied_Classe,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Classe,Gha) %>%
  mutate(label="G moyenne") %>%
  arrange(Classe)

Y=group_by(df2,Classe) %>%
  summarise(value=sum(value)) %>%
  ungroup() %>%
  filter(value==max(value)) %>%
  select(value) %>%
  unlist()
X=max(df2$Classe)
Xmin=min(df2$Classe)

ggplot() +
  geom_bar(df0,
           mapping=aes(Classe,Gha,fill=Mark),
           stat="identity",position="stack") +
  geom_line(df3,
            mapping=aes(Classe,Gha,colour=label)) +
  scale_x_continuous(limits=c(17,X*1.1),
                     breaks=seq(20,X*1.3,5),
                     expand=c(0,0)) +
  scale_y_continuous(limits=c(0,Y*1),
                     breaks=seq(0,Y*1.3,0.5)) +
  scale_fill_manual(name="",
                    values=c("forestgreen","dodgerblue"),
                    label=c("arbres sans DMH",
                            "arbre porteur\nde DMH")) +
  scale_colour_manual(values="red") +
  guides(colour=guide_legend(title="")) +
  theme_bw() + MyTheme
@
\FloatBarrier

<<NotesEco_AFI5_Ancien, echo=F, include=F, eval=F, fig.pos="H", fig.height=3, fig.cap= "Répartition de la note AFI par catégories de diamètre et par essences", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetCodes_CatCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Cat,CodeEcolo,Nha,Gha,Vha)

df_Codes <- mutate(CodeEcolos,
                   Code=toupper(Code))

df1 <- left_join(df0,df_Codes,
            by=c("CodeEcolo"="Code")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Cat=factor(Cat,levels=names(Palette_Cat)[length(Palette_Cat):1])) %>%
  group_by(NumForet,Cat) %>%
  summarise(Note_Tot=sum(Note_Tot)) %>%
  ungroup()



p1 <- ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Cat),
           stat="identity",position="fill",width=1) +
  scale_fill_manual(name="Catégories de diamètre",
                    values=Palette_Cat) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=T)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain'),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x=element_text(face='plain',size=9),
    legend.text = element_text(size = 7),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="right",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())



df0 <- filter(gfForetCodes_EssenceCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Essence,CodeEcolo,Nha,Gha,Vha)

df_Codes <- mutate(CodeEcolos,
                   Code=toupper(Code))

df1 <- left_join(df0,df_Codes,
            by=c("CodeEcolo"="Code")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Essence=factor(Essence,
                        levels=names(Palette_Essence)[length(Palette_Essence):1])) %>%
  group_by(NumForet,Essence) %>%
  summarise(Note_Tot=sum(Note_Tot)) %>%
  ungroup()

p2 <- ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Essence),
           stat="identity",position="fill",width=1) +
  scale_fill_manual(name="Essences",
                    values=Palette_Essence) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=T)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain'),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x=element_text(face='plain',size=9),
    legend.text = element_text(size = 7),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="right",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())

grid.arrange(p1,p2,
             nrow=1,widths=rep(1,2))
@

<<NotesEco_AFI5, echo=F, include=F, eval=F, fig.pos="H", fig.height=3, fig.cap= "Répartition de la note AFI par catégories de diamètre et par essences", comment=NA, message=F, warning=FALSE>>=

df0 <- filter(gfForetFpied_CatCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Cat,CodeEcolo,Nha,Gha,Vha)

# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))

df1 <- left_join(df0,NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Cat=factor(Cat,levels=names(Palette_Cat))) %>% # [length(Palette_Cat):1]
  group_by(NumForet,Cat) %>%
  summarise(Note_Tot=sum(Note_Tot,na.rm=T)) %>%
  ungroup()



p1 <- ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Cat),
           stat="identity",position="fill",width=1) +
  scale_fill_manual(name="Catégories de diamètre",
                    values=Palette_Cat) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=F)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain',size=7),
        plot.title=element_text(hjust=0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.text = element_text(size = 6),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="bottom",
    legend.direction="horizontal",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())



df0 <- filter(gfForetFpied_EssenceCodeEcolo,
             NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Essence,CodeEcolo,Nha,Gha,Vha)

# df_Codes <- mutate(CodeEcolos,
#                    Code=toupper(Code))

df1 <- left_join(df0,NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Note_Tot=Note_AFI*Nha,
         Essence=factor(Essence,
                        levels=names(Palette_Essence)[length(Palette_Essence):1])) %>%
  group_by(NumForet,Essence) %>%
  summarise(Note_Tot=sum(Note_Tot,na.rm=T)) %>%
  ungroup()

p2 <- ggplot() +
  geom_bar(df1,
           mapping=aes("",Note_Tot,fill=Essence),
           stat="identity",position="fill",width=1) +
  scale_fill_manual(name="Essences",
                    values=Palette_Essence) +
  scale_y_continuous(labels=percent) +
  coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=T)) +
  theme_bw() + MyTheme +
  theme(title=element_text(face='plain',size=7),
        plot.title=element_text(hjust=0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.text = element_text(size = 6),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="bottom",
    legend.direction="horizontal",
    # legend.title=element_text(size = 7),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border=element_blank())

grid.arrange(p1,p2,
             nrow=1,widths=rep(1,2))
@
\FloatBarrier

La figure \ref{fig:NotesEco_AFI6}, représente pour chaque classe de diamètre la répartition de la surface terrière totale entre trois populations :
\begin{itemize}[label=-]
\item les arbres sans valeur écologique particulière (sans dendromicrohabitats)
\item les arbres possédant une valeur écologique (au moins 1 DMH)
\item les arbres ayant une forte valeur écologique (note $\geqslant$ 3)
\end{itemize}

<<NotesEco_AFI6, echo=F, eval=eval_dmh, include=eval_dmh, fig.pos="H", fig.height=2.5, fig.cap= "Répartition de la surface terrière en fonction de la valeur écologique", comment=NA, message=F, warning=FALSE>>=

df <- filter(gfForetFpied_ClasseCodeEcolo,
              NumForet==forest_num & Cycle==last_cycle) %>%
  select(NumForet,Classe,CodeEcolo,Nha,Gha,Vha) %>%
  mutate(CodeEcolo=toupper(CodeEcolo)) %>%
  left_join(NotesAFI_DF,
            by=c("CodeEcolo"="Id")) %>%
  mutate(Population=ifelse(is.na(Note_AFI),
                           "Sans_Valeur",
                           ifelse(Note_AFI > 3,
                                  "Forte_Valeur",
                                  "Avec_Valeur")),
         Population=factor(Population,levels=c("Sans_Valeur",
                                               "Avec_Valeur",
                                               "Forte_Valeur"))) %>%
  group_by(Classe,Population) %>%
  summarise(Gha_Tot=sum(Gha,na.rm=T)) %>%
  ungroup()

tab_lim <- group_by(df,
                    Classe) %>%
  summarise(G=sum(Gha_Tot,na.rm=T)) %>%
  ungroup()

X=max(df$Classe)
Y=max(tab_lim$G)
Y=ifelse(Y==0,
         10,Y)
# value_by <- ifelse(Y>=5000,
#                    1000,Y/10)
# if (Y >= 1000) {
by_VALUE <- floor(((Y/8+Y/15)/2)/100+0.5)*100
# }
if (Y < 650) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/50+0.5)*50
}
if (Y < 325) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/25+0.5)*25
}
if (Y < 130) {
by_VALUE <- floor(((Y/8+Y/15)/2)/10+0.5)*10
}
if (Y < 65) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/5+0.5)*5
  by_VALUE <- ifelse(by_VALUE==0,
                     5,by_VALUE)
}
if (Y < 40) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/3+0.5)*3
  by_VALUE <- ifelse(by_VALUE==0,
                     3,by_VALUE)
}
if (Y < 27) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/2+0.5)*2
  by_VALUE <- ifelse(by_VALUE==0,
                     2,by_VALUE)
}
if (Y <= 13) {
  by_VALUE <- 1
}
by_VALUE <- ifelse(Y <= 6.5,
                   0.5,1)

  ggplot() +
  geom_bar(df,
           mapping=aes(Classe,Gha_Tot,fill=Population),
           stat="identity",position="stack",
           colour="black") +
  scale_fill_manual(name="",
                    values=c("Gray90","olivedrab3","green3"),
                    label=c("Sans valeur écologique\nparticulière",
                            "Avec valeur écologique",
                            "Avec forte valeur écologique\n(Note > 3)")) +
  # scale_y_continuous(name="G (m2/ha)") +
    scale_y_continuous(name="G (m2/ha)",
                     limits=c(0,Y*1.1),
                     breaks=seq(0,Y*1.3,by_VALUE)) +
    scale_x_continuous(limits=c(17,X*1.1),
                     breaks=seq(20,X*1.3,5),
                     expand=c(0,0)) +
  # coord_polar(theta="y") +
  # scale_colour_manual(values="red") +
  guides(fill=guide_legend(reverse=F)) +
  theme_bw() + MyTheme
@
\FloatBarrier

}{}

\section{Bois mort}

\EditIf{\Sexpr{eval_BM}}{TRUE}{

\subsection{Répartition du bois mort}

Le tableau \ref{species-deadwood_types_distribution_table} illustre la répartition du bois mort par essences et par catégories de diamètre. Il est complété par les figures \ref{fig:diam_classe-deadwood_bar_chart} et \ref{fig:deadwood_pie_chart}.

<<species-deadwood_types_distribution_table, results='asis', eval=eval_BM, eval=eval_BM>>=
# -- build print_table (call 'set_up_results_by_2_attributes_table')
results_with_attribute1_and_attribute2 <-
  gfForetBM_Essence %>%
  # select
  select(
    NumForet, Cycle, Essence,
    Vha_BMSinf, Vha_BMSsup, Vha_BMPinf, Vha_BMPsup
  ) %>%

  # pivot
  pivot_longer(
    cols = -c("NumForet", "Cycle", "Essence"),
    names_to = "deadwood_type",
    values_to = "Vha"
  )
attribute1 <- "Essence" # row attribute
attribute2 <- "deadwood_type" # column attribute
attribute1_levels <- deadwood_species_order
attribute2_levels <-
  c("Vha_BMSinf", "Vha_BMSsup", "Vha_BMPinf", "Vha_BMPsup")
var <- "Vha"
attribute1_name <- i18n()$t("Essences")
attribute1_total_label <- i18n()$t("\\textbf{Total par essence}")
attribute2_total_label <- i18n()$t("\\textbf{Total par type}")

print_table <- set_up_results_by_2_attributes_table(
  results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
  forest_num = forest_num,
  last_cycle = last_cycle,
  attribute1 = attribute1,
  attribute2 = attribute2,
  var = var,
  attribute1_name = attribute1_name,
  attribute1_levels = attribute1_levels,
  attribute2_levels = attribute2_levels,
  attribute1_total_label = attribute1_total_label,
  attribute2_total_label = attribute2_total_label,

  hold_print = T
)

# -- table names
table_names <- c(
  # Essence
  paste0(
    "\\hline\n\\multirow{2}{*}{\\parbox{1.6cm}{\\centering \\textbf{",
    i18n()$t("Essence"),
    "}}}"
  ),

  # BM types
  paste0(
    "\\multicolumn{2}{c|}{\\textbf{", i18n()$t("Bois mort au sol"), "}}"
  ),
  paste0(
    "\\multicolumn{2}{c|}{\\textbf{", i18n()$t("Bois mort sur pied"), "}}"
  ),
  paste0(
    "\\multirow{2}{*}{\\parbox{2cm}{\\centering \\textbf{", i18n()$t("Bois mort total"), " \\scriptsize{(m3/ha)}}}}\\\\\n"
  )
)
table_names <- paste0( paste0(table_names, collapse = " & ") , "\n\\cline{2-5}\n")

names(print_table) <- c(
  " ",
  "< 30 cm \\scriptsize{(m3/ha)}",
  "$\\geqslant$ 30 cm \\scriptsize{(m3/ha)}",
  "< 30 cm \\scriptsize{(m3/ha)}",
  "$\\geqslant$ 30 cm \\scriptsize{(m3/ha)}",
  " "
)

Digits = rep(0, ncol(print_table) + 1)
print(
  xtable(
    print_table,
    digits = Digits,
    align = c("M{0cm}", "|M{1.6cm}|", rep("M{2cm}|", dim(print_table)[2] - 1)),
    caption = i18n()$t("Répartition du volume de bois mort par essence et par type"),
    label = "species-deadwood_types_distribution_table"
  ),
  caption.placement = "bottom",
  hline.after = 0:dim(print_table)[1],
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  add.to.row = list(
    pos = list(-1),
    command = table_names),
  table.placement="H",
  size = "\\footnotesize"
)
@
\FloatBarrier


<<diam_classe-deadwood_bar_chart, size = 'footnotesize', fig.pos = 'H', fig.height = 3.5, fig.cap = i18n()$t("Répartition du volume de bois mort sur pied et du volume de bois mort au sol par classe de diamètre"), eval = eval_BM, include = eval_BM>>=

# -- plot table
plot_table <- filter(
  gfForetBM_Classe,
  NumForet == forest_num & Cycle == last_cycle &
  Vha_total != 0
) %>%
  mutate(
    BMS = Vha_BMSinf + Vha_BMSsup,
    BMP = Vha_BMPinf + Vha_BMPsup
  ) %>%
  select(Classe, BMP, BMS) %>%
  pivot_longer(cols = -c("Classe"), names_to = "variable") %>%
  mutate(
    value = ifelse(is.na(value), 0, value),

    # translate deadwood
    variable = case_when(
      variable == "BMP" ~ i18n()$t("Bois mort sur pied"),
      variable == "BMS" ~ i18n()$t("Bois mort au sol")
    ),
    variable = factor(variable, levels = names(colour_aes_for_deadwood))
  ) %>%
  complete(variable)


# -- plot settings
X <- ifelse(max(plot_table$Classe) < 60, 60, max(plot_table$Classe))
Y <-
  plot_table %>% group_by(Classe) %>% mutate(Max = sum(value)) %>% ungroup()
Y = max(Y$value, na.rm = T)
Y = ifelse(Y != 0, Y, 5)
by_VALUE <- ifelse(Y <= 6.5, 0.5, 1)


# -- plot
ggplot()  +
  geom_bar(
    plot_table,
    mapping = aes(Classe, value, fill = variable),
    stat = "identity", position = "stack"
  )  +
  scale_x_continuous(
    name = i18n()$t("Classes de diamètre"),
    limits = c(2.5, X * 1.1),
    breaks = seq(5, X * 1.3, 5),
    expand = c(0, 0)
  )  +
  scale_y_continuous(
    name = i18n()$t("V (m3/ha)"),
    limits = c(0, Y),
    breaks = seq(0, Y, by_VALUE)
  )  +
  scale_fill_manual(
    name = "",
    values = colour_aes_for_deadwood
  )  +
  theme_bw() + MyTheme  +
  theme(
    legend.position = "bottom",
    plot.margin = unit(c(0.1, 0.3, 0.1, 0.1), "cm")
  )
@
\FloatBarrier

<<deadwood_pie_chart, include = eval_BM, eval = eval_BM, fig.pos = 'H', fig.height = 3, fig.cap = i18n()$t("Répartition du volume de bois mort total par catégorie de diamètre et par essence"), dev = "cairo_pdf">>=

# -- plot table 1 - by diam cat
plot_table <-
  gfForetBM_ %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(NumForet, Vha_BMSinf, Vha_BMSsup, Vha_BMPinf, Vha_BMPsup) %>%
  pivot_longer(cols = -c("NumForet"), names_to = "type") %>%
  mutate(
    # translate deadwood
    type = case_when(
      type == "Vha_BMSinf" ~ i18n()$t("Bois mort au sol < 30"),
      type == "Vha_BMSsup" ~ i18n()$t("Bois mort au sol ≥ 30"),
      type == "Vha_BMPinf" ~ i18n()$t("Bois mort sur pied < 30"),
      type == "Vha_BMPsup" ~ i18n()$t("Bois mort sur pied ≥ 30")
    ),
    type = factor(
      type,
      levels = names(colour_aes_for_deadwood_diameter_category)
      )
  ) %>%
  complete(type) %>%
  arrange(desc(type)) %>%
  mutate(
    total = sum(value, na.rm = T),
    share = round(value / total, 2),
    share_cumul = cumsum(share),
    Y_label = share_cumul - share / 2
  ) %>%
arrange(type)


# -- plot 1
p1 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes("", value, fill = type),
    stat = "identity", position = "fill", width = 1
  ) +
  geom_label(
    plot_table,
    mapping = aes(
      "", Y_label,
      label = ifelse(share > 0.06, paste0(round(share * 100, 0), " %"), NA)
    ),
    # position = position_dodge(width = 1),
    label.padding = unit(0.15, "lines"),
    fill = "white",
    size = 1.7, alpha = 1
  ) +
  scale_fill_manual(
    name = str_wrap(i18n()$t("Type de bois mort"), 10),
    values = colour_aes_for_deadwood_diameter_category
    ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  guides(fill = guide_legend(reverse = T, nrow = 2)) +
  coord_polar(theta = "y") +
  theme_bw() + MyTheme +
  theme(
    title = element_text(face = 'plain', size = 7),
    plot.title = element_text(hjust = 0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    
    legend.title = element_text(size = 5),
    legend.text = element_text(size = 5),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.key.height = unit(0.4, 'cm'),
    legend.key.width = unit(0.6, 'cm'),
    
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border = element_blank()
  )


  # -- plot table 2 - by species
plot_table <-
  gfForetBM_EssReg %>% rename(Essence = EssReg) %>%
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(NumForet, Essence, Vha_total) %>%
  mutate(
    # translate species
    Essence = i18n()$t(Essence),
    Essence = factor(Essence, levels = rev(deadwood_grouped_species_order))
  ) %>%
  complete(Essence) %>%
  arrange(desc(Essence)) %>%
  mutate(
    total = sum(Vha_total, na.rm = T),
    share = round(Vha_total / total, 2),
    share_cumul = cumsum(share),
    Y_label = share_cumul - share / 2
  ) %>%
  arrange(Essence)

# -- plot 2
p2 <-
  ggplot() +
  geom_bar(
    plot_table,
    mapping = aes("", Vha_total, fill = Essence),
    stat = "identity", position = "fill", width = 1
  ) +
  geom_label(
    plot_table,
    mapping = aes(
      "", Y_label,
      label = ifelse(share > 0.06, paste0(round(share * 100, 0), " %"), NA)
    ),
    # position = position_dodge(width = 1),
    label.padding = unit(0.15, "lines"),
    fill = "white",
    size = 1.7, alpha = 1
  ) +
  scale_fill_manual(
    name = i18n()$t("Essences"),
    values = colour_aes_for_grouped_species
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  coord_polar(theta = "y") +
  theme_bw() + MyTheme +
  theme(
    title = element_text(face = 'plain', size = 7),
    plot.title = element_text(hjust = 0.5),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 7),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    
    legend.title = element_text(size = 5),
    legend.text = element_text(size = 5),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.key.height = unit(0.2, 'cm'),
    legend.key.width = unit(0.3, 'cm'),
    legend.spacing.y = unit(0.2, 'cm'),
    
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border = element_blank()
  ) +
  ## important additional element to increase legend.spacing.y
  guides(fill = guide_legend(byrow = TRUE))

# grid.arrange(p1, p2, nrow = 1)

grid.arrange(
  p1 + theme(legend.position = "none"),
  p2 + theme(legend.position = "none"),
  g_legend(p1),
  g_legend(p2),
  nrow = 2, heights = c(8, 2.5)
)
@
\FloatBarrier

<<Preparation_CompositionBM, eval=T >>=
t <- dplyr::filter(gfForetBM_Essence, NumForet==forest_num & Cycle==last_cycle & !is.na(Essence)) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  dplyr::select(NumForet, Cycle, Essence, BMSinf, BMSsup, BMPinf, BMPsup) %>%
  melt(id=c("NumForet", "Cycle", "Essence"),
       variable.name="Type", value.name="Vha") %>%
  left_join(Essences[,c("Nom", "Reg")], by = c("Essence" = "Nom"))
species_main_results_table_BM <- unique(t$Essence)
@
\FloatBarrier

\Sexpr{i18n()$t("Sur les")} \Sexpr{length(unique(species_main_results_table[, "Essence"]))} \Sexpr{i18n()$t("espèces échantillonnées au total sur le dispositif, ")} \Sexpr{length(species_main_results_table_BM)} \Sexpr{i18n()$t("sont présents sous forme de bois mort.")} \Sexpr{i18n()$t("La figure")} \ref{fig:deadwood_diversity_plot} \Sexpr{i18n()$t("donne une image de la répartition du volume de bois mort représenté par les différentes essences selon la taille et la position.")}

<<deadwood_diversity_table, eval = T, include = eval_BM>>=
# -- table
table <-
  gfForetBM_Essence %>%
  filter(NumForet == forest_num & Cycle == last_cycle & !is.na(Essence)) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  select(NumForet, Cycle, Essence, BMSinf, BMSsup, BMPinf, BMPsup) %>%
  pivot_longer(
    cols = -c("NumForet", "Cycle", "Essence"),
    names_to = "Type",
    values_to = "Vha"
  ) %>%
  left_join(Essences, by = c("NumForet", "Essence" = "Nom"))

# -- sort deadwood species + other
current_deadwood_species_order <- sort(unique(table$Essence))
pop_order <- c("BMSinf", "BMSsup", "BMPinf", "BMPsup")
dead_wood_species_nb <- length(unique(current_deadwood_species_order))

fig_height_parameters$deadwood_diversity <- with(
  look_up_for_heights_table,
  fig_height[match(dead_wood_species_nb, elements_nb)]
)
@

<<deadwood_diversity_plot, fig.pos = 'ht', fig.cap = i18n()$t("Répartition des volumes de bois mort par essence (m3/ha)"), fig.height = fig_height_parameters$deadwood_diversity, eval = eval_BM, include = eval_BM, dev = "cairo_pdf">>=
# -- plot table
plot_table <-
  table %>%
  mutate(
    Essence = match(Essence, current_deadwood_species_order),
    Type = match(Type, pop_order)
  ) %>%
  select(NumForet, Cycle, Type, Essence, Vha) %>%
  group_by(Type) %>%
  mutate(
    rescale = rescale(Vha),
    taux = Vha / sum(Vha, na.rm = T) * 100,
    Vha = ifelse(Vha<0.1, round(Vha, 3), round(Vha, 1))
  ) %>%
  ungroup() %>%
  mutate(taux = ifelse(is.na(taux), 0, taux))

# -- plot
ggplot(plot_table, aes(Type, Essence)) +
  geom_tile(aes(fill = taux), colour = "black") +
  geom_text(
    aes(Type, Essence, label = ifelse(Vha != 0, round(Vha, 3), "")),
    size = 2.5
  ) +
  scale_fill_gradient(
    name = "Part du \nvolume (%)", low = "white", high = "darkgreen",
    limits = c(0, 100),
    breaks = c(0, 25, 50, 75, 100)
  ) +
  scale_x_continuous(
    position = "top",
    expand = c(0, 0),
    breaks = seq(1, 4),
    limits = c(0.5, 4.5),
    minor_breaks = seq(0.5, 4.5, 0.1),
    label = c(
      "Bois Mort au sol \n< 30 cm de Diam",
      "Bois Mort au sol \n\u2265 30 cm de Diam",
      "Bois Mort sur pied \n< 30 cm de Diam",
      "Bois Mort sur pied \n\u2265 30 cm de Diam"
    )
  ) +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0.5, max(plot_table$Essence, na.rm = T) + 0.5),
    breaks = seq(1, max(plot_table$Essence, na.rm = T)),
    minor_breaks = seq(0.5, max(plot_table$Essence, na.rm = T) + 0.5, 0.1),
    label = current_deadwood_species_order
  ) +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(
    text = element_text(size = 8),
    title = element_text(size = 9),

    axis.text.x  = element_text(size = 9),
    axis.text.y  = element_text(size = 9),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9, face = 'plain'),
    panel.grid.major = element_line(colour = "gray"),
    panel.grid.minor = element_line(colour = "gray"),
    panel.background = element_rect(fill = "white"),
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )
@
\FloatBarrier
% \clearpage
% \vspace{5cm}
% La figure \ref{fig:CompoBoisMort} illustre la part relative des  différentes essences relevées en volume et selon un regroupement opéré et précisé dans le tableau \ref{EssReg} en annexe \ref{Regroupement}.

<<CompoBoisMort, echo=F, message=F, fig.height=4, fig.cap="R\u00E9partition du volume de bois mort entre les diff\u00E9rentes essences relev\u00E9es.", fig.pos="H",include=F,eval=F>>=
# CompoBoisMort,
# tk_messageBox(type="ok",
#               message="CompoBoisMort")
# t <- dplyr::filter(gfForetBM_EssenceClasse,NumForet==forest_num) %>%
  t <- dplyr::filter(gfForetBM_EssRegClasse,NumForet==forest_num) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  # left_join(CodeEssence) %>%
  # group_by(NumForet,Foret,Cycle,EssReg) %>%
  group_by(EssReg) %>%
  dplyr::summarise(Vha=sum(BMSinf,BMSsup,BMPinf,BMPsup,na.rm=T)) %>%
  ungroup() %>%
  melt(id="EssReg") %>%
  group_by(variable) %>%
  dplyr::mutate(Tot=sum(value,na.rm=T),
         Ratio=value/Tot,
         RatioCum=cumsum(value/Tot)) %>%
  ungroup() %>%
  arrange(variable)
ggplot() +
  geom_bar(t,mapping=aes(variable,y=value,fill=EssReg),
           stat="identity",position="fill", width=1) +
  coord_polar(theta="y") +
  ggplot2::geom_text(t, mapping=aes(x=1,
                           y=round(RatioCum-Ratio/2,3),
                           label = ifelse(Ratio > 0.1,
                                          paste0(round(value,1)," m3/ha"),
                                          "")),
            size=2.5, alpha=1, colour="black") +
  coord_polar(theta = "y") +
  scale_x_discrete("") +
  scale_y_continuous(name="Part relative des essences",labels = percent) +
  # scale_fill_discrete("Essences Regroup\u00E9es") +
  scale_fill_manual("Essences Regroup\u00E9es :", values=Palette) +
  guides(fill=guide_legend(ncol=ifelse(length(unique(t$EssReg))>10,2,1),bycol=T)) +
  theme_bw() + theme(title=element_text(face='plain'),
    axis.text.y  = element_blank(),
    axis.text.x = element_text(size = 6),
    axis.ticks = element_blank(),
    axis.title.x=element_text(face='plain'),
    legend.text = element_text(size = 7),
    # legend.title = element_text(size=9,face='plain'),
    legend.position="right",
    strip.text = element_text(size = 7, colour="white"),
    legend.title=element_text(size = 8),
    plot.margin = unit(c(0.1,0.1,0.1,0.1), "cm"),
    panel.grid.major = element_blank(),
    panel.border=element_blank(),
    strip.background = element_rect(fill="forestgreen", colour="black"))

@
\FloatBarrier

<<BMStades, echo=F, fig.pos="H", fig.width=3.5, fig.height=3, fig.cap= "Diversit\u00E9 des stades de d\u00E9composition par types de bois mort.\\\\BMinf = bois mort au sol inf\u00E9rieur \u00E0 30cm; BMSsup = bois mort au sol sup\u00E9rieur \u00E0 30cm; BMPinf = bois mort sur pied inf\u00E9rieur \u00E0 30cm; BMPsup = bois mort sur pied sup\u00E9rieur \u00E0 30cm", fig.subcap=c("Stade de duret\u00E9", "Stade d'\u00E9corce", out.width='.49\\linewidth', out.extra='scale=1'),include=F,eval=F>>=
# BMStades,
tab <- subset(gfForetBM_StadeD, NumForet==forest_num & Cycle==last_cycle)
pos <- which(is.na(is.na(tab$Type)))
if (length(pos) > 0) {
  tab <- tab[-pos,]
}
# tab <- tab[!is.na(tab$Type),]

ggplot(tab, aes(x=Type, y=Vha, fill=StadeD)) +
  geom_bar(stat = "identity", position='stack') +
  MyTheme2 + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(y="Volume \u00E0 l'hectare (m3/ha)") +
  scale_x_discrete() +
  guides(fill=guide_legend("Stade de \npourriture",
                           reverse=T))


tab <- subset(gfForetBM_StadeE, NumForet==forest_num & Cycle==last_cycle)
tab <- tab[!is.na(tab$Type),]
ggplot(tab, aes(x=Type, y=Vha, fill=StadeE)) +
  geom_bar(stat = "identity", position='stack') +
  MyTheme2 + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(y="Volume \u00E0 l'hectare (m3/ha)") +
  guides(fill=guide_legend("Stade \n\u00E9corce",
                           reverse=T))
@
\FloatBarrier

% Le tableau \ref{BoisMort} fournit par cycle, l'importance en volume du bois mort en distinguant bois mort au sol et sur pied.
<<BoisMort, echo=FALSE, results='asis', fig.pos="H", comment=F,include=F,eval=F>>=
t1 <- filter(gfForetBMP_,NumForet==forest_num) %>%
  select(NumForet,Cycle,Vha) %>%
  mutate(Type="sur pied")
t2 <- filter(gfForetBMS_,NumForet==forest_num) %>%
  select(NumForet,Cycle,Vha) %>%
  mutate(Type="au sol")

t <- rbind(t1,t2) %>%
  filter(!is.na(Vha)) %>%
  select(-NumForet) %>%
  arrange(Cycle) %>%
  set_multirow_table("Cycle")
pos <- which(!is.na(t$Cycle))-1

print(xtable(t,
             caption = "Importance et type de bois mort.",
             digits=c(0,0,1,0),
             label = "BoisMort",
             align=c(rep("c|",dim(t)[2]),"c"),
             caption.placement="top"),
      include.rownames=FALSE,
      hline.after=pos,
      sanitize.text.function=function(x){return(x)},
      size="\\footnotesize")
@

% \FloatBarrier
% \subsubsection{Importance par nature, dimension et stade de décomposition}
% La figure \ref{fig:BMSline1} fournit l'importance du bois mort au sol, exprimée en volume, tandis que la figure \ref{fig:BMSline2} l'exprime par stade de décomposition.
<<BMSline1, echo=FALSE, size='footnotesize', include=T, fig.pos="H", fig.height=2, fig.cap= "Importance du bois mort au sol.",include=F, eval=F>>=
t1 <- filter(gfForetBMS_ClasseStadeD,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  mutate(Type="BMS") %>%
  select(NumForet,Cycle,Classe,Vha,StadeD,Type)
t2 <- filter(gfForetBMP_ClasseStadeD,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  select(NumForet,Cycle,Classe,Vha,StadeD) %>%
  mutate(Type="BMP")
t <- rbind(t1,t2) %>%
  mutate(Titre=paste0("Cycle ",Cycle))
if (dim(t)[1] > 0) {
  ggplot() +
    geom_bar(t,mapping=aes(x=Classe,y=Vha,fill=Type),
             stat="identity",position='stack') +
    labs(x="Classe de diamètre",y="Volume( m3/ha)") +
    facet_wrap(~Titre,ncol=2) +
    MyTheme + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                    strip.background = element_rect(fill=NA, colour=NA))
} else {print("Pas de bois mort")}
@

<<BMSline2, echo=F, fig.pos="H", fig.height=2, fig.cap= "Importance du bois mort au sol par stade de dureté du bois.",include=F, eval=F>>=
t1 <- filter(gfForetBMS_ClasseStadeD,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  mutate(Type="BMS") %>%
  select(NumForet,Cycle,Classe,Vha,StadeD,Type)
t2 <- filter(gfForetBMP_ClasseStadeD,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  select(NumForet,Cycle,Classe,Vha,StadeD) %>%
  mutate(Type="BMP")
t <- rbind(t1,t2) %>%
  arrange(desc(StadeD)) %>%
  mutate(Titre=paste0("Cycle ",Cycle))
if (dim(t)[1] > 0) {
  ggplot() +
    geom_bar(t,mapping=aes(x=Classe,y=Vha,fill=factor(StadeD)),
             stat="identity",position='stack') +
    #     scale_x_continuous(limits=c(0,max(t$Classe,na.rm=T)),
    #                        breaks=seq(10,max(t$Classe,na.rm=T),20)) +
    #   ,
    #                        expand=c(0,0)) +
    # scale_y_continuous(expand=c(0,0)) +
    facet_wrap(~Titre,ncol=2) +
    scale_fill_grey(name="Stade de\npourriture",
                    start=0.9,
                    end=0.1,
                    na.value="grey50") +
    MyTheme + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                    strip.background = element_rect(fill=NA, colour=NA))
} else {print("Pas de bois mort")}
@

<<BMSline3, echo=F, fig.pos="H", fig.height=2, fig.cap= "Importance du bois mort au sol par stade de décomposition de l'écorce.",include=F, eval=F>>=
t1 <- filter(gfForetBMS_ClasseStadeE,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  mutate(Type="BMS") %>%
  select(NumForet,Cycle,Classe,Vha,StadeE,Type)
t2 <- filter(gfForetBMP_ClasseStadeE,
             NumForet==forest_num &
               !is.na(Vha)) %>%
  select(NumForet,Cycle,Classe,Vha,StadeE) %>%
  mutate(Type="BMP")
t <- rbind(t1,t2) %>%
  arrange(-StadeE) %>%
  mutate(Titre=paste0("Cycle ",Cycle))
if (dim(t)[1] > 0) {
  ggplot() +
    geom_bar(t,mapping=aes(x=Classe,y=Vha,fill=factor(StadeE)),
             stat="identity",position='stack') +
    facet_wrap(~Titre,ncol=2) +
    scale_fill_grey(name="Stade\nécorce",
                    start=0.9,
                    end=0.1,
                    na.value="grey50") +
    MyTheme + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                    strip.background = element_rect(fill=NA, colour=NA))
}

@
\FloatBarrier

\EditIf{\Sexpr{last_cycle > 1}}{TRUE}{

\subsection{Evolution du bois mort}
Le tableau \ref{Tab_EvolBM} et la figure \ref{fig:Hist_EvolBM} présentent l'évolution des volumes de bois mort.

<<Tab_EvolBM, fig.pos = 'H', fig.height = 3, results = 'asis', eval = (eval_BM & eval_evol), include = (eval_BM & eval_evol)>>=
EvolBM_ALIBI <- expand.grid(
  Cycle = 1:last_cycle,
  NumForet = forest_num,
  variable = c(
    "BMSinf", "BMSsup",
    "BMPinf", "BMPsup", "Vha_total"
  ),
  stringsAsFactors = F
) %>%
  data.frame() %>%
  left_join(Cycles[, c("NumForet", "Cycle", "Annee")]) %>%
  mutate(
    variable = factor(
      variable,
      levels = c(
        "BMSinf", "BMSsup",
        "BMPinf", "BMPsup", "Vha_total"
      )
    )
  )

df1 <-
  gfForetBM_ %>%
  filter(NumForet == forest_num) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  left_join(Cycles[, c("NumForet", "Cycle", "Annee")]) %>%
  select(
    Cycle, Annee,
    BMSinf, BMSsup, BMPinf, BMPsup, Vha_total
    ) %>%
  pivot_longer(
    cols = -c("Annee", "Cycle"),
    names_to = "variable"
    ) %>%
  mutate(
    variable = factor(
      variable,
      levels = c(
        "BMSinf", "BMSsup",
        "BMPinf", "BMPsup", "Vha_total"
      )
    )
  ) %>%
  full_join(EvolBM_ALIBI) %>%
  select(Annee, variable, value) %>%
  pivot_wider(id_cols = "Annee", names_from = "variable", values_from = "value") %>% 
  arrange(-Annee) %>%
  group_by(Annee) %>%
  mutate(
    Part_BMSinf = round(BMSinf / Vha_total * 100, 0),
    Part_BMSsup = round(BMSsup / Vha_total * 100, 0),
    Part_BMPinf = round(BMPinf / Vha_total * 100, 0),
    Part_BMPsup = round(BMPsup / Vha_total * 100, 0),
    Part_Vha_total = round(Vha_total / Vha_total * 100, 0),

    BMSinf = ifelse(
      BMSinf != 0,
      ifelse(
        BMSinf > 0.1,
        round(BMSinf, 1),
        round(BMSinf, 2)
      ),
      NA
    ),
    BMSsup = ifelse(
      BMSsup != 0,
      ifelse(
        BMSsup > 0.1,
        round(BMSsup, 1),
        round(BMSsup, 2)),
      NA
    ),
    BMPinf = ifelse(
      BMPinf != 0,
      ifelse(
        BMPinf > 0.1,
        round(BMPinf, 1),
        round(BMPinf, 2)
      ),
      NA
    ),
    BMPsup = ifelse(
      BMPsup != 0,
      ifelse(
        BMPsup > 0.1,
        round(BMPsup, 1),
        round(BMPsup, 2)
      ),
      NA
    ),
    Vha_total = ifelse(
      Vha_total != 0,
      ifelse(
        Vha_total > 0.1,
        round(Vha_total, 1),
        round(Vha_total, 2)
      ),
      NA
    ),

    # nouvelle version (plus lisible mais à améliorer)
    BMSinf = ifelse(
      !is.na(BMSinf) & !is.na(Part_BMSinf),
      paste0(
        "\\footnotesize{",
        BMSinf,
        "} \\scriptsize{\\textcolor{CornflowerBlue}{(",
        Part_BMSinf,
            "\\%)}}"
      ),
      ""
      ),
    BMSinf = ifelse(
      !is.na(BMSinf) & is.na(Part_BMSinf),
      paste0(
        "\\footnotesize{",
        BMSinf,
        "}"
      ),
      BMSinf
      ),

    # # ancienne version ---
    # BMSinf = ifelse(
    #   !is.na(BMSinf),
    #   paste0(
    #     "\\footnotesize{",
    #     BMSinf,
    #     ifelse(
    #       !is.na(Part_BMSinf),
    #       paste0(
    #         "} \\scriptsize{\\textcolor{CornflowerBlue}{(",
    #         Part_BMSinf,
    #         "\\%)}}"
    #       ),
    #       "}"
    #     )),
    #   ""),
    # # ---

    BMSsup = ifelse(!is.na(BMSsup),
                    paste0("\\footnotesize{",
                           BMSsup,
                           ifelse(!is.na(Part_BMSsup),
                                  paste0("} \\scriptsize{\\textcolor{CornflowerBlue}{(",
                                         Part_BMSsup,
                                         "\\%)}}"), "}")),
                    ""),
    BMPinf = ifelse(!is.na(BMPinf),
                    paste0("\\footnotesize{",
                           BMPinf,
                           ifelse(!is.na(Part_BMPinf),
                                  paste0("} \\scriptsize{\\textcolor{CornflowerBlue}{(",
                                         Part_BMPinf,
                                         "\\%)}}"), "}")),
                    ""),
    BMPsup = ifelse(!is.na(BMPsup),
                    paste0("\\footnotesize{",
                           BMPsup,
                           ifelse(!is.na(Part_BMPsup),
                                  paste0("} \\scriptsize{\\textcolor{CornflowerBlue}{(",
                                         Part_BMPsup,
                                         "\\%)}}"), "}")),
                    ""),
    Vha_total = ifelse(!is.na(Vha_total),
                    paste0("\\cellcolor{LightGray} \\textbf{\\footnotesize{",
                           Vha_total,
                           "} \\scriptsize{\\textcolor{Brown}{(",
                           Part_Vha_total,
                           "\\%)}}}"),
                    "\\cellcolor{LightGray}")
  ) %>%
  ungroup() %>%
  select(Annee, BMSinf, BMSsup, BMPinf, BMPsup, Vha_total) %>%
  arrange(Annee) %>%
  rename(
    !!paste0("\\hline\n\\multirow{2}{*}{\\parbox{2cm}{\\centering \\textbf{", i18n()$t("Années d'inventaire"), "}}}") := "Annee",
    !!paste0(" & \\multicolumn{2}{c|}{\\textbf{", i18n()$t("Bois mort au sol"), "}}") := "BMSinf",
    " " = "BMSsup",
    !!paste0(" & \\multicolumn{2}{c|}{\\textbf{", i18n()$t("Bois mort sur pied"), "}}") := "BMPinf",
    "  " = "BMPsup",
    !!paste0(" & \\multirow{2}{*}{\\parbox{2cm}{\\centering \\textbf{", i18n()$t("Bois mort total"), " \\scriptsize{(m3/ha)}}}}\\\\\n") := "Vha_total"
  )



Entete <- paste0(paste0(names(df1), collapse = ""), "\n\\cline{2-5}\n")
names(df1) <- c(
  " ",
  "< 30cm \\scriptsize{(m3/ha)}",
  "$\\geqslant$ 30cm \\scriptsize{(m3/ha)}",
  "< 30cm \\scriptsize{(m3/ha)}",
  "$\\geqslant$ 30cm \\scriptsize{(m3/ha)}",
  " "
)

Digits = rep(0, dim(df1)[2] + 1)

# %%%%%%%%%% Impression tableau
print(
  xtable(
    df1,
    # digits = rep(0, dim(t1)[2]+1),
    digits = c(0, 0, rep(1, dim(df1)[2] - 1)),
    align = c("M{0cm}", "|M{2cm}|", rep("M{2cm}|", dim(df1)[2] - 2), "M{2cm}|"),
    caption = i18n()$t("Evolution des volumes de bois mort au cours du temps"),
    label = "Tab_EvolBM"
  ),
  caption.placement = "bottom",
  hline.after = 0:dim(df1)[1],
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  add.to.row = list(
    pos = list(-1),
    command = Entete
  ),
  size = "\\footnotesize"
)
@


<<Courbe_EvolBM, echo=F, comment=NA, warning=FALSE, fig.pos='H', fig.height=3, fig.cap= "Evolution des volumes de bois mort",results='asis',eval=F,include=F,message=F,warning=F>>=
  # BM_Intitule <- data.frame(Base=c("BMSinf","BMSsup","BMPinf","BMPsup"),
  #                   Intitule=c("Bois mort au sol < ou = 30",
  #                              "Bois mort au sol > 30",
  #                              "Bois mort sur pied < ou = 30",
  #                              "Bois mort sur pied > 30"),
  #                   stringsAsFactors=T) %>%
  # mutate(Base=factor(Base,levels=c("BMSinf","BMSsup","BMPinf","BMPsup")))
  BM_Intitule <- data.frame(Base=c("BMS","BMP"),
                    Intitule=c("Bois mort au sol",
                               "Bois mort sur pied"),
                    stringsAsFactors=T) %>%
  mutate(Base=factor(Base,levels=c("BMS","BMP")))


EvolBM_ALIBI <- expand.grid(Cycle=1:last_cycle,
                            NumForet=forest_num,
                           variable=c("BMS","BMP"),
                           stringsAsFactors=F) %>%
  data.frame() %>%
  left_join(Cycles[,c("NumForet","Cycle","Annee")]) %>%
  mutate(variable=factor(variable,levels=c("BMS","BMP")))

df <- filter(gfForetBM_,
         NumForet==forest_num) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  mutate(BMS=BMSinf+BMSsup,
         BMP=BMPinf+BMPsup) %>%
  left_join(Cycles[,c("NumForet","Cycle","Annee")]) %>%
  select(Cycle,Annee,BMS,BMP) %>%
  melt(id=c("Annee","Cycle")) %>%
  mutate(variable=factor(variable,levels=c("BMS","BMP"))) %>%
  full_join(EvolBM_ALIBI) %>%
  left_join(BM_Intitule,
            by=c("variable"="Base")) %>%
  mutate(variable=Intitule,
         variable=factor(variable,levels=c("Bois mort au sol",
                               "Bois mort sur pied"))) %>%
  select(Cycle,Annee,variable,value) %>%
  replace(is.na(.),0)

df_Bis <- filter(df,
         is.element(Cycle,c(1,last_cycle)))

# df1$value[which(is.na(df1$value))] <- 5

Y=max(df1$value)

Palette_CatBM <- c("Gray30","Gray75")
names(Palette_CatBM) <- c("Bois mort au sol",
                               "Bois mort sur pied")

ggplot() +
  geom_line(df,
             mapping=aes(factor(Annee),value,colour=variable,group=variable)) +
  # geom_point(df,
  #            mapping=aes(factor(Annee),value,colour=variable,group=variable)) +
  geom_label_repel(df_Bis,
                   mapping=aes(factor(Annee),value,label=variable),
                   label.padding = unit(0.15, "lines"),
                     size=1.7, alpha=1, colour="black") +
  # geom_label_repel(df_Bis,
  #                  mapping=aes(Cat,Moy_AcctD,label=Annee),
  #                  label.padding = unit(0.15, "lines"),
  #                    size=1.7, alpha=1, colour="black") +
  # scale_x_continuous(name="Catégories de diamètre",
  #                    # limits=c(10,max(df_AcctD$Classe,na.rm=T)),
  #                    # breaks=seq(10,floor(max(df_AcctD$Classe,na.rm=T)/20+0.5)*20,5),
  #                    expand=c(0,0)) +
  scale_y_continuous(name="Volumes de bois mort (m3/ha/an)") +
  scale_colour_manual(name="Années d'inventaire",
                      values=Palette_CatBM) +
  # guides(colour=guide_legend(nrow=1,
  #                            byrow=T,
  #                            order=2),
  #        size=guide_legend(order=1)) +
  labs(x="Années d'inventaire") +
  MyTheme + theme(legend.position="bottom",
                  legend.direction="horizontal",
                  legend.box="vertical",
                  legend.box.just="bottom",
                  legend.spacing.y = unit(0,"cm"),
                  legend.title=element_text(size=8),
                  legend.text=element_text(size=7),

                  axis.title.x=element_text(size=8),
                  axis.title.y=element_text(size=8),
                  axis.text.x=element_text(size=7),
                  axis.text.y=element_text(size=7),

                  strip.background=element_blank(),
                  strip.text=element_text(face="bold"))
@

<<Hist_EvolBM, echo=F, comment=NA, warning=FALSE, fig.pos='H', fig.height=3, fig.cap= "Evolution des volumes de bois mort",results='asis',eval=(eval_BM & eval_evol),include=(eval_BM & eval_evol),message=F,warning=F>>=
  # BM_Intitule <- data.frame(Base=c("BMSinf","BMSsup","BMPinf","BMPsup"),
  #                   Intitule=c("Bois mort au sol < ou = 30",
  #                              "Bois mort au sol > 30",
  #                              "Bois mort sur pied < ou = 30",
  #                              "Bois mort sur pied > 30"),
  #                   stringsAsFactors=T) %>%
  # mutate(Base=factor(Base,levels=c("BMSinf","BMSsup","BMPinf","BMPsup")))
  BM_Intitule <- data.frame(Base=c("BMS","BMP"),
                    Intitule=c("Bois mort au sol",
                               "Bois mort sur pied"),
                    stringsAsFactors=T) %>%
  mutate(Base=factor(Base,levels=c("BMS","BMP")))


EvolBM_ALIBI <- expand.grid(Cycle=1:last_cycle,
                            NumForet=forest_num,
                           variable=c("BMS","BMP"),
                           stringsAsFactors=F) %>%
  data.frame() %>%
  left_join(Cycles_Disp[,c("NumForet","Cycle","Annee")]) %>%
  mutate(variable=factor(variable,levels=c("BMS","BMP")))

df <- filter(gfForetBM_,
         NumForet==forest_num) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  mutate(BMS=BMSinf+BMSsup,
         BMP=BMPinf+BMPsup) %>%
  left_join(Cycles[,c("NumForet","Cycle","Annee")]) %>%
  select(Cycle,Annee,BMS,BMP) %>%
  melt(id=c("Annee","Cycle")) %>%
  mutate(variable=factor(variable,levels=c("BMS","BMP"))) %>%
  full_join(EvolBM_ALIBI) %>%
  left_join(BM_Intitule,
            by=c("variable"="Base")) %>%
  mutate(variable=Intitule,
         variable=factor(variable,levels=c("Bois mort au sol",
                               "Bois mort sur pied"))) %>%
  select(Cycle,Annee,variable,value) %>%
  replace(is.na(.),0)

df_Bis <- filter(df,
         is.element(Cycle,c(1,last_cycle)))

# df1$value[which(is.na(df1$value))] <- 5

Y=max(df$value,na.rm=T)
Y=ifelse(Y==0,
         10,Y)
# value_by <- ifelse(Y>=5000,
#                    1000,Y/10)
# if (Y >= 1000) {
by_VALUE <- floor(((Y/8+Y/15)/2)/100+0.5)*100
# }
if (Y < 650) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/50+0.5)*50
}
if (Y < 325) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/25+0.5)*25
}
if (Y < 130) {
by_VALUE <- floor(((Y/8+Y/15)/2)/10+0.5)*10
}
if (Y < 65) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/5+0.5)*5
  by_VALUE <- ifelse(by_VALUE==0,
                     5,by_VALUE)
}
if (Y < 40) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/3+0.5)*3
  by_VALUE <- ifelse(by_VALUE==0,
                     3,by_VALUE)
}
if (Y < 27) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/2+0.5)*2
  by_VALUE <- ifelse(by_VALUE==0,
                     2,by_VALUE)
}
if (Y <= 13) {
  by_VALUE <- 1
}

# Palette_CatBM <- c("Gray30","Gray75")
Palette_CatBM <- c("burlywood1","chocolate4")
names(Palette_CatBM) <- c("Bois mort au sol",
                               "Bois mort sur pied")

ggplot() +
  geom_bar(df,
             mapping=aes(factor(Annee),value,fill=variable),
           position="dodge",stat="identity",width=0.5) +
  # geom_point(df,
  #            mapping=aes(factor(Annee),value,colour=variable,group=variable)) +
  # geom_label_repel(df_Bis,
  #                  mapping=aes(factor(Annee),value,label=variable),
  #                  label.padding = unit(0.15, "lines"),
  #                    size=1.7, alpha=1, colour="black") +
  # geom_label_repel(df_Bis,
  #                  mapping=aes(Cat,Moy_AcctD,label=Annee),
  #                  label.padding = unit(0.15, "lines"),
  #                    size=1.7, alpha=1, colour="black") +
  # scale_x_continuous(name="Catégories de diamètre",
  #                    # limits=c(10,max(df_AcctD$Classe,na.rm=T)),
  #                    # breaks=seq(10,floor(max(df_AcctD$Classe,na.rm=T)/20+0.5)*20,5),
  #                    expand=c(0,0)) +
  scale_y_continuous(name="Volumes de bois mort (m3/ha/an)",
                     limits=c(0,Y*1.1),
                     breaks=seq(0,Y*1.3,by_VALUE)) +
  scale_fill_manual(name="",
                      values=Palette_CatBM) +
  # guides(colour=guide_legend(nrow=1,
  #                            byrow=T,
  #                            order=2),
  #        size=guide_legend(order=1)) +
  labs(x="Années d'inventaire") +
  MyTheme + theme(legend.position="bottom",
                  legend.direction="horizontal",
                  legend.box="vertical",
                  legend.box.just="bottom",
                  legend.spacing.y = unit(0,"cm"),
                  legend.title=element_text(size=8),
                  legend.text=element_text(size=7),

                  axis.title.x=element_text(size=8),
                  axis.title.y=element_text(size=8),
                  axis.text.x=element_text(size=7),
                  axis.text.y=element_text(size=7),

                  strip.background=element_blank(),
                  strip.text=element_text(face="bold"))
@
}{}

\subsection{Ratio entre bois mort et bois vivant}

La figure \ref{fig:Hist_BMBV} représente conjointement le volume de bois mort total (hors classe 5 cm) et le volume de bois total (c'est-à-dire la somme des volumes de bois mort et de bois vivant) par classe de diamètre.\\
% \textcolor{red}{Attention : problème sur les calculs de perches détecté avec la figure ci-dessous. Revoir afi\_Calculs() pour les perches (+ Vc + Acct ...)}
% Mettre ratio BM/BV dans une phrase à part et non sur figure.
<<Hist_BMBV, echo=F, message=F, comment=NA, size='footnotesize', fig.pos="H", fig.height=3.5, fig.cap= "Importance relative du bois mort par classes de diam\u00E8tre.",eval=T, include=eval_BM>>=

t <- gfForetBM_Classe %>% 
  filter(NumForet == forest_num & Cycle == last_cycle & Classe >= 5) %>%
  select(NumForet, Foret, Classe, Vha_total)

## -- ##
t1_PREC <- dplyr::filter(gfForetFpied_Classe,
                    NumForet==forest_num & Cycle==last_cycle) %>%
  dplyr::select(NumForet,Foret,Classe,Vha) %>%
  group_by(NumForet,Foret,Classe) %>%
  dplyr::summarise(Vha=sum(Vha,na.rm=T)) %>%
  ungroup()
t1_PER <- dplyr::filter(gfForetPer_Classe,
                    NumForet==forest_num & Cycle==last_cycle) %>%
  dplyr::select(NumForet,Foret,Classe,Vha) %>%
  group_by(NumForet,Foret,Classe) %>%
  dplyr::summarise(Vha=sum(Vha,na.rm=T)) %>%
  ungroup()
t1_TAILLIS <- dplyr::filter(gfForetTaillis_Classe,
                    NumForet==forest_num & Cycle==last_cycle) %>%
  dplyr::select(NumForet,Foret,Classe,Vha) %>%
  group_by(NumForet,Foret,Classe) %>%
  dplyr::summarise(Vha=sum(Vha,na.rm=T)) %>%
  ungroup()

t1 <- rbind(t1_PREC,
            t1_PER,
            t1_TAILLIS) %>%
  group_by(NumForet,Foret,Classe) %>%
  summarise(Vha=sum(Vha,na.rm=T)) %>%
  ungroup()
## -- ##

t2 <- full_join(t,t1) %>%
 replace(is.na(.),0) %>%
    ungroup()
# Ratio=round(mean(t2$Vha_total/(t2$Vha+t2$Vha_total),na.rm=T),3)
# Mean =round(mean(t2$Vha_total,na.rm=T),2)
BMTot=round(sum(t2$Vha_total,na.rm=T),1)
BTot=round(sum(t2$Vha+t2$Vha_total,na.rm=T),1)
Ratio=round(BMTot/BTot,3)
t2 <- melt(t2,id=c("NumForet","Foret","Classe")) %>%
  dplyr::mutate(value=ifelse(is.na(value),0,value),
         variable=factor(variable,levels=c("Vha_total","Vha"))) %>%
  arrange(variable)

 # En absolu

X=max(t2$Classe,na.rm=T)
# value_breaks <- ifelse(X >= 50,
#                        c(0,10,30,seq(50,X,20)),
#                        seq(0,X,10))
value_breaks <- seq(0,X,10)


Y=max(t2$value,na.rm=T)
Y=ifelse(Y==0,
         10,Y)
# value_by <- ifelse(Y>=5000,
#                    1000,Y/10)
# if (Y >= 1000) {
by_VALUE <- floor(((Y/8+Y/15)/2)/100+0.5)*100
# }
if (Y < 650) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/50+0.5)*50
}
if (Y < 325) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/25+0.5)*25
}
if (Y < 130) {
by_VALUE <- floor(((Y/8+Y/15)/2)/10+0.5)*10
}
if (Y < 65) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/5+0.5)*5
  by_VALUE <- ifelse(by_VALUE==0,
                     5,by_VALUE)
}
if (Y < 40) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/3+0.5)*3
  by_VALUE <- ifelse(by_VALUE==0,
                     3,by_VALUE)
}
if (Y < 27) {
  by_VALUE <- floor(((Y/8+Y/15)/2)/2+0.5)*2
  by_VALUE <- ifelse(by_VALUE==0,
                     2,by_VALUE)
}
if (Y <= 13) {
  by_VALUE <- 1
}

ggplot() +
  geom_bar(arrange(t2,variable),
           mapping=aes(Classe,value,fill=variable), #,colour=variable
                 stat='identity',position='stack',alpha=1) +
  # geom_hline(yintercept=Mean, colour="blue", linetype=2, size=0.5) +
  scale_x_continuous(expand=c(0,0),
                     limits=c(5,X+5),
                     breaks=value_breaks,
                     name="Classes de diam\u00E8tre") +
  scale_y_continuous(expand=c(0,0),
                     limits=c(0,Y*1.3),
                     breaks=seq(0,Y*1.3,by_VALUE),
                     # labels=percent,
                     name="Volume de bois (m3/ha)") +
  scale_fill_manual(name="Population",
                    values=c("chocolate4","green3"),
                    labels=c("Bois mort","Bois vivant")) +
#   scale_colour_manual(name="Population",
#                     values=c("gray60","limegreen"),
#                     labels=c("Bois vivant","Bois mort")) +
  annotate("text", label = c(paste("Volume bois mort total = ",BMTot,"m3/ha"),
                             # paste("Volume bois mort moyen = ",Mean,"m3/ha"),
                            paste("Volume bois total = ",BTot,"m3/ha")),
           x = rep(0.7*(max(t2$Classe,na.rm=T)+5),2), #3
           y = c(Y*1.1,
                 # Mean,
                 Y*1.1),
           vjust=c(-1.5,
                   # -0.7,
                   0),
           size=2.5,fontface='plain',color="navyblue") +
  MyTheme + theme(legend.direction="horizontal",
                  legend.position="bottom")
 # En relatif
# p2 <- ggplot() +
#   geom_bar(t2,mapping=aes(Classe,value,fill=variable),
#                  stat='identity',position='fill') +
#   # geom_hline(yintercept=Ratio, colour="blue", linetype=2, size=0.5) +
#   scale_x_continuous(expand=c(0,0),
#                      limits=c(0,max(t2$Classe,na.rm=T)+5),
#                      breaks=c(0,10,30,seq(50,max(t2$Classe,na.rm=T),20)),
#                      name="Classes de diam\u00E8tre") +
#   scale_y_continuous(expand=c(0,0),
#                      # limits=c(-1,3),
#                      breaks=seq(0,1,0.2),
#                      labels=percent,
#                      name="Part du volume total") +
#   scale_fill_manual(name="Population",
#                     values=c("limegreen","palegoldenrod"),
#                     labels=c("Bois mort","Bois vivant")) +
#   annotate("text", label = paste("ratio bois mort / bois total = ",Ratio*100,"%"),
#            x = 0.5*(max(t2$Classe,na.rm=T)+5), y = Ratio,
#            vjust=-0.7,size=2.5,fontface='plain',color="navyblue") +
#   MyTheme
#
# mylegend <- g_legend(p1)
#
# grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
#                          p2 + theme(legend.position="none"),
#                          nrow=1),
#              mylegend, nrow=2,heights=c(9, 1))
# print(getwd())
@
La part du volume de bois mort par rapport au volume de bois total s'élève dans ce dispositif à \textbf{\Sexpr{round(Ratio*100,0)} \%}.\\

% \begin{figure}[H]
% \begin{center}
% \includegraphics[width=\textwidth]{/Users/Valentin/Foret/Travail/Programmation/PSDRF/Nouvelle_Base/Template/Figures/Cycle1/RatioBis1-1.pdf}
% \end{center}
% \end{figure}
% \textcolor{red}{Ici la figure est tirée d'une analyse PSDRF pour gagner du temps (=avoir un retour sur le carnet et son contenu plus rapidement)}
\FloatBarrier


% \subsection{Bois mort sur pied}
% % \vspace{5cm}
% La figure \ref{fig:BMPtypo} s'intéresse au bois mort sur pied et permet de visualiser la répartition -- en absolu et en relatif -- du volume, selon les 3 types de bois morts sur pied inventoriés (types arbres\footnote{\underline{Type arbre :} c'est le cas des arbres qui viennent de dépérir, ou bien des arbres qui ont perdu une partie de leurs rameaux fins, mais pas de parties importantes de leur squelette.}, chandelles\footnote{\underline{Type chandelle :} il comprend les volis de hauteur supérieure à 1,30 m, ainsi que les arbres ayant perdu une partie importante de leur squelette.} et souches\footnote{\underline{Type souche :} il comprend les volis de hauteur inférieure à 1,30 m, ainsi que les souches non déracinées. Les souches sont échantillonnées quelle que soit leur hauteur.} ).

<<BMPtypo, echo=F, size='footnotesize', fig.pos="H", fig.height=3, fig.cap= "Répartition du volume de bois mort sur pied par type à l'échelle de l'ensemble du domaine d'inventaire.\\\\\\scriptsize{Arbre = arbre mort ayant conservé son squelette d'arbre vivant\\\\Souches = hauteur < 1,30 m\\\\Chandelles = arbre mort n'ayant pas conservé son squelette + hauteur > 1,30 m.}", include=F, eval=F>>=
# BMPtypo,
tab <- dplyr::filter(gfForetBMP_ClasseType,
                     NumForet==forest_num & Cycle==last_cycle & !is.na(Type)) %>%
  right_join(data.frame(NumForet=rep(forest_num,4),
                        Cycle=rep(last_cycle,4),
                        Classe=c(10,40,10,40),
                        Type=c("BMS","BMS","BMP","BMP"),
                        stringsAsFactors=F))
if (dim(tab)[1] > 0) {
  dplyr::select(NumForet,Classe,Type,Vha) %>%
    merge(CodeTypoArbres,
          by.x="Type", by.y="Code", all.x=T) %>%
    dplyr::mutate(Descriptif=factor(Descriptif,levels=c("Souches","Chandelles","Arbres"))) %>%
    arrange(Descriptif) %>%
    group_by(NumForet,Classe) %>%
    dplyr::mutate(VhaTot=sum(Vha, na.rm=T),
                  PartVha=Vha/VhaTot) %>%
    ungroup()
  SumS <- round(sum(tab$Vha[tab$Descriptif=="Souches"],na.rm=T),1)
  SumA <- round(sum(tab$Vha[tab$Descriptif=="Arbres"],na.rm=T),1)
  SumC <- round(sum(tab$Vha[tab$Descriptif=="Chandelles"],na.rm=T),1)
  SumTot <- SumS+SumA+SumC
  if (dim(tab)[1] > 0) {
    X <- max(tab$Classe,na.rm=T)
    Y <- max(tab$VhaTot,na.rm=T)
  } else {
    X=100
    Y=50
  }


  p1 <-  ggplot() +
    geom_bar(tab,
             mapping=aes(x=Classe, y=Vha, fill=Descriptif),
             stat = "identity", position='stack') +
    annotate("text",label=paste0("Volume 'Bois mort sur pied' total = ",
                                 SumTot,
                                 " m3/ha"),
             x=X*0.4,
             y=Y*1.07,
             # vjust=-5.5,
             size=2,
             col="red",fontface ='bold') +
    annotate("segment", x = X*0.2, xend = X*0.6, y = Y*1.04, yend = Y*1.04,
             colour = "red") +
    # annotate("text",label=paste0("Volume 'Arbres' total = ",
    #                             SumA,
    #                             " m3/ha"),
    #          x=X*0.4,
    #          y=Y*0.9,
    #          vjust=-3.5,
    #          size=2,
    #          col="darkred") +
    geom_label(data.frame(x=c(X*0.4,
                              X*0.4,
                              X*0.4),
                          y=c(Y*1.0,
                              Y*0.94,
                              Y*0.88),
                          label=c(paste0("Volume 'Arbres' total = ",
                                         SumA,
                                         " m3/ha"),
                                  paste0("Volume 'Chandelles' total = ",
                                         SumC,
                                         " m3/ha"),
                                  paste0("Volume 'Souches' total = ",
                                         SumS,
                                         " m3/ha"))),
               mapping=aes(x,y,label=label),
               size=2,
               col="darkred",position="dodge",
               label.padding=unit(0.1, "lines"),alpha=0.7) +
    # annotate("text",label=paste0("Volume 'Chandelles' total = ",
    #                               SumC,
    #                               " m3/ha"),
    #            x=X*0.4,
    #            y=Y*0.9,
    #            vjust=-1.5,
    #            size=2,
    #            col="darkred") +
    #   annotate("text",label=paste0("Volume 'Souches' total = ",
    #                               SumS,
    #                               " m3/ha"),
  #            x=X*0.4,
  #            y=Y*0.9,
  #            size=2,
  #            col="darkred") +
  labs(x="Classes de diamètre", y="Volume à l'hectare (m3/ha)") +
    scale_x_continuous(limits=c(5,X+5),
                       expand=c(0,0),
                       breaks=seq(10,X,10)) +
    scale_y_continuous(limits=c(0,Y*1.1),
                       expand=c(0,0)) +
    guides(fill=guide_legend(reverse=F)) +
    scale_fill_grey() +
    MyTheme + theme(legend.direction="horizontal")

  tab <- arrange(tab,Descriptif)
  if (dim(tab)[1] > 0) {
    Y <- max(tab$PartVha,na.rm=T)
  } else {
    Y=0
  }
  p2 <- ggplot(tab, aes(x=Classe, y=Vha, fill=Descriptif)) +
    geom_bar(stat = "identity", position='fill') +
    labs(x="Classes de diamètre", y="Part du volume (%)") +
    scale_x_continuous(limits=c(5,X+5),
                       expand=c(0,0),
                       breaks=seq(10,X,10)) +
    scale_y_continuous(labels=percent,
                       # limits=c(0,1),
                       expand=c(0,0)) +
    guides(fill=guide_legend(reverse=F)) +
    scale_fill_grey() +
    MyTheme

  if (dim(tab)[1] > 0) {
    mylegend <- g_legend(p1)

    grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                             p2 + theme(legend.position="none"),
                             nrow=1),
                 mylegend, nrow=2,heights=c(8,1))
  } else {
    grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                             p2 + theme(legend.position="none"),
                             nrow=1,widths=c(1,1)))
  }
}
@
% % \vspace{5cm}
% \begin{figure}[H]
% \begin{center}
% \includegraphics[width=\textwidth]{/Users/Valentin/Foret/Travail/Placettes_Tetras/Template/Figures/BMPtypo-1.pdf}
% \end{center}
% \end{figure}
% \textcolor{red}{Ici la figure est tirée du rapport tétras pour gagner du temps (=avoir un retour sur le carnet et son contenu plus rapidement)}
% \FloatBarrier

\subsection{Diversité des stades de décomposition (pourriture et écorce)}
\EditIf{\Sexpr{Eval_Stades}}{TRUE}{
<<Comment_3.2.4, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3.2.4")
cat(Comment$Texte)
@

En plus de l'essence et du diamètre du bois mort, de nombreuses espèces saproxyliques sont particulièrement sensibles au stade de décomposition. On rencontre en effet des cortèges très différents selon les cas de figure (notamment chez les champignons lignicoles). L'application du protocole AFI prévoit de relever cette information selon les classes suivantes :

\begin{table}[ht]
\centering
{\footnotesize
  \begin{tabular}{cc}
  \hline
Pourriture & Ecorce\\
\hline
1. Dur ou non altéré & 1. Présente sur tout le billon\\
2. Pourriture <1/4 du diamètre & 2. Présente sur plus de 50\% de la surface\\
3. Pourriture entre 1/4 et 1/2 du diamètre & 3. Présente sur moins de 50\% de la surface\\
4. Pourriture entre 1/2 et 3/4 du diamètre & 4. Absente du billon\\
5. Pourriture supérieure à 3/4. & \\
\hline
  \end{tabular}
\caption{Codification des stades de décomposition (pourriture et écorce)}
\label{TabCodeStade}
}
\end{table}
\FloatBarrier
% \vspace{5cm}
% La figure \ref{BMStades2}  permet de visualiser la répartition du volume de bois mort total selon la taille et la position (au sol ou sur pied) par paires de stades de décomposition (pourriture et écorce)

% \begin{figure}[h]
% {\centering
<<BMStades2, echo=F, fig.pos="H",fig.height=4, fig.cap= NULL,fig.subcap=c('one plot', 'the other one', 'the other one', 'the other one'),results='asis',cache=F,eval=F,include=F>>=
# BMStades2,
t <-
  gfForetBM_StadeDStadeE %>%
  dplyr::filter(NumForet == forest_num & !is.na(StadeD) & Cycle == last_cycle) %>%
  dplyr::select(
    NumForet, Cycle, StadeD, StadeE, BMSinf, BMSsup, BMPinf, BMPsup
  ) %>%
  melt(id = c("NumForet", "Cycle", "StadeD", "StadeE"),
       variable.name = "Type", value.name = "Vha") %>%
  group_by(NumForet,Cycle,Type) %>%
dplyr::mutate(VhaTot=sum(Vha,na.rm=T),
         taux=Vha/VhaTot*100,
         StadeD=as.numeric(StadeD),
         StadeE=as.numeric(StadeE)) %>%
  ungroup() %>%
  mutate(taux=ifelse(is.na(taux),0,taux))
tempBM <- data.frame(Type=c("BMSinf","BMSsup","BMPinf","BMPsup"),
                     Col=c("deepskyblue4","navyblue","forestgreen","darkgreen"),
                     Name=c("de bois\nmort au\nsol < 30 cm\nde Diam (%)",
                            "de bois\nmort au\nsol > 30 cm\nde Diam (%)",
                            "de bois\nmort sur\npied < 30 cm\nde Diam (%)",
                            "de bois\nmort sur\npied < 30 cm\nde Diam (%)"),
                     stringsAsFactors=F)
# PaletteBM        <- c("deepskyblue4","navyblue","forestgreen","darkgreen")
# names(PaletteBM) <- c("BMSinf","BMSsup","BMPinf","BMPsup")

# if (dim(t)[1] > 0) {
#   cat("La figure \\ref{BMStades2}  permet de visualiser la distribution du volume de bois mort selon la taille et la position par paires de stades de d\\u00E9composition (pourriture et \\u00E9corce)")
plotBM <- function(data,type) {
  p <- ggplot() +
  geom_tile(dplyr::filter(data,Type==type),
            mapping=aes(StadeD,StadeE,fill=taux),colour="black") +
  scale_fill_gradient(name=paste0("Part du \nvolume"),
                      low = "white", high = tempBM$Col[match(type,tempBM$Type)],
                      limits=c(0,100),
                      breaks=c(0,25,50,75,100)) +
    labs(x="Stade de pourriture",
                      y="Stade \u00E9corce") +
    scale_x_continuous(expand=c(0,0),
                     limits=c(0.5,5.5),
                     breaks=seq(1,5),
                     minor_breaks=seq(0.5,5.5,0.1)) +
    scale_y_continuous(expand=c(0,0),
                     limits=c(0.5,4.5),
                     breaks=seq(1,4),
                     minor_breaks=seq(0.5,4.5,0.1)) +
  # guides(fill=guide_legend(title="Importance relative")) +
    MyTheme2 +
  theme(panel.grid.major=element_line(colour="gray"),
        panel.grid.minor=element_line(colour="gray"),
#         panel.grid=element_line(),
#         panel.grid=element_line(),
        panel.background=element_rect(fill="white"),
# legend.key=element_rect(col="gray"),
        legend.key.height=unit(0.5,"cm"),
        legend.key.width=unit(0.5,"cm"))
} #facet_wrap(~Type,nrow=2,ncol=2)
p1 <- plotBM(t,"BMSinf")
p2 <- plotBM(t,"BMSsup")
p3 <- plotBM(t,"BMPinf")
p4 <- plotBM(t,"BMPsup")

p1
p2
p3
p4
# setwd(repGF)
# } else {cat("")}
@
% \subfloat[Bois mort au sol < 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0(repFigures,"Cycle",ChoixCycle,"/BMStades2-1")}}}
% \subfloat[Bois mort au sol > 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0(repFigures,"Cycle",ChoixCycle,"/BMStades2-2")}}}\\ %#\vspace{0.5cm}
% \subfloat[Bois mort sur pied < 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0(repFigures,"Cycle",ChoixCycle,"/BMStades2-3")}}}
% \subfloat[Bois mort sur pied > 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0(repFigures,"Cycle",ChoixCycle,"/BMStades2-4")}}}
% }

% \subfloat[Bois mort au sol < 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0("Figures",gsub(".","_","/BMStades2-1",fixed=T))}}}
% \subfloat[Bois mort au sol > 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0("Figures",gsub(".","_","/BMStades2-2",fixed=T))}}}\\ %#\vspace{0.5cm}
% \subfloat[Bois mort sur pied < 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0("Figures",gsub(".","_","/BMStades2-3",fixed=T))}}}
% \subfloat[Bois mort sur pied > 30 cm\label{fig:BMStades2}]{\includegraphics[width=.49\linewidth]{\Sexpr{paste0("Figures",gsub(".","_","/BMStades2-4",fixed=T))}}}
% }
% \caption[Distribution des volumes de bois mort par stades de pourriture et par stades écorce]{Distribution des volumes de bois mort par stades de pourriture et par stades écorce}%\label{fig:BMStades2}
% \label{BMStades2}
% \end{figure}
%
% \FloatBarrier
% \vspace{5cm}
La figure \ref{fig:BMStades3} permet de visualiser la répartition du volume de bois mort total par stades de décomposition (pourriture et écorce).
<<BMStades3, echo=F, fig.pos='H', fig.height=2.5, fig.cap= "R\u00E9partition du volume de bois mort total par stades de pourriture et par stades \u00E9corce",eval=eval_BM & Eval_Stades,include=eval_BM & Eval_Stades>>=
# BMStades3,
# print(paste0(repFigures,"Cycle",ChoixCycle,"/BMStades2-1"))
# tk_messageBox(type="ok",
#               message=Eval_Stades)
t <- dplyr::filter(gfForetBM_StadeDStadeE,
                   NumForet==forest_num &
                     !is.na(StadeD) &
                     Cycle==last_cycle) %>%
  rename(
    BMSinf = Vha_BMSinf,
    BMSsup = Vha_BMSsup,
    BMPinf = Vha_BMPinf,
    BMPsup = Vha_BMPsup
  ) %>%
  dplyr::select(NumForet,Cycle,StadeD,StadeE,BMSinf,BMSsup,BMPinf,BMPsup) %>%
  melt(id=c("NumForet","Cycle","StadeD","StadeE"),
       variable.name="Type", value.name="Vha") %>%
# t <- filter(gfForetBM_StadeDStadeE, NumForet==forest_num & !is.na(Type)) %>%
  group_by(NumForet,Cycle,StadeD,StadeE) %>%
  dplyr::summarise(Vha=sum(Vha,na.rm=T)) %>%
  ungroup() %>%
  group_by(NumForet,Cycle) %>%
  dplyr::mutate(VhaTot=sum(Vha,na.rm=T),
         taux=Vha/VhaTot*100,
         StadeD=as.numeric(StadeD),
         StadeE=as.numeric(StadeE)) %>%
  ungroup()


ggplot() +
  geom_tile(t,
            mapping=aes(StadeD,StadeE,fill=taux),colour="black") +
  scale_fill_gradient(name="Part du volume\nde bois mort total (%) ",
                      low = "ghostwhite", high = "tan4",
                      limits=c(0,100),
                      breaks=c(0,25,50,75,100)) +
  scale_x_continuous(expand=c(0,0),
                     limits=c(0.5,5.5),
                     breaks=seq(1,5),
                     minor_breaks=seq(0.5,5.5,0.1)) +
  scale_y_continuous(expand=c(0,0),
                     limits=c(0.5,4.5),
                     breaks=seq(1,4),
                     minor_breaks=seq(0.5,4.5,0.1)) +
  labs(x="Stade de pourriture",
       y="Stade \u00E9corce") +
  theme(axis.text.x  = element_text(size=9, angle = 0, hjust = 1),
        axis.text.y  = element_text(size=9),
        legend.text=element_text(size=8),
        legend.title=element_text(size=9,face='plain'),
        # panel.grid=element_blank(),
        panel.grid.major=element_line(colour="gray"),
        panel.grid.minor=element_line(colour="gray"),
        panel.background=element_rect(fill="white"))


@
% } % pour commande EditIf

% \clearpage
\FloatBarrier
% \vspace{5cm}
% \newpage
}{Les stades d'écorce et de décomposition ne sont pas renseignés}
}{Il n'y a pas de bois mort inventorié}






























\EditIf{\Sexpr{eval_carbon}}{TRUE}{
\section{bilan carbone}
\subsection{stock global}
\textcolor{red}{en cours de développement}
Le premier tableau présente le stock total de carbone (dans la partie biomasse, aérienne et racinaire).\\

stock total + répartition bois mort et bois vivant, ratio entre les deux.\\

\textcolor{red}{Diamètres < 17,5 cm exclus des calculs de carbone}

<<carbon_by_diameter_classes_distribution, fig.pos = 'H', fig.height = 5, fig.cap = "Répartition du stock de carbone par classe de diamètre et par type de bois (vivant/mort)", eval = eval_carbon, include = eval_carbon>>=
# table
living_trees_carbon_by_class <-
  gfForetFpied_Classe %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Classe, tCha) %>%
  rename(carbon_stock = tCha) %>%
  mutate(type = "bois vivant")

fallen_dead_wood_carbon_by_class <-
  gfForetBMS_Classe %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Classe, tCha) %>%
  rename(carbon_stock = tCha) %>%
  mutate(type = "bois mort au sol")

standing_dead_wood_carbon_by_class <-
  gfForetBMP_Classe %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Classe, tCha) %>%
  rename(carbon_stock = tCha) %>%
  mutate(type = "bois mort sur pied")

plot_table <- rbind(
  living_trees_carbon_by_class,
  fallen_dead_wood_carbon_by_class,
  standing_dead_wood_carbon_by_class
) #%>%
  # pivot_longer(cols = c("HautT", "HautL")) %>%
  # filter(!is.na(value)) %>%
  # unite(group, Essence, name, remove = FALSE) %>%

  # # translation
  # mutate(
  #   Essence = i18n()$t(Essence),
  #   name = i18n()$t(name),
  #   name = factor( name, levels = c(
  #     i18n()$t("HautT"), i18n()$t("HautL")
  #   )) )

# -- plot settings
X_max <- max(plot_table$Classe)
X_min <- min(plot_table$Classe)
Y_max <- max(plot_table$carbon_stock, na.rm = T)

# increment scale (y)
default_increment_scale <- cut(
  Y_max, breaks = c(-Inf, 13, 27, 40, 65, 130, 325, 650, Inf),
  labels = c(1, 2, 3, 5, 10, 25, 50, 100),
  include.lowest = T,
  right = F
) %>%
  as.character() %>%
  as.numeric()

if (default_increment_scale > 1) {
  increment_value <-
    floor( ( (Y_max / 8 + Y_max / 15) / 2 ) / default_increment_scale + 0.5 ) *
    default_increment_scale
  # security
  increment_value <-
    if (increment_value == 0) default_increment_scale else increment_value
} else {
  increment_value <- 1
}

# -- plot
ggplot() +
  geom_bar(
    plot_table,
    mapping = aes(
      x = Classe, y = carbon_stock, fill = type),
    stat = 'identity', position = 'stack', alpha = 1
  ) +
  scale_x_continuous(
    name = "Classes de diamètre",
    limits = c(2, X_max),
    breaks = seq(5, floor(X_max / 10 + 0.5) * 10, 5),
    expand = c(0,0)
  ) +
  scale_y_continuous(
    # name = paste0(
    #   str_wrap(i18n()$t("Hauteurs (m) (données de "), 15), " ",
    #   last_tree_crown_measures$Annee,
    #   ")"
    # ),
    limits = c(0, Y_max * 1.1),
    breaks = seq(0, Y_max * 1.1, increment_value),
    expand = c(0,0)
  ) +
  scale_fill_manual(values = c("burlywood1", "chocolate4", "green3")) +
  # # scale_colour_manual(
  # #   name = i18n()$t("Essence"),
  # #   values = colour_aes_for_species
  # # ) +
  # scale_linetype_manual(
  #   name = i18n()$t("Hauteurs moyennes"),
  #   values = c("solid", "dashed"),
  #   label = levels(plot_table$name)
  # ) +
  # scale_alpha_manual(
  #   name = i18n()$t("Hauteurs moyennes"),
  #   values = c(1, 0.3),
  #   label = levels(plot_table$name)
  #   ) +
  # scale_shape_manual(
  #   name = i18n()$t("Hauteurs moyennes"),
  #   values = c(19, 17),
  #   label = levels(plot_table$name)
  #   ) +
  #
  # # guides
  # guides(
  #   # colour
  #   colour = guide_legend(
  #     nrow = ifelse(
  #       length(main_tree_heights_species) > 4,
  #       round(length(main_tree_heights_species) / 4, 0), 1
  #     ),
  #     byrow = T, order = 2
  #   ),
  #   # size
  #   size = guide_legend(order = 1)
  # ) +

geom_label(
  tibble(
    x = c(X_max * 0.7),
    y = c(Y_max * 1.0),
    label = paste0(
      "stock de carbone total = ",
      round(sum(plot_table$carbon_stock, na.rm = T), 0),
      " tC/ha"
    )
  ),
  mapping = aes(x, y, label = label),
  size = 2,
  col = "black", position = "dodge",
  label.padding = unit(0.1, "lines"), alpha = 1
  ) +

  # themes
  theme_bw() +
  theme(
    title = element_text(size = 8),
    text = element_text(size = 7),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.box = "horizontal",
    legend.box.just = "top",
    legend.spacing.y = unit(0, "cm"),
    strip.background = element_blank(),
    strip.text=element_text(face = "bold")
  )
@
\FloatBarrier

Tableau join : distribution des stocks de carbone par type de bois

<<carbon_stock_by_pop_distribution_table, results = 'asis', fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
# TODO : à rapprocher de la fonction 'print_main_results_table' ?
# -- carbon stock by population
living_trees_carbon <-
  gfForetFpied_ %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, tCha, CV_tCha, Er_tCha) %>%
  rename(
    Moy = tCha,
    CV = CV_tCha,
    Er = Er_tCha
  ) %>%
  mutate(variable = "bois vivant")

fallen_dead_wood_carbon <-
  gfForetBMS_ %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, tCha, CV_tCha, Er_tCha) %>%
  rename(
    Moy = tCha,
    CV = CV_tCha,
    Er = Er_tCha
  ) %>%
  mutate(variable = "bois mort au sol")

standing_dead_wood_carbon <-
  gfForetBMP_ %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, tCha, CV_tCha, Er_tCha) %>%
  rename(
    Moy = tCha,
    CV = CV_tCha,
    Er = Er_tCha
  ) %>%
  mutate(variable = "bois mort sur pied")

# -- rejoindre les modèles de tableaux pré-existants !
# TODO : faire un chunck 'set-up' pour réutiliser la même table tout le temps
carbon_results_variability <- rbind(
  living_trees_carbon,
  fallen_dead_wood_carbon,
  standing_dead_wood_carbon
) %>%
  select(-NumForet, -Cycle) %>%
  mutate(
    # build IC
    IC = paste0(
      "\\emph{[", round(Moy - Er * Moy / 100, 1),
      "-", round(Moy + Er * Moy / 100, 1), "]}"
    ),
    # remove mean column
    Moy = NULL,

    variable = gsub("ha", "", variable),
    variable = gsub("per", "", variable),
    variable = gsub("Ha", "", variable),

    # translation
    # variable = i18n()$t(variable),

    variable = paste0("\\cellcolor{LightGray} ", variable),

    # format CV & Er columns
    CV = round(CV, 0),
    Er = round(Er, 0)
  ) %>%
  # pivot : variables N et G en colonnes
  pivot_longer(
    cols = -c("variable"),
    names_to = "stat",
    values_to = "value",
    values_transform = list(
      value = as.character
    )
  ) %>%
  pivot_wider(
    id_cols = c("stat"),
    names_from = "variable",
    values_from = "value"
  ) %>%

  # format table
  mutate(
    # stat = str_replace(stat, "Moy", "\\\\textbf{Moyenne}"),
    stat = str_replace(stat, "CV", "Coefficient de variation (\\\\%)"),
    stat = str_replace(stat, "Er", "Erreur relative (\\\\%)"),
    stat = str_replace(stat, "IC", "\\\\emph{Intervalle de confiance}")

    # column 'N' -> no need
    # empty = NA
  ) %>%
  # set_multirow_table(1) %>% # TODO : remplacer les numéros de colonne par les noms de colonne

  # rename
  rename(
    # "\\cellcolor{LightGray} Année" = "Annee",
    "\\cellcolor{LightGray} " = "stat"#,
    #   " " = "empty"
  )

# -- carbon results table
# var = "Gha" # Gha <=> Moy <=> carbon_stock pour pouvoir utiliser la fonction 'set_up_main_results_by_attribute_table'
# attribute = "variable"
# attribute_name <- paste0("\\textbf{", i18n()$t("Types de bois"), "}")
table <- rbind(
  living_trees_carbon,
  fallen_dead_wood_carbon,
  standing_dead_wood_carbon
) %>%
  select(Moy, variable) %>%
  rename(value = Moy) %>%

  mutate(
    # total
    total = sum(value, na.rm = T),

    # share
    share = round(value / total * 100),
    share = ifelse(share >= 1, share, "$\\sim$0"),
    share = ifelse(value > 0, share, NA),

    # digits
    digits = 1
  )

# # total table
# total_table <-
#   table %>%
#   select(variable, total) %>%
#   mutate(total = paste0("\\textbf{", round(total, 1), "}")) %>%
#   pivot_wider(id_cols = NULL, names_from = "variable", values_from = "total")

# final_table
carbon_results_by_wood_types <-
  table %>%
  mutate(
    # label
    label = ifelse(value >= 1 / 10 ^ digits, round(value, digits), "$\\sim$0"),
    label = paste0(
      "\\footnotesize{",
      label,
      "} \\scriptsize{\\textcolor{CornflowerBlue}{(",
      share,
      "\\%)}}"
    ),

    variable = paste0("\\cellcolor{LightGray} \\textbf{", variable, "}")
) %>%
  select(variable, label) %>%
  pivot_wider(id_cols = NULL, names_from = "variable", values_from = "label") %>%
  # rbind(total_table)
  mutate(stat = "tC/ha moyen") %>%
  select(stat, everything()) %>%
  # rename
  rename("\\cellcolor{LightGray} " = "stat")


#   # arrange table
#   mutate(
#     name = ifelse(name == "total", "\\rowcolor{LightGray} \\textbf{Total}", name),
#     name = factor(name, levels = c(
#       "bois vivant", "bois mort au sol", "bois mort sur pied",
#       "\\rowcolor{LightGray} \\textbf{Total}"
#     ))
#   ) %>%
#   arrange(name)
#   # pivot_wider(names_from = "variable", values_from = Moy)
#   # rename(
#   #   Gha = Moy,
#   #   Vha = CV,
#   #   )
#
#
# # bold total
#       label = ifelse(
#         attribute == "\\rowcolor{LightGray} \\textbf{Total}",
#         paste0("\\textbf{", label, "}"),
#         label
#       ),



























# carbon_results_by_wood_types <- set_up_main_results_by_attribute_table(
#   table = table,
#   var = var,
#   attribute = attribute,
#   # attribute_name = attribute_name,
#   forest_num = forest_num,
#   last_cycle = last_cycle,
#   precision_needed = F
# )
#
# # -- print table
# carbon_results_by_wood_types$print_table <-
#   carbon_results_by_wood_types$print_table %>%
#
#   # rename
#   rename(
#     !!attribute_name := "attribute",
#     !!paste0("\\textbf{", i18n()$t("G"), "\\hspace{2cm}\\scriptsize{", i18n()$t("(m2/ha)"), "}}") := "Gha"
#   )

# -- print table settings
digits_param = rep(0, dim(carbon_results_by_wood_types)[2] + 1)

# -- print tables
# 1st table
cat("\\begin{table}[h]\n\\centering")
print(
  xtable(
    carbon_results_by_wood_types,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(carbon_results_by_wood_types)[2] - 1)),
    caption = NULL,
    label = NULL
  ),
  caption.placement = "bottom",
  hline.after = -1:dim(carbon_results_by_wood_types)[1],
  floating = F,
  sanitize.text.function = function(x){return(x)},
  include.rownames = F,
  size = "\\footnotesize"
)

# space
cat("\n\\vspace{0.1cm}\n")

# 2nd table
print(
  xtable(
    carbon_results_variability,
    caption = NULL,
    digits = digits_param,
    align = c("M{0cm}|", "|M{4cm}|", rep("M{2cm}|", dim(carbon_results_variability)[2]-1)),
    label = NULL),
  include.rownames = FALSE,
  include.colnames = FALSE,
  sanitize.text.function = function(x){return(x)},
  hline.after = -1:dim(carbon_results_variability)[1],
  floating = F,
  size = "\\footnotesize"
)
cat(paste0("\\caption{", "Nombre de tiges et surface terrière des perches, déclinées par essence"), "}\n\\label{stems_species_distribution_table}\n\\end{table}")
@
\FloatBarrier

\subsection{Analyse par structure et par essence}
tableau analyse par structure + essence
<<carbon_stock_by_species_and_diam_cat_distribution_table, results = 'asis', fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
# -- carbon stock by population
living_trees_carbon <-
  gfForetFpied_EssenceCat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, Essence, Cat, tCha) %>%
  mutate(variable = "bois vivant")

fallen_dead_wood_carbon <-
  gfForetBMS_EssenceCat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, Essence, Cat, tCha) %>%
  mutate(variable = "bois mort au sol")

standing_dead_wood_carbon <-
  gfForetBMP_EssenceCat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(NumForet, Cycle, Essence, Cat, tCha) %>%
  mutate(variable = "bois mort sur pied")

   # -- call 'set_up_results_by_2_attributes_table'
results_with_attribute1_and_attribute2 <- rbind(
  living_trees_carbon,
  fallen_dead_wood_carbon,
  standing_dead_wood_carbon
)

  attribute1 <- "Essence" # row attribute
  attribute2 <- "Cat" # column attribute
  attribute1_levels <- main_species_order
  # attribute2_levels <- names(colour_aes_for_diameter_category)
  attribute2_levels <- names(colour_aes_for_diameter_category)
  var <- "tCha"
  attribute1_name <- "Essences"
  attribute1_total_label <- "\\textbf{Total par essence}"
  attribute2_total_label <- "\\textbf{Total par catégorie}"
  table_title <- "Répartition des stocks de carbone par catégorie de diamètre et par essence"
  table_label <- "species-diam_cat_distribution_table"
  align_parameters = NULL

  set_up_results_by_2_attributes_table(
    results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
    forest_num = forest_num,
    last_cycle = last_cycle,
    attribute1 = attribute1,
    attribute2 = attribute2,
    var = var,
    attribute1_name = attribute1_name,
    attribute1_levels = attribute1_levels,
    attribute2_levels = attribute2_levels,
    attribute1_total_label = attribute1_total_label,
    attribute2_total_label = attribute2_total_label,
    table_title = table_title,
    table_label = table_label,
    align_parameters
  )
@
\FloatBarrier

Figures stock par catégorie de diamètre + stock par essence\\

<<carbon_stock_species_distribution_pie_chart, size = 'footnotesize', fig.height = 4, fig.cap = "Importance relative des différentes essences.", fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
# -- carbon stock by population
living_trees_carbon <-
  gfForetFpied_Essence %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Essence, tCha) %>%
  mutate(variable = "bois vivant")

fallen_dead_wood_carbon <-
  gfForetBMS_Essence %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Essence, tCha) %>%
  mutate(variable = "bois mort au sol")

standing_dead_wood_carbon <-
  gfForetBMP_Essence %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Essence, tCha) %>%
  mutate(variable = "bois mort sur pied")


# -- table
pie_chart_table <- rbind(
  living_trees_carbon,
  fallen_dead_wood_carbon,
  standing_dead_wood_carbon
) %>%
  mutate(
    label_str = variable,
    label_y = 0.5,

    # sort species
    Essence = factor(Essence, levels = main_species_order)
  ) %>%
  arrange(Essence)


# -- theme sizes
  # TODO : faire une liste size pour tout le document ?
  # theme_sizes <- list(
  #   title = 7,
  #   text = 6,
  #   axis_title_x = 9,
  #   axis_text_x = 7,
  #   legend_text = 7
  # )

  # -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)

  # -- plot
build_pie_chart(
  table = pie_chart_table,
  # var = NULL,
  x = "variable",
  y = "tCha",
  attribute = "Essence",
  fill_scale_range = colour_aes_for_species,
  fill_scale_name = "Essences :",
  y_axis_name = "Part relative des essences",
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier

<<carbon_stock_diam_cat_distribution_pie_chart, size = 'footnotesize', fig.height = 4, fig.cap = "Importance relative des différentes essences.", fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
# -- carbon stock by population
living_trees_carbon <-
  gfForetFpied_Cat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Cat, tCha) %>%
  mutate(variable = "bois vivant")

fallen_dead_wood_carbon <-
  gfForetBMS_Cat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Cat, tCha) %>%
  mutate(variable = "bois mort au sol")

standing_dead_wood_carbon <-
  gfForetBMP_Cat %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(Cat, tCha) %>%
  mutate(variable = "bois mort sur pied")


# -- table
pie_chart_table <- rbind(
  living_trees_carbon,
  fallen_dead_wood_carbon,
  standing_dead_wood_carbon
) %>%
  mutate(
    label_str = variable,
    label_y = 0.5,

    # sort species
    Cat = factor(Cat, levels = rev(names(colour_aes_for_diameter_category)))
  ) %>%
  arrange(Cat)


# -- theme sizes
  # TODO : faire une liste size pour tout le document ?
  # theme_sizes <- list(
  #   title = 7,
  #   text = 6,
  #   axis_title_x = 9,
  #   axis_text_x = 7,
  #   legend_text = 7
  # )

  # -- grob settings
grob_settings <- list(
  layers = list(
    geom_bar = list(),
    geom_label = list(
      label.padding_unit.num = 0.15,
      label.r_unit.num = 0,
      fill = "gray70",
      size = 2.5,
      alpha = 0.8,
      fontface = "bold"
    )
  ),
  guides = list(
    fill = list(reverse = T)
  ),
  theme = list(
    title = list(size = 7),
    text = list(size = 6),
    axis.title.x = list(size = 9),
    axis.text.x = list(size = 7),
    legend.text = list(size = 7),
    legend.position = "right",
    legend.direction = "vertical",
    plot.margin_unit.num = c(0.1, 0.1, 0.1, 0.1)
  )
)

  # -- plot
build_pie_chart(
  table = pie_chart_table,
  # var = NULL,
  x = "variable",
  y = "tCha",
  attribute = "Cat",
  fill_scale_range = colour_aes_for_diameter_category,
  fill_scale_name = "Catégories\r\nde diamètre :",
  y_axis_name = "Part relative des catégories de diamètre",
  # plot_title = NULL,
  grob_settings = grob_settings
)
@
\FloatBarrier

\subsection{Analyse par durée de vie}
\textcolor{red}{en cours de développement - attention : les durées de vie pour les qualités de Pin semblent peu réalistes -> calcul f(qualités) à ajuster ?}
<<species-lifespan_relative_bar_chart, size = 'footnotesize', fig.height = 3, fig.cap = "Importance relative des durées de vie du carbone  stocké par les individus précomptables des différentes essences", fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
  # -- grob settings
  grob_settings <- list(
    layers = list(
      geom_bar = list(),
      geom_label = list(
        label.padding_unit.num = 0.15,
        label.r_unit.num = 0.15,
        fill = "white",
        size = 1.7,
        alpha = 1,
        fontface = "plain"
      )
    ),
    guides = list(
      fill = list(reverse = T)
    ),
    theme = list(
      title = list(size = 7),
      text = list(size = 7),
      axis.title.x = list(size = 9),
      axis.text.x = list(size = 7),
      axis.text.y = list(size = 6),
      legend.text = list(size = 7),
      legend.position = "bottom",
      legend.direction = "horizontal",
      plot.margin_unit.num = c(0.1, 0.3, 0.1, 0.1)
    )
  )

# -- colour for lifespan
colour_aes_for_lifespan <-
  c("#FEF0D9", "#FDD49E", "#FDBB84", "#FC8D59", "#EF6548", "#D7301F", "#990000")
names(colour_aes_for_lifespan) <-
  c("0-5", "5-10", "10-20", "20-30", "30-40", "40-50", "50-100")


# -- main table
table <-
  gfForetCarbone_EssenceLifetime %>%
  # filter & select
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(Essence, Lifetime, tCha) %>%

  # cut & summarise Lifetime
  mutate(Lifetime = ifelse(Lifetime %in% names(colour_aes_for_lifespan), Lifetime, "50-100")) %>%
  group_by(Essence, Lifetime) %>%
  summarise(tCha = sum(tCha, na.rm = T)) %>%
  ungroup() %>%

  pivot_longer(
    cols = "tCha",
    names_to = "variable",
    values_to = "value"
  ) %>%

  # calcul totaux
  group_by(Essence, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share and label, sort species
  mutate(
    # share
    share = value / total,

    # cut & sort Lifetime
    Lifetime = case_when(
      Lifetime %in% names(colour_aes_for_lifespan) ~ Lifetime,
      !Lifetime %in% names(colour_aes_for_lifespan) ~ "50-100"
    ),
    Lifetime = factor(
      Lifetime,
      levels = rev(names(colour_aes_for_lifespan))
    ),

    # # translation
    # Essence = i18n()$t(Essence),

    # sort species
    Essence = factor(Essence, levels = rev(standing_trees_species_order))
  ) %>%
  arrange(Essence, variable, desc(Lifetime)) %>%

  # calcul cumul share
  group_by(Essence) %>%
  mutate(cumul_share = cumsum(share)) %>%
  ungroup() %>%
  mutate(
    label_y = round(cumul_share - share / 2, 3),
    label_str = ifelse(share > 0.05, paste0(round(share * 100), " %"), NA)
  )

# -- pie chart plot
build_pie_chart(
  table = table,
  var = "tCha",
  x = "Essence",
  y = "value",
  attribute = "Lifetime",
  fill_scale_range = colour_aes_for_lifespan,
  fill_scale_name = "Durée de vie",
  y_axis_name = "Part relative des essences",
  plot_title = NULL,
  grob_settings = grob_settings,
  pie_chart = F
)
@
\FloatBarrier

<<diam_cat-lifespan_relative_bar_chart, size = 'footnotesize', fig.height = 3, fig.cap = "Importance relative des durées de vie du carbone  stocké par les individus précomptables des différentes catégories de diamètre", fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
  # -- grob settings
  grob_settings <- list(
    layers = list(
      geom_bar = list(),
      geom_label = list(
        label.padding_unit.num = 0.15,
        label.r_unit.num = 0.15,
        fill = "white",
        size = 1.7,
        alpha = 1,
        fontface = "plain"
      )
    ),
    guides = list(
      fill = list(reverse = T)
    ),
    theme = list(
      title = list(size = 7),
      text = list(size = 7),
      axis.title.x = list(size = 9),
      axis.text.x = list(size = 7),
      axis.text.y = list(size = 6),
      legend.text = list(size = 7),
      legend.position = "bottom",
      legend.direction = "horizontal",
      plot.margin_unit.num = c(0.1, 0.3, 0.1, 0.1)
    )
  )

# -- colour for lifespan
colour_aes_for_lifespan <-
  c("#FEF0D9", "#FDD49E", "#FDBB84", "#FC8D59", "#EF6548", "#D7301F", "#990000")
names(colour_aes_for_lifespan) <-
  c("0-5", "5-10", "10-20", "20-30", "30-40", "40-50", "50-100")


# -- main table
table <-
  gfForetCarbone_CatLifetime %>%
  # filter & select
  filter(Cycle == last_cycle & NumForet == forest_num) %>%
  select(Cat, Lifetime, tCha) %>%

  # cut & summarise Lifetime
  mutate(Lifetime = ifelse(Lifetime %in% names(colour_aes_for_lifespan), Lifetime, "50-100")) %>%
  group_by(Cat, Lifetime) %>%
  summarise(tCha = sum(tCha, na.rm = T)) %>%
  ungroup() %>%

  pivot_longer(
    cols = "tCha",
    names_to = "variable",
    values_to = "value"
  ) %>%

  # calcul totaux
  group_by(Cat, variable) %>%
  mutate(total = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # get share and label, sort species
  mutate(
    # share
    share = value / total,

    # cut & sort Lifetime
    Lifetime = case_when(
      Lifetime %in% names(colour_aes_for_lifespan) ~ Lifetime,
      !Lifetime %in% names(colour_aes_for_lifespan) ~ "50-100"
    ),
    Lifetime = factor(
      Lifetime,
      levels = rev(names(colour_aes_for_lifespan))
    ),

    # translation
    # Cat = i18n()$t(Cat),

    # sort species
    Cat = factor(Cat, levels = rev(names(colour_aes_for_diameter_category)[-1]))
  ) %>%
  arrange(Cat, variable, desc(Lifetime)) %>%

  # calcul cumul share
  group_by(Cat) %>%
  mutate(cumul_share = cumsum(share)) %>%
  ungroup() %>%
  mutate(
    label_y = round(cumul_share - share / 2, 3),
    label_str = ifelse(share > 0.05, paste0(round(share * 100), " %"), NA)
  )

# -- pie chart plot
build_pie_chart(
  table = table,
  var = "tCha",
  x = "Cat",
  y = "value",
  attribute = "Lifetime",
  fill_scale_range = colour_aes_for_lifespan,
  fill_scale_name = "Durée de vie",
  y_axis_name = "Part relative des catégories de diamètre",
  plot_title = NULL,
  grob_settings = grob_settings,
  pie_chart = F
)
@
\FloatBarrier

<<diam_cat-lifespan_distribution_table, results = 'asis', fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
   # -- call 'set_up_results_by_2_attributes_table'
results_with_attribute1_and_attribute2 <-
  gfForetCarbone_CatLifetime %>%
  # cut Lifetime
  mutate(Lifetime = ifelse(Lifetime %in% names(colour_aes_for_lifespan), Lifetime, "50-100"))

  attribute1 <- "Cat" # row attribute
  attribute2 <- "Lifetime" # column attribute
  attribute1_levels <- names(colour_aes_for_diameter_category)[-1]
  attribute2_levels <- names(colour_aes_for_lifespan)
  var <- "tCha"
  attribute1_name <- "Catégories de diamètre"
  attribute1_total_label <- "\\textbf{Total par catégorie}"
  attribute2_total_label <- "\\textbf{Total par durée de vie}"
  table_title <- "Répartition des stocks de carbone par durée de vie et par catégorie de diamètre"
  table_label <- "diam_cat-lifespan_distribution_table"
  align_parameters = list(first_column = 2, columns = 1.5)

  set_up_results_by_2_attributes_table(
    results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
    forest_num = forest_num,
    last_cycle = last_cycle,
    attribute1 = attribute1,
    attribute2 = attribute2,
    var = var,
    attribute1_name = attribute1_name,
    attribute1_levels = attribute1_levels,
    attribute2_levels = attribute2_levels,
    attribute1_total_label = attribute1_total_label,
    attribute2_total_label = attribute2_total_label,
    table_title = table_title,
    table_label = table_label,
    align_parameters
  )
@

<<species-lifespan_distribution_table, results = 'asis', fig.pos = "H", eval = eval_carbon, include = eval_carbon>>=
   # -- call 'set_up_results_by_2_attributes_table'
  results_with_attribute1_and_attribute2 <- gfForetCarbone_EssenceLifetime %>%
  # cut Lifetime
  mutate(Lifetime = ifelse(Lifetime %in% names(colour_aes_for_lifespan), Lifetime, "50-100"))

  attribute1 <- "Essence" # row attribute
  attribute2 <- "Lifetime" # column attribute
  attribute1_levels <- main_species_order
  attribute2_levels <- names(colour_aes_for_lifespan)
  var <- "tCha"
  attribute1_name <- "Essences"
  attribute1_total_label <- "\\textbf{Total par essence}"
  attribute2_total_label <- "\\textbf{Total par durée de vie}"
  table_title <- "Répartition des stocks de carbone par durée de vie et par essence"
  table_label <- "species-lifespan_distribution_table"
  align_parameters = list(first_column = 2, columns = 1.5)

  set_up_results_by_2_attributes_table(
    results_with_attribute1_and_attribute2 = results_with_attribute1_and_attribute2,
    forest_num = forest_num,
    last_cycle = last_cycle,
    attribute1 = attribute1,
    attribute2 = attribute2,
    var = var,
    attribute1_name = attribute1_name,
    attribute1_levels = attribute1_levels,
    attribute2_levels = attribute2_levels,
    attribute1_total_label = attribute1_total_label,
    attribute2_total_label = attribute2_total_label,
    table_title = table_title,
    table_label = table_label,
    align_parameters
  )
@
}{}


















\subsection{Indice de diversité de Shannon}
<<Shannon, echo=F, fig.height=7, fig.pos='H', fig.cap="Evolution de l'indice de diversité de Shannon.">>=
Shannon_DF <- filter(gfForetFpied_Essence,
             NumForet==forest_num & Cycle==last_cycle &
             Gha > 0) %>%
  select(NumForet,Essence,Gha) %>%
  group_by(NumForet) %>%
  mutate(Gha_Tot=sum(Gha,na.rm=T)) %>%
  ungroup() %>%
  mutate(Freq_Shannon=Gha/Gha_Tot,
         Shannon=Freq_Shannon*log2(Freq_Shannon))

Shannon_INDICE <- round(-sum(Shannon_DF$Shannon),2)

@

L'indice de diversité de Shannon est donné par la formule $ H = -\Sigma p_ilog_2(p_i)$ où $ p_i $ correspond au pourcentage de l'essence. Il est calculé en pourcentage de surface terrière.\\
L’indice de Shannon calculé sur les essences précomptables synthétise à la fois le nombre d’essences et leur répartition. Cet indice a un intérêt pour une comparaison dans le temps de son évolution. Pour rappel, une valeur de l’indice proche de zéro signifie que tous les individus du peuplement appartiennent à une seule et même espèce, ou que chaque espèce du peuplement est représentée par un seul individu. L’indice de Shannon est maximal quand tous les individus sont répartis d’une façon égale sur toutes les espèces. Sur la forêt, l’indice est de \Sexpr{Shannon_INDICE}.\\

% \clearpage
\subsection[Evaluation de l'état de conservation des habitats forestiers : analyse des données de structure]{Evaluation de l'état de conservation des habitats forestiers : analyse des données de structure\protect\footnote{Commission scientifique  et groupe forêts de Réserves naturelles de France. Evaluation de l'état de conservation (habitats forestiers et éco-complexes alluviaux). Cahier  RNF n°2. 2013, 72 p. La méthode est disponible en téléchargement sur le site internet de RNF (www.reserves-naturelles.org/publications/numero-2-des-cahiers-rnf-evaluation-de-l-etat-de-conservation-habitats-forestiers-et) ou sur demande (rnf@espaces-naturels.fr)}}

<<Comment_3.2.5, echo=F,message=F,results='asis',eval=F,include=F>>=
Comment <- filter(Comments, Section=="3.2.5")
cat(Comment$Texte)
@

La figure \ref{fig:conservation_evaluation_star_diagram} fournit une représentation de l'évaluation de l'état de conservation du peuplement forestier inventorié.
<<conservation_evaluation_star_diagram, fig.cap = i18n()$t("Évaluation de la structure forestière au regard de l'état de conservation (pour l'ensemble du dispositif)"), fig.pos = 'H', include=T, eval=T, fig.height = 3, dev = "cairo_pdf">>=
##### fonction pour la construction de la table des coordonnées du radars de l'état de conservation : #####
get_radar_coords <- function(group = NULL, tables_needed = NULL) { # à tester par habitat
 # group <- "Habitat" # debug
  # quo_group <- enquo(group)
  quo_group <- quo(!!parse_expr(group))

  # -- critère 1 ratio volume de bois mort / volume de bois total
  # arbres sur pied
  vol_bv <-
    tables_needed$grouped_results_of_Fpied_by_ %>%
    filter(!is.na(Vha) & Vha != 0) %>%
    select(NumForet, group, Cycle, Vha) %>%
    rename(VhaArbres = Vha)

  # perches
  vol_perches <-
    tables_needed$grouped_results_of_Per_by_ %>%
    filter(!is.na(Vha) & Vha != 0) %>%
    select(NumForet, group, Cycle, Vha) %>%
    rename(VhaPerches = Vha)

  # taillis
  vol_taillis <-
    tables_needed$grouped_results_of_Taillis_by_ %>%
    filter(!is.na(Vha) & Vha != 0) %>%
    select(NumForet, group, Cycle, Vha) %>%
    rename(VhaTaillis = Vha)

  # bmp
  vol_bmp <-
    tables_needed$grouped_results_of_BMP_by_ %>%
    filter(!is.na(Vha) & Vha != 0) %>%
    select(NumForet, group, Cycle, Vha) %>%
    rename(VhaBMP = Vha)

  # bms
  vol_bms <-
    tables_needed$grouped_results_of_BMS_by_ %>%
    filter(!is.na(Vha) & Vha != 0) %>%
    select(NumForet, group, Cycle, Vha) %>%
    rename(VhaBMS = Vha)

  volumes <-
    vol_bv %>%
    full_join(vol_perches, by = c("NumForet", group, "Cycle")) %>%
    full_join(vol_taillis, by = c("NumForet", group, "Cycle")) %>%
    full_join(vol_bmp, by = c("NumForet", group, "Cycle")) %>%
    full_join(vol_bms, by = c("NumForet", group, "Cycle")) %>%
    distinct() %>%
    group_by(NumForet, !!quo_group, Cycle) %>%
    mutate(
      BVivantT = sum(VhaArbres, na.rm = T) + sum(VhaTaillis, na.rm = T),
      BMortT = sum(VhaBMP, na.rm = T) + sum(VhaBMS, na.rm = T),
      BTot = sum(BVivantT, na.rm = T) + sum(BMortT, na.rm = T),
      # calcul du ratio
      RatioBMT = BMortT / BTot * 100,
      NoteRatioBMT = cut(
        RatioBMT,
        breaks = c(-Inf, 3, 5, 10, 15, 100),
        labels = c(1, 2, 3, 4, 5)
      )
    ) %>%
    ungroup() %>%
    select(NumForet, group, Cycle, NoteRatioBMT)

  # -- critère 2 : % de bois mort > 30
bm_30_rate <-
  tables_needed$grouped_results_of_BM_by_ %>%
  # filter(NumForet == Choix & Cycle == cycle_num) %>%

  mutate(
    RatioBM30 = (Vha_BMPsup + Vha_BMSsup) / Vha_total * 100, # TODO : il y avait une erreur de calcul (voir ancienne version)
    NoteRatioBM30 = cut(
      RatioBM30,
      breaks = c(-Inf, 5, 25, 50, 75, 100),
      labels = c(1, 2, 3, 4, 5))
  ) %>%
  select(NumForet, group, Cycle, NoteRatioBM30)

# -- critère 3 - diversité des stades de décomposition (sur le volume)
stadeD_diversity <-
  tables_needed$grouped_results_of_BM_by_StadeD %>%
  # filter(NumForet == Choix & Cycle == cycle_num) %>%
  select(NumForet, group, Cycle, StadeD, Vha_total) %>%
  group_by(NumForet, !!quo_group, Cycle) %>%
  mutate(
    Vha = Vha_total,
    VhaTot = sum(Vha, na.rm = T),
    RatioBMD = Vha / VhaTot * 100,
    NoteRatioBMD = ifelse(RatioBMD > 5, 1, 0)
  ) %>%
  group_by(NumForet, !!quo_group, Cycle) %>%
  summarise(NoteBMD = max(cumsum(NoteRatioBMD))) %>%
  ungroup() %>%
  select(NumForet, group, Cycle, NoteBMD)

# -- critère 4 - structure horizontale : diversité des classes de diamètre (sur la surface terrière)
# arbres
ba_bv <-
  tables_needed$grouped_results_of_Fpied_by_Classe %>%
  filter(!is.na(Gha) & Gha != 0) %>%
  select(NumForet, group, Cycle, Classe, Gha) %>%
  rename(GhaArbres = Gha)

# perches
ba_perches <-
  tables_needed$grouped_results_of_Per_by_Classe %>%
  filter(!is.na(Gha) & Gha != 0) %>%
  select(NumForet, group, Cycle, Classe, Gha) %>%
  rename(GhaPerches = Gha)

# taillis
ba_taillis <-
  tables_needed$grouped_results_of_Taillis_by_Classe %>%
  filter(!is.na(Vha) & Vha != 0) %>%
  select(NumForet, group, Cycle, Classe, Gha) %>%
  rename(GhaTaillis = Gha)

# surface terrières
basal_areas <-
  ba_bv %>%
  full_join(ba_perches, by = c("NumForet", group, "Classe", "Cycle")) %>%
  full_join(ba_taillis, by = c("NumForet", group, "Classe", "Cycle")) %>%
  mutate(
    GhaArbres = ifelse(is.na(GhaArbres), 0, GhaArbres),
    GhaPerches = ifelse(is.na(GhaPerches), 0, GhaPerches),
    GhaTaillis = ifelse(is.na(GhaTaillis), 0, GhaTaillis),
    Gha = GhaArbres + GhaTaillis
  ) %>%
  group_by(NumForet, !!quo_group, Cycle) %>%
  mutate(GhaTot = sum(Gha, na.rm = T)) %>%
  ungroup() %>%
  data.frame()

# diversité des classes de diamètre
class_diversity <-
  basal_areas %>%
  mutate(
    RatioGha = Gha / GhaTot * 100,
    NoteRatioGha = ifelse(RatioGha > 5, 1, 0)
  ) %>%
  group_by(NumForet, !!quo_group, Cycle) %>%
  summarise(CumGha = max(cumsum(NoteRatioGha), na.rm = T)) %>%
  ungroup() %>%
  mutate(
    Note = cut(
      CumGha,
      breaks = c(-Inf, 3, 4, 5, 6, +Inf),
      labels = c(1, 2, 3, 4, 5),
      right = F
    )
  ) %>%
  data.frame() %>%
  select(NumForet, group, Cycle, Note)

# -- critère 5 : % de TGB (% de G):
tgb_rate <-
  basal_areas %>%
  mutate(
    Cat = cut(
      Classe,
      breaks = c(-Inf, 17.5, 27.5, 47.5, 67.5, +Inf),
      labels = c("PER", "PB", "BM", "GB", "TGB")
    )
  ) %>%
  group_by(NumForet, !!quo_group, Cycle, Cat, GhaTot) %>%
  summarise(Gha = sum(Gha, na.rm = T)) %>%
  ungroup() %>%
  # sécurité
  filter(!is.na(Cat)) %>%
  # calcul du ratio
  mutate(RatioTGB = Gha / GhaTot * 100) %>%
  filter(Cat == "TGB") %>%
  mutate(
    NoteRatioTGB = cut(
      RatioTGB,
      breaks = c(-Inf, 0, 5, 10, 15, +Inf),
      labels = c(1, 2, 3, 4, 5),
      right = F
    )
  ) %>%
  select(NumForet, group, Cycle, NoteRatioTGB)

# -- assemblage des 5 critères
radar_coords <-
  volumes %>%
  full_join(
    bm_30_rate,
    by = c("NumForet", group, "Cycle")
  ) %>%
  full_join(
    stadeD_diversity,
    by = c("NumForet", group, "Cycle")
    ) %>%
  full_join(
    class_diversity,
    by = c("NumForet", group, "Cycle")
  ) %>%
  full_join(
    tgb_rate,
    by = c("NumForet", group, "Cycle")
  ) %>%
  mutate(
    NoteRatioBMT = ifelse(is.na(NoteRatioBMT), 1, NoteRatioBMT),
    NoteRatioBM30 = ifelse(is.na(NoteRatioBM30), 1, NoteRatioBM30),
    NoteRatioTGB = ifelse(is.na(NoteRatioTGB), 1, NoteRatioTGB),
    Note = ifelse(is.na(Note), 1, Note),
    NoteBMD = ifelse(is.na(NoteBMD), 1, NoteBMD),

    NoteRatioBMT = factor(NoteRatioBMT, levels = c("1", "2", "3", "4", "5")),
    NoteRatioBM30 = factor(NoteRatioBM30, levels = c("1", "2", "3", "4", "5")),
    NoteRatioTGB = factor(NoteRatioTGB, levels = c("1", "2", "3", "4", "5")),
    Note = factor(Note, levels = c("1", "2", "3", "4", "5"))
    # NoteBMD = factor(NoteBMD, levels = c("1", "2", "3", "4", "5"))
  ) %>%
  distinct() %>%
  mutate(
    NoteRatioBMT = as.numeric(NoteRatioBMT),
    NoteRatioBM30 = as.numeric(NoteRatioBM30),
    NoteBMD = as.numeric(NoteBMD),
    Note = as.numeric(Note),
    NoteRatioTGB = as.numeric(NoteRatioTGB)
  ) %>%
  rename(
    BMort = NoteRatioBMT,
    BMort30 = NoteRatioBM30,
    StadeD = NoteBMD,
    DivClasses = Note,
    PartTGB = NoteRatioTGB
  ) %>%
  select(group, BMort, BMort30, StadeD, DivClasses, PartTGB)

# -- retour de la fonction get_radar_coords
return(radar_coords)
}

##### 1/ Get radar coords #####
# liste des tables demandées
tables_needed <- list(
  grouped_results_of_Fpied_by_ = gfForetFpied_,
  grouped_results_of_Fpied_by_Classe = gfForetFpied_Classe,
  grouped_results_of_Per_by_ = gfForetPer_,
  grouped_results_of_Per_by_Classe = gfForetPer_Classe,
  grouped_results_of_Taillis_by_ = gfForetTaillis_,
  grouped_results_of_Taillis_by_Classe = gfForetTaillis_Classe,
  grouped_results_of_BMP_by_ = gfForetBMP_,
  grouped_results_of_BMS_by_ = gfForetBMS_,
  grouped_results_of_BM_by_ = gfForetBM_,
  grouped_results_of_BM_by_StadeD = gfForetBM_StadeD
)
# filter tables
tables_needed <- lapply(
  tables_needed,
  function(x) filter(x, NumForet == forest_num & Cycle == last_cycle)
)

plot_group = "Foret"
radar_coords <- get_radar_coords(plot_group, tables_needed) %>% select(-plot_group)

# number of plots -> defined plus haut

##### 2/ Figure #####
# preparation :

maxmin <- data.frame(
  BMort = c(5, 0),
  BMort30 = c(5, 0),
  StadeD = c(5, 0),
  DivClasses = c(5, 0),
  PartTGB = c(5, 0)
)

dat1 <- rbind(maxmin, radar_coords)
for (i in 1:dim(dat1)[2]) {
  dat1[, i] <- as.numeric(dat1[, i])
}

par(
  mar = c(0, 0, 1, 0),
  family = "Times",
  cex.main = 1,
  fig = c(0, 1, 0, 1),
  mgp = c(5, 5, 5)
)
radarchart(
  dat1,
  axistype = 1,
  pty = 32, pcol = "black",
  plty = 1, pdensity = 50, plwd = 0.3, pfcol = "salmon",
  title = paste(i18n()$t("Année"), last_year),
  centerzero = T, seg = 5, caxislabels = c(0, 1, 2, 3, 4, 5), calcex = 0.8,
  vlcex = 0.85,
  vlabels = c(
    str_wrap(i18n()$t("Rapport : BMort/BTotal"), 10),
    str_wrap(i18n()$t("Rapport : BMort≥30/BMort total"), 10),
    str_wrap(i18n()$t("Stades de pourriture présents"), 10),
    str_wrap(i18n()$t("Diversité des classes de diamètre"), 10),
    str_wrap(i18n()$t("Part de TGB"), 10)
  )
)
# TODO : voir si rajouter le nombre de placettes ? ->  a priori non : info déjà connue
# text(
#   x = 0.75,
#   y = 0.9,
#   labels = paste0(str_wrap(i18n()$t("Nombre de placettes : "), 10), plot_nb),
#   cex = 0.75, # numeric character expansion factor
#   col = "firebrick" # color font
# )
@
\FloatBarrier




























































\FloatBarrier



% \chapter{Bilan de la gestion passée}

% \section{Bilan financier}
% \subsection{Evolution du capital argent}

% La figure \ref{fig:EvolCap1} montre l'évolution des valeurs de consommation et potentielles au cours du temps. La figure \ref{fig:EvolCap2} fournit leurs fonctions de répartition au cours du temps.
<<EvolCap1, echo=F, fig.height=2, fig.cap="Evolution comparée des valeurs de consommation et potentielles au cours du temps.", fig.pos='H', eval=F, include=F>>=
t1 <- subset(gfForetFpied_, NumForet==forest_num, select=c(Cycle, VcHa, VpHa))
t1 <- melt(t1, id="Cycle")
t1 <- melt(t1, id="Cycle")
ggplot(t1, aes(x=Cycle, y=value, color=variable)) + geom_line() + MyTheme + ylim(c(0,max(t1$value))) +
  labs(y="Valeur en euro/ha", color="")
@

<<TabFinance, echo=F, eval=F, include=F>>=
b <- subset(Arbres, NumForet==forest_num, select=c("Cycle","Taux","Vha","VcHa","VpHa","Coupe"))
b <- subset(b, !is.na(Taux))
b <- b[order(b$Cycle,b$Taux),]
c <- data.frame()
for (i in 1:max(b$Cycle)) {
  d <- subset(b, Cycle==i)
  for (j in 3:(dim(d)[2]-1)) {
    somme <- sum(d[,j], na.rm=T)
    d[,j] <- cumsum(d[,j])/somme
  }
  c <- rbind(c,d)
}
c.m <- melt(c, id=c("Cycle","Taux","Coupe"))
c.m$Titre <- paste0("Cycle ", c.m$Cycle)
# c.m$Cycle <- as.factor(c.m$Cycle)
@

<<EvolCap2, echo=F, fig.height=3, fig.pos='H', fig.cap="Fonctions de répartition des valeurs de consommation et potentielles.", eval=F, include=F>>=
a.m <- subset(c.m, variable!="Vha")
ggplot(a.m, aes(x=Taux, y=value, color=factor(Cycle))) +
  geom_line() +
  facet_wrap(~ variable, ncol=2, scales="free_y") +
  xlim(c(0,0.15)) +
  geom_segment(aes(x = 0, y = 0.1, xend = 0.03, yend = 0.1),
               linetype=3, color='grey') +
  labs(y="Fonction de répartition", color="Cycle") +
  MyTheme +
  theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
        strip.background = element_rect(fill=NA, colour=NA))
@


% La figure \ref{fig:EvolCap3} permet de mesurer l'impact d'un prélèvement sur la valeur potentielle.
<<EvolCap3, echo=F, fig.height=4, fig.cap="Evolution comparée des valeurs de consommation et potentielles.", fig.pos='H', eval=F, include=F>>=
ggplot(c, aes(x=VcHa, y=VpHa, color=factor(Cycle))) + geom_line() + MyTheme + labs(color="Cycle")
@

% \FloatBarrier
% \subsection{Prise en compte des risques}
%
% \FloatBarrier
% \subsubsection{Temps de rotation du capital}
% \subsubsection{Taux d'accroissement et temps de rotation du capital volume et argent}
% Le tableau \ref{Taux} fournit les taux d'accroissement et les temps de passage en volume (TauxV et TempsV) et en argent (TauxA et TempsA). Les taux sont exprimés en \% et les temps de rotation en années\footnote{Dans des peuplements en équilibre, les temps de rotations du volume sont compris entre 35 et 45 ans.}.

<<Taux, echo=F, results='asis', fig.pos="H", comment=F, eval=F, include=F>>=
# tab <- subset(gfForet, NumForet==forest_num)
# tab$TauxA <- tab$GainHa/tab$VcHa*100
# tab$TauxV <- tab$AcctVHa/tab$Vha*100
# tab$TempsV <- 100/tab$TauxV
# tab$TempsA <- 100/tab$TauxA
#
# print(xtable(tab[,c(2,12:15)],
#              caption = "Taux d'accroissement et temps de rotation du capital volume et argent.",
#              caption.placement = "top",
#              digits=c(0,0,1,1,0,0),
#              align=rep("c",dim(tab)[2]+1),
#              label = "Taux"),
#       include.rownames=F,
#       size="\\footnotesize")


t <- filter(gfForetFpied_,
            NumForet==forest_num) %>%
  mutate(TauxA=Gainper/VcHa*100,
         TauxV=AcctVper/Vha*100,
         TempsV=100/TauxV,
         TempsA=100/TauxA) %>%
  select(Cycle,TauxA,TauxV,TempsA,TempsV)
print(xtable(t,
             caption = "Taux d'accroissement et temps de rotation du capital volume et argent.",
             caption.placement = "top",
             digits=c(0,0,1,1,0,0),
             align=rep("c",dim(t)[2]+1),
             label = "Taux"),
      include.rownames=F,
      size="\\footnotesize")
@

<<Plasticite, echo=F, message=F, comment=NA, warning=NA, fig.height=4, eval=F, include=F>>=
# t <- filter(Arbres, NumForet==forest_num) %>%
#   select(NumForet,Cycle,Taux,VcHa,VpHa) %>%
#   arrange(Taux) %>%
#   group_by(Cycle) %>%
#   mutate(TotVpHa=sum(VpHa,na.rm=T),
#          TotVcHa=sum(VcHa,na.rm=T),
#          CumVpHa=cumsum(VpHa)/TotVpHa,
#          CumVcHa=cumsum(VcHa)/TotVcHa) %>%
#   ungroup()
# pos <- which(t$CumVcHa>0.5)
# p <- ggplot() +
#   geom_line(t, mapping=aes(CumVcHa, CumVpHa, col=factor(Cycle))) +
#   geom_vline(xintercept=0.5, linetype=2) +
#   geom_hline(yintercept=t$CumVpHa[min(pos,na.rm=T)-1]) +
#   scale_x_continuous(expand=c(0,0)) +
#   scale_y_continuous(expand=c(0,0)) +
#   theme_bw()

t <- filter(Arbres, NumForet==forest_num) %>%
  select(NumForet,Cycle,Taux,VcHa,Vha) %>%
  arrange(Taux) %>%
  group_by(Cycle) %>%
  mutate(TotVha=sum(Vha,na.rm=T),
         TotVcHa=sum(VcHa,na.rm=T),
         CumVha=cumsum(Vha)/TotVha,
         CumVcHa=cumsum(VcHa)/TotVcHa) %>%
  ungroup()
t2bis <- group_by(t, Cycle) %>%
  filter(CumVcHa < 0.5) %>%
  rename(CumVhabis=CumVha) %>%
  summarise(CumVhabis=max(CumVhabis, na.rm=T)) %>%
  ungroup()
t2 <- group_by(t, Cycle) %>%
  filter(CumVcHa > 0.5) %>%
  summarise(CumVha=min(CumVha, na.rm=T)) %>%
  ungroup() %>%
  full_join(t2bis,by="Cycle") %>%
  mutate(CumVha=(CumVha+CumVhabis)/2)
# Palette <- c("red","green","blue","gold","gray")
p <- ggplot() +
  geom_line(t, mapping=aes(CumVcHa, CumVha, col=factor(Cycle))) +
  geom_vline(xintercept=0.5, linetype=2) +
  geom_hline(t2, mapping=aes(yintercept=CumVha[Cycle], col=factor(Cycle)), linetype=2) +
  # geom_text(t2, mapping=aes(1:dim(t2)[1]/10, y=CumVha, label=round(CumVha,1)))
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0)) +
  labs(x="Valeur de consommation (€/ha)",
       y="Volume (m3/ha)",
       colour="Cycle") +
  theme_bw() +
  theme(axis.title=element_text(size=8),
        axis.text=element_text(size=7),
        legend.title=element_text(size=8),
        legend.text=element_text(size=7))
p
# pg <- ggplot_build(p)



#  a <- pg$data[[1]]
@

% \FloatBarrier
% \subsubsection{Vitesse de cicatrisation}
%
% \FloatBarrier
% \subsection{Recettes / Dépenses}

<<Depenses, echo=FALSE, message=F, eval=F, include=F>>=
CoefActu <- rename(CoefActu,Annee=Année)
surf <- Dispositifs$SurfParc[which(Dispositifs$NumForet==forest_num)]
depart <- InfosSuiviEco[which(InfosSuiviEco$NumForet==forest_num),"DépartSuiviEco"]
fin <- max(CoefActu$Annee)

t <- filter(Depenses,NumForet==forest_num) %>%
  rename(Annee=Année) %>%
  select(Annee,TotalHT,Code) %>%
  # merge(CoefActu,by.x="Annee",by.y="Année")
  left_join(CoefActu) %>% # ,by=c("Année"="Annee")
  mutate(Montant=TotalHT*CoefActu) %>%
  group_by(Code) %>%
  summarise(Montant=sum(Montant,na.rm=T)) %>%
  ungroup() %>%
  right_join(PlanComptable) %>%
  rename(Categorie=Catégorie)
Cout <- filter(t,
             Categorie %in% c("Exploitation","Entretien du capital",
                              "Soins aux peuplements","Martelage",
                              "Frais de gestion forestière","Frais généraux",
                              "Dotations aux comptes d'amortissement","Impôts") &
               !is.na("Montant")) %>%
  select(Code,Montant,Categorie) %>%
  group_by(Categorie) %>%
  summarise(Montant=sum(Montant,na.rm=T),
            Montant=Montant/(fin-depart+1)/surf) %>%
  ungroup()
Vente <- filter(Recettes,NumForet==forest_num) %>%
  rename(Annee=Année) %>%
  select(Annee,Volume,PU) %>%
  left_join(CoefActu) %>% #,by=c("Annee"="Année")
  mutate(Montant=Volume*PU,
         Montant=Montant*CoefActu)
Recette <- filter(t,
                  Categorie %in% c("Recettes bois","Recettes Chasse","Subvention","Autres recettes") &
                    !is.na("Montant")) %>%
  select(Code,Montant,Categorie) %>%
  group_by(Categorie) %>%
  summarise(Montant=sum(Montant,na.rm=T)) %>%
  ungroup() %>%
  mutate(Montant=ifelse(Categorie=="Recettes bois",
                        Montant+sum(Vente$Montant,na.rm=T),
                        Montant),
         Montant=Montant/(fin-depart+1)/surf)




# surf <- Dispositifs$SurfParc[which(Dispositifs$NumForet==forest_num)]
# t1 <- subset(Depenses, NumForet==forest_num, select=c(Année,TotalHT,Code))
# t1 <- merge(t1, CoefActu, by="Année", all.x=T)
# t1$Montant <- t1$TotalHT*t1$CoefActu
# t2 <- summaryBy(Montant ~ Code, data=t1, FUN=sum, na.rm=T, keep.names=T)
# t3 <- merge(PlanComptable[1:23,c(1,3)], t2, by="Code", all.x=T)
# Cout <- summaryBy(Montant ~ Catégorie , data=t3, FUN=sum, na.rm=T, keep.names=T)
# depart <- InfosSuiviEco[which(InfosSuiviEco$NumForet==forest_num),"DépartSuiviEco"]
# fin <- max(CoefActu$Année)
# Cout$Montant <- Cout$Montant/(fin-depart+1)/surf
#
# t3 <- merge(PlanComptable[-(1:23),c(1,3)], t2, by="Code", all.x=T)
# recettes <- summaryBy(Montant ~ Catégorie , data=t3, FUN=sum, na.rm=T, keep.names=T)
# recettes$Montant <- recettes$Montant/(fin-depart+1)/surf
#
# t1 <- subset(Recettes, NumForet==forest_num, select=c(Année,Volume,PU))
# t1$Montant <- t1$Volume*t1$PU
# t1 <- merge(t1, CoefActu, by="Année", all.x=T)
# t1$Montant <- t1$Montant*t1$CoefActu
# recettes$Montant[2] <- sum(t1$Montant, na.rm=T)/(fin-depart+1)/surf
@

% Pour ce dispositif, \Sexpr{depart} correspond à l'année de début de suivi économique. Les montants indiqués dans le tableau ci-dessous sont exprimés en euros \Sexpr{fin}. \\
%
%
% \begin{tabular}{|p{6cm}|r|p{7cm}|r|}
% \hline
% \multicolumn{2}{|c|}{Recettes} & \multicolumn{2}{c|}{Dépenses} \\
% \hline
% Catégorie & Montant  & Catégorie & Montant \\
% \hline
% Autres recettes & \Sexpr{round(Recette[1,2],2)} & Dotations aux comptes d'amortissement & \Sexpr{round(Cout[1,2],2)} \\
% Recettes bois & \Sexpr{round(Recette[2,2],2)} & Entretien du capital & \Sexpr{round(Cout[2,2],2)} \\
% Recettes Chasse & \Sexpr{round(Recette[3,2],2)} & Exploitation & \Sexpr{round(Cout[3,2],2)} \\
% Subvention & \Sexpr{round(Recette[4,2],2)} & Frais de gestion forestière & \Sexpr{round(Cout[4,2],2)} \\
%  &  & Frais généraux & \Sexpr{round(Cout[5,2],2)} \\
%  &  & Impôts & \Sexpr{round(Cout[6,2],2)} \\
%  &  & Martelage & \Sexpr{round(Cout[7,2],2)} \\
%  &  & Soins aux peuplements & \Sexpr{round(Cout[8,2],2)} \\
% \hline
% Total & \Sexpr{round(sum(Recette[,2]),2)} & Total & \Sexpr{round(sum(Cout[,2]),2)} \\
% \hline
% \end{tabular}
<<Recettes>>=

@
% \FloatBarrier
% \section{Martelage}
% La figure \ref{fig:Martelage} permet une première analyse des martelages.
<<Martelage, echo=F, fig.height=5, fig.cap="Prélèvements", eval=F, include=F>>=
b <- subset(Arbres, NumForet==forest_num, select=c("Cycle","Taux","Vha","VcHa","VpHa","Coupe"))
b <- subset(b, !is.na(Taux))
b <- b[order(b$Cycle,b$Taux),]
b <- b[order(b$Coupe),] %>%
   mutate(Titre=paste0("Cycle ",Cycle),
         Coupe=ifelse(Coupe=="E","Récolté",Coupe),
         Coupe=ifelse(Coupe=="PF/E","Récolté",Coupe),
         Coupe=ifelse(Coupe=="C","Chablis",Coupe),
         Coupe=ifelse(Coupe=="PF","Sur pied",Coupe),
         Coupe=ifelse(Coupe=="","Sur pied",Coupe),
         Coupe=factor(Coupe, levels=c("Sur pied", "Chablis", "Récolté")))
ggplot(b, aes(x=VcHa, y=VpHa, color=Coupe)) +
  geom_point(alpha=0.9) +
  geom_abline(intercept = 0, slope = 1, colour="grey60") +
  # scale_y_log10(expand=c(0,0)) +
  # scale_x_log10(expand=c(0,0)) +
  scale_colour_manual(name="Prélèvement",
                      values=c("limegreen", "dodgerblue", "red3"),
                      # label=c("Exploitation","Chablis"),
                      na.value="grey90") +
  labs(x="Valeur de consommation (€/ha)",y="Valeur potentielle (€/ha)") +
  facet_wrap(~ Titre, ncol=3) +
  MyTheme + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                  strip.background = element_rect(fill=NA, colour=NA))
@

<<Martelage2, echo=F,fig.height=3, fig.width=3.2, fig.cap="Prélèvements", eval=F, include=F>>=
t1 <- filter(Arbres,
             NumForet==forest_num & Coupe=="E")
t2 <- group_by(t1,
               Cycle,Cat) %>%
  summarise(VpHa=sum(VpHa,na.rm=T),
            VcHa=sum(VcHa,na.rm=T)) %>%
  ungroup() %>%
  melt(id=c("Cycle","Cat")) %>%
  mutate(variable=ifelse(variable=="VpHa","Vp","Vc")) %>%
  arrange(Cat)
t3 <- group_by(t1,
               Cycle,Reg1) %>%
  summarise(VpHa=sum(VpHa,na.rm=T),
            VcHa=sum(VcHa,na.rm=T)) %>%
  ungroup() %>%
  melt(id=c("Cycle","Reg1")) %>%
  mutate(variable=ifelse(variable=="VpHa","Vp","Vc")) %>%
  arrange(Reg1)

ggplot(t2,
       aes(x=factor(Cycle), y=value, fill=Cat)) +
  geom_bar(stat= "identity", position = "stack") +
  labs(x="Cycle", y="Valeur (€/ha)") +
  guides(fill=guide_legend(title="Catégories\nde diamètre",reverse=T)) +
  facet_wrap(~ variable) +
  theme_bw() + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                     strip.background = element_rect(fill=NA, colour=NA))
ggplot(t3,
       aes(x=factor(Cycle), y=value, fill=Reg1)) +
  geom_bar(stat= "identity", position = "stack") +
  guides(fill=guide_legend(title="Qualité",reverse=T)) +
  labs(x="Cycle", y="Valeur (€/ha)") +
  facet_wrap(~ variable) + theme_bw() + theme(strip.text = element_text(size = 7, colour="lightsteelblue4", face="bold"),
                                              strip.background = element_rect(fill=NA, colour=NA))

# t1 <- subset(Arbres, NumForet==forest_num & Coupe == "E")
# t2 <- summaryBy(VpHa + VcHa ~  Cycle + Cat, data = t1, FUN = sum, na.rm = T, keep.names = T)
# t3 <- summaryBy(VpHa + VcHa ~  Cycle + Reg1, data = t1, FUN = sum, na.rm = T, keep.names = T)
# t2.m <- melt(t2, id=c("Cycle","Cat")) %>%
#   arrange(Cat)
# t3.m <- melt(t3, id=c("Cycle","Reg1"))
#
# ggplot(t2.m,
#        aes(x=factor(Cycle), y=value, fill=Cat)) +
#   geom_bar(stat= "identity", position = "stack") +
#   labs(x="Cycle", y="Valeur (€/ha)") +
#   guides(fill=guide_legend(reverse=T)) +
#    facet_wrap(~ variable) + theme_bw()
# ggplot(t3.m,
#        aes(x=factor(Cycle), y=value, fill=Reg1)) +
#   geom_bar(stat= "identity", position = "stack") +
#   guides(fill=guide_legend(reverse=T)) +
#   labs(x="Cycle", y="Valeur (€/ha)") +
#    facet_wrap(~ variable) + theme_bw()
@
\FloatBarrier



%%%%%%%%%%%%%%%%%%%% Tronches des chapitres pour les annexes
\titleformat{\chapter}[frame]
{\normalsize}%
{\filright\sffamily\Large%
\enspace Annexe \thechapter\enspace}%
{8pt}
{\sffamily\Huge\bfseries\filcenter}

% ----- Numérotation figures en fonction des chapitres :
\counterwithin{figure}{chapter}
\begin{appendices}

% \chapter{\Sexpr{i18n()$t("Regroupements d'essence")}}\label{Regroupement}
% Le tableau \ref{grouped_species_table} liste les regroupements d'essence.
<<grouped_species_table, results = 'asis', eval = F, include = F>>=
# table
table <-
  EssReg %>%
  filter(NumForet == forest_num) %>%
  select(Essence, EssReg) %>%
  arrange(EssReg) %>%
  
  # translation
  mutate(
    Essence = i18n()$t(Essence),
    EssReg = i18n()$t(EssReg)
  ) %>% 
  
  # merge rows
  set_multirow_table(2) %>%
  
  # rename
  rename(
    !!i18n()$t("Essence") := "Essence",
    !!i18n()$t("Essences regroupées") := "EssReg"
    )

# print
pos_NA <- which(!is.na(table[, 2]))
print(
  xtable(
    table,
    label = "grouped_species_table",
    align = c("l", "l", "|c"),
    caption = i18n()$t("Regroupements d'essence"),
    caption.placement = "bottom"
  ),
  include.rownames = F,
  sanitize.text.function = function(x) return(x),
  hline.after = c(-1, pos_NA - 1, dim(t)[1]),
  size = "\\footnotesize"
)
@

\chapter{\Sexpr{i18n()$t("Echantillon")}}
\EditIf{\Sexpr{FALSE}}{TRUE}{Les figures \ref{fig:Echantillonnage_DiamDist} et \ref{fig:Echantillonnage_DiamDist_BMP} permettent}{La figure \ref{fig:Echantillonnage_DiamDist} permet} de vérifier le bon respect du protocole ainsi que de détecter d'éventuels arbres limites. % initialement, test est :\EditIf{\Sexpr{eval_BMP}}{TRUE}{

<<Echantillonnage_DiamDist, fig.height=4, fig.cap= "\\footnotesize{Vérification de l'échantillon (pour les arbres vivants précomptables et repérés en azimut/distance dans le dernier inventaire).}", eval = T, include = T>>=
# -- parameters_table
parameters_table <-
  Echantillonnages %>%
  # filter # TODO : gérer plusieurs strates ? à voir si le case se présente
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(
    DiamLim1, Rayon1, DiamLim2, Rayon2,
    DiamLim3, Rayon3, Coeff, DiamLim
  ) %>%
  pivot_longer(cols = everything()) %>%
  filter(!is.na(value)) %>%

  mutate(
    type = ifelse(grepl("DiamLim", name), "diam_seuil", "parametre"),
    methode = ifelse(name %in% c("Coeff", "DiamLim"), "angle", "surface")
  )

Type_PALETTE <- c(21:23)
names(Type_PALETTE) <- c("AV", "BMPinf30", "BMPsup30")

Type_PALETTE2 <- c("limegreen", "black", "black")
names(Type_PALETTE2) <- c("AV", "BMPinf30", "BMPsup30")

Type_PALETTE3 <- c(0.3, 1, 1)
names(Type_PALETTE3) <- c("AV", "BMPinf30", "BMPsup30")

Limite_PALETTE <- c("red", "black")
names(Limite_PALETTE) <- c(1, 0)

plot_table <- rbind(
  Arbres %>% select(Dist, Diam1, Diam, Type, Limite),
  BMP %>% mutate(Diam1 = Diam) %>% select(Dist, Diam1, Diam, Type, Limite)
) %>%
  mutate(
    Type = ifelse(
      !is.na(Type),
      ifelse(Diam < 30, "BMPinf30", "BMPsup30"),
      Type
    ),
    Type = ifelse(is.na(Type), "AV", Type),
    Type = factor(Type, levels = names(Type_PALETTE)),

    Limite = ifelse(is.na(Limite), 0, Limite),
    Limite = factor(Limite, levels = names(Limite_PALETTE))
  )

# -- plot
# dist_max & Diam1_max
dist_max <- max(plot_table$Dist, na.rm = T)
dist_max <- if (dist_max < 20) 20 else dist_max
Diam1_max <- max(plot_table$Diam1, na.rm = T)


# -- plot
plot <-
  ggplot(plot_table) +
  geom_point(aes(
    Dist, Diam1, shape = Type,
    fill = Type, alpha = Type, colour = Limite
  )) +
  # legends
  scale_shape_manual(
    values = Type_PALETTE,
    drop = F,
    label = c(
      "Arbres vivants",
      "Bois mort sur pied - Diam < 30",
      "Bois mort sur pied - Diam > ou = 30"
    )
  ) +
  scale_fill_manual(
    values = Type_PALETTE2,
    drop = F,
    label = c(
      "Arbres vivants",
      "Bois mort sur pied - Diam < 30",
      "Bois mort sur pied - Diam > ou = 30"
    )
  ) +
  scale_alpha_manual(
    values = Type_PALETTE3,
    drop = F,
    label = c(
      "Arbres vivants",
      "Bois mort sur pied - Diam < 30",
      "Bois mort sur pied - Diam > ou = 30"
    )
  ) +
  scale_colour_manual(
    values = Limite_PALETTE,
    drop = F,
    label = c("Arbre limite", "Arbre de l'inventaire")
  ) +

  # scales
  scale_x_continuous(
    expand = c(0, 0),
    limits = c(0, dist_max * 1.1),
    breaks = seq(0, floor(dist_max / 5 + 0.5) * 5 * 1.3, 5)
  ) +
  scale_y_continuous(
    expand = c(0, 0),
    limits = c(0, Diam1_max * 1.1),
    breaks = seq(0, floor(Diam1_max / 5 + 0.5) * 5 * 1.3, 10)
  ) +
  guides(
    shape = guide_legend(order = 1),
    fill = guide_legend(order = 1),
    alpha = guide_legend(order = 1),
    colour = guide_legend(
      order = 2,
      override.aes = list(shape = 1, size = 1.75, alpha = 0.5)
    )
  ) +
  theme_bw() +
  theme(
    axis.text.x  = element_text(size = 8),
    axis.title.x  = element_text(size = 9),
    axis.title.y  = element_text(size = 9),
    axis.text.y  = element_text(size = 8),
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )

# -- add surface parameters
if ("surface" %in% parameters_table$methode)  {
  plot <- plot +
    # vertical line
    geom_vline(
      xintercept = with(parameters_table, value[
        type == "parametre" & methode == "surface"]),
      colour = "dodgerblue3",
      linetype = 2,
      size = 0.5
    ) +
    # horizontal line
    geom_hline(
      yintercept = with(parameters_table, value[
        type == "diam_seuil" & methode == "surface"]),
      colour = "dodgerblue3",
      linetype = 2,
      size = 0.5
    )
}
# -- add surface parameters
if ("surface" %in% parameters_table$methode) {
  plot <- plot +
    # diagonal line
    geom_abline(
      intercept = 0,
      slope = with(parameters_table, value[
        type == "parametre" & methode == "angle"]) * 100,
      colour = "dodgerblue3",
      linetype = 2
    ) +
    # horizontal line
    geom_hline(
      yintercept = with(parameters_table, value[
        type == "diam_seuil" & methode == "angle"]),
      colour = "dodgerblue3",
      linetype = 2,
      size = 0.5
    )
}

plot
@
\FloatBarrier

% \textcolor{red}{\textbf Arbres morts inventoriés via PCQM -> pas de figure d'échantillonnage prévue}
% <<Echantillonnage_DiamDist_BMP, echo = F, comment = NA, warning = FALSE, fig.pos = 'H', fig.height = 4, fig.cap = "\\footnotesize{Vérification de l'échantillon (pour les arbres morts repérés en azimut/distance dans le dernier inventaire).}", eval = F, include = F>>=
% # eval = eval_BMP, include = eval_BMP
%
% ArbresPlot_DF <-
%   Arbres_DF %>%
%   select(NumForet, NumPlac, Azimut, Dist, Diam1, Limite, Type) %>%
%   mutate(
%     Type = ifelse(is.na(Type), "AV", Type),
%     Type = factor(Type, levels = names(Type_PALETTE)),
%
%     Limite = ifelse(is.na(Limite), 0, Limite),
%     Limite = factor(Limite, levels = names(Limite_PALETTE))
%   ) %>%
%   filter(Type != "AV")
%
% p1 <-
%   ggplot() +
%   geom_point(
%     ArbresPlot_DF,
%
%     mapping = aes(
%       Dist, Diam1,
%       shape = Type,
%       fill = Type,
%       colour = Limite,
%       alpha = Type
%     )
%   ) +
%   scale_shape_manual(
%     values = Type_PALETTE,
%     label = c(
%       "Arbres vivants",
%       "Bois mort sur pied (arbre)",
%       "Bois mort sur pied (chandelle)",
%       "Bois mort sur pied (souche)"
%     )
%   ) +
%   scale_fill_manual(
%     values = Type_PALETTE2,
%     label = c(
%       "Arbres vivants",
%       "Bois mort sur pied (arbre)",
%       "Bois mort sur pied (chandelle)",
%       "Bois mort sur pied (souche)"
%     )
%   ) +
%   scale_alpha_manual(
%     values = Type_PALETTE3,
%     label = c(
%       "Arbres vivants",
%       "Bois mort sur pied (arbre)",
%       "Bois mort sur pied (chandelle)",
%       "Bois mort sur pied (souche)"
%     )
%   ) +
%   scale_colour_manual(
%     values = Limite_PALETTE,
%     label = c("Arbre limite", "Arbre de l'inventaire")
%   ) +
%
%   geom_hline(yintercept = Rayons, colour = "dodgerblue3", linetype = 2, size = 0.5) +
%   geom_abline(intercept = 0, slope = Angle, colour = "dodgerblue3", linetype = 2) +
%   geom_vline(xintercept = c(10, 20), colour = "dodgerblue3", linetype = 2, size = 0.5) +
%   scale_x_continuous(
%     expand = c(0, 0),
%     limits = c(0, X_lim * 1.1),
%     breaks = seq(0, floor(X_lim / 5 + 0.5) * 5 * 1.3, 5)
%   ) +
%   scale_y_continuous(
%     expand = c(0, 0),
%     limits = c(0, max(ArbresPlot_DF$Diam1, na.rm = T) * 1.1),
%     breaks = seq(0, floor(max(ArbresPlot_DF$Diam1, na.rm = T) / 5 + 0.5) * 5 * 1.3, 10)
%   ) +
%   guides(
%     shape = guide_legend(order = 1),
%     fill = guide_legend(order = 1),
%     alpha = guide_legend(order = 1),
%     colour = guide_legend(
%       order = 2,
%       override.aes = list(shape = 1, size = 1.75, alpha = 0.5)
%     )
%   ) +
%   theme_bw() +
%   theme(
%     axis.text.x = element_text(size = 8),
%     axis.title.x = element_text(size = 9),
%     axis.title.y = element_text(size = 9),
%     axis.text.y = element_text(size = 8),
%     plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
%   )
%
% p1
% @
% \FloatBarrier

\chapter{\Sexpr{i18n()$t("Tarifs de cubage")}}
\Sexpr{i18n()$t("Le tableau")} \ref{tariff_table} \Sexpr{i18n()$t("rappelle les tarifs de cubage retenus. Les tarifs de cubage par essence sont fournis par le gestionnaire de la forêt. Ils sont ensuite convertis en tarifs Schaeffer.")}

<<tariff_table, results = 'asis'>>=
# -- table
tab <-
  Tarifs %>%
  filter(NumForet == forest_num) %>%

  # translation
  mutate(Essence = i18n()$t(Essence)) %>%

  select(Essence,TypeTarif,NumTarif) %>%
  rename(
    !!i18n()$t("Essence") := "Essence",
    !!i18n()$t("Type de tarif") := "TypeTarif",
    !!i18n()$t("Numéro") := "NumTarif"
  )

# -- print
print(
  xtable(
    tab,
    caption = i18n()$t("Tarifs de cubage retenus"),
    digits = rep(0, 4), label = "tariff_table"
  ),
  caption.placement = "top",
  include.rownames = F,
  size = "\\footnotesize"
)
@
\FloatBarrier

\fancychapterstyle

\EditIf{\Sexpr{eval_maps}}{TRUE}{
\chapter{Cartes de résultats}

<<Resultats_MAPS, echo=F, results='asis', fig.pos="H", comment=F, eval=eval_maps, include=eval_maps>>=

cat(paste0("\\includepdf[pages=-]{",Map_ListFiles,"}\n\\FloatBarrier\n"))
@
}{}

% Carte Camembert Gha
% \includepdf[pages=-]{/Users/Valentin/Foret/Travail/Leforestier/Geneve/FD_Geneve/Out/Cartes/Carte_FD_Geneve_Gha.pdf}
%
% % Carte Camembert Gha - Cat
% \includepdf[pages=-]{/Users/Valentin/Foret/Travail/Leforestier/Geneve/FD_Geneve/Out/Cartes/Carte_FD_Geneve_GhaCat.pdf}
%
% % Carte Camembert Gha - EssReg
% \includepdf[pages=-]{/Users/Valentin/Foret/Travail/Leforestier/Geneve/FD_Geneve/Out/Cartes/Carte_FD_Geneve_GhaEssReg.pdf}
%
% % Carte Camembert AcctGper
% \includepdf[pages=-]{/Users/Valentin/Foret/Travail/Leforestier/Geneve/FD_Geneve/Out/Cartes/Carte_FD_Geneve_AcctG.pdf}


% \chapter{Protocole d'inventaire}
% \label{Protocole}
%
% \includepdf[pages=-]{Figures/Annexe_methodo_VD.pdf}
%
% \FloatBarrier



\EditIf{\Sexpr{eval_appendix}}{TRUE}{
%%%%%%%%%%%%%%%%%%%% Tronches des chapitres pour les annexes
\titleformat{\chapter}[frame]
{\normalsize}%
{\filright\sffamily\Large%
\enspace Annexe \thechapter\enspace}%
{8pt}
{\sffamily\Huge\bfseries\filcenter}


\chapter{\Sexpr{i18n()$t("Plans des arbres sur la placette")}}
\newpage

\section{\Sexpr{i18n()$t("Localisation")}}

<<map_trees_set_up, eval = eval_appendix, include = eval_appendix>>=
  ##### function to build range for 1 variable #####
  # t0 <- t1 # debug
  build_range_for_variable <- function(
    table = NULL, variable = NULL
  ) {
    # table = t0 # debug
    # variable = "Note_AFI" # debug

    # -- find max value
    # value_max <- max(table[, variable], na.rm = T)
    value_max <- unname(
      quantile(table[, variable], probs = 0.98, na.rm = T)
    )
    # security
    value_max <- if (is.na(value_max)) 50 else value_max
    # increment value
    increment_value <- find_increment_value(value_max)

    # -- breaks values
    breaks_values <- seq(increment_value, value_max - increment_value, increment_value)
    breaks_values <- breaks_values + increment_value / 2
    # breaks_values <- seq(20, value_max - 10, 10) + 5

    # -- breaks label
    breaks_labels <- if (length(breaks_values) > 1) {
      c(
        paste0("< ", breaks_values[1]),
        paste0(
          breaks_values[1:(length(breaks_values) - 1)], "-",
          breaks_values[2:length(breaks_values)]
        ),
        paste0("> ", breaks_values[length(breaks_values)])
      )
    } else {
      c(
        paste0("< ", breaks_values),
        paste0("> ", breaks_values)
      )
    }

    # -- build range
    table <- table %>% mutate(
      range = cut(
        x = !!sym(variable),
        breaks = c(-Inf, breaks_values, Inf),
        labels = breaks_labels
      )
    )

    # -- return of 'build_range_for_variable' function
    return(table)
  }



# -- main table
t1 <-
  Arbres %>%
  filter(NumForet == forest_num & Cycle == last_cycle) %>%

  # filter arbres hors limite
  filter(is.na(Limite) | Limite == 0) %>%

  # calcul de la valeur de consommation unitaire ?
  # mutate(VcHa = VcHa / Nha) %>% # à voir si besoin se fait sentir un jour
  mutate(
    Essence = EssReg,
    
    # translation
    Essence = i18n()$t(Essence),
    # factor
    Essence = factor(
      Essence,
      levels = names(colour_aes_for_grouped_species)
    ),
     # drop levels which do not occur
    Essence = factor(Essence)
  ) %>%
  arrange(NumPlac, Azimut)

# -- join dmh values if available
if (eval_dmh) {
  t1 <- t1 %>% left_join(NotesAFI_DF, by = c("CodeEcolo" = "Id"))
}

# -- palette species
species_palette <- colour_aes_for_grouped_species[levels(t1$Essence)]



# -- Diam1
t1 <-
  t1 %>%
  build_range_for_variable(variable = "Diam1") %>%
  rename(range_Diam1 = range)

Palette_Size <- 4 + (1:length( levels(t1$range_Diam1) ))
names(Palette_Size) <- levels(t1$range_Diam1)

# -- valeur de consommation
t1 <-
  t1 %>%
  build_range_for_variable(variable = "VcHa") %>%
  rename(range_VcHa = range)

Palette_Size_Vc <- 4 + (1:length( levels(t1$range_VcHa) ))
names(Palette_Size_Vc) <- levels(t1$range_VcHa)



# -- AcctD
if (eval_evol) {
  t1 <-
    t1 %>%
    mutate(AcctD = ifelse(is.na(AcctD), 0, AcctD)) %>%
    build_range_for_variable(variable = "AcctD") %>%
    rename(range_AcctD = range)

Palette_Size_AcctD <- 4 + (1:length( levels(t1$range_AcctD) ))
names(Palette_Size_AcctD) <- levels(t1$range_AcctD)

# -- palette acctD
acctD_palette_names <- levels(t1$range_AcctD)
acctD_palette <- RColorBrewer::brewer.pal(
  n = length(acctD_palette_names),
  name = "Greens"
)
names(acctD_palette) <- acctD_palette_names
}

# -- note AFI
if (eval_dmh) {
  t1 <-
    t1 %>%
    build_range_for_variable(variable = "Note_AFI") %>%
    rename(range_Note_AFI = range)

Palette_Size_Note_AFI <- 4 + (1:length( levels(t1$range_Note_AFI) ))
names(Palette_Size_Note_AFI) <- levels(t1$range_Note_AFI)
}


# -- création tables pour superposition de 2 geom_point :
if (eval_dmh) {
  df <-
    t1 %>%
    mutate(
      Value_Size_Note  =
        unname(Palette_Size_Note_AFI)[
          match(range_Note_AFI, names(Palette_Size_Note_AFI))
          ],
      Value_Size_Note = Value_Size_Note + 4,
      Value_Size_Vc  =
        unname(Palette_Size_Vc)[
          match(range_VcHa, names(Palette_Size_Vc))
          ],
      Value_Size_Vc = Value_Size_Vc + 4.5
    ) %>%
    select(
      NumPlac, NumArbre, Cycle,
      Essence, Azimut, Dist,
      Diam1, Classe, VcHa, Note_AFI,

      Value_Size_Note, Value_Size_Vc
    ) %>%
    pivot_longer( 
      cols = -c(
        "NumPlac", "NumArbre", "Cycle",
        "Essence", "Azimut", "Dist",
        "Diam1", "Classe", "VcHa", "Note_AFI"
      ),
      names_to = "variable"
    ) %>%
    mutate(
      variable = ifelse(
        variable == "Value_Size_Vc",
        i18n()$t("Valeur de consommation"),
        i18n()$t("Note écologique AFI")
      ),
      variable  = factor(
        variable,
        levels = c(
          i18n()$t("Note écologique AFI"),
          i18n()$t("Valeur de consommation")
          ))
    )

Palette_VcNote <- c("firebrick", "limegreen")
names(Palette_VcNote) <-
  c(i18n()$t("Valeur de consommation"), i18n()$t("Note écologique AFI"))
}

@

<<map_trees_Diam1, fig.height = 10, fig.show = 'asis', fig.pos = "H", eval = eval_appendix, include = eval_appendix>>=
##### fonction pour dessiner les plans des arbres par placette #####
map_trees <- function(
  table = NULL, var = NULL,
  forest_name = NULL,

  size_aes = NULL,
  size_legend_title = NULL,
  size_legend_values = NULL,
  size_legend_labels = NULL,

  fill_aes = NULL,
  fill_legend_title = NULL,
  fill_legend_values = NULL,
  fill_legend_labels = NULL
) {
  # -- set up
  # liste des placettes
  plots_list <- with(table, sort(as.numeric(unique(NumPlac))) )
  # compteur
  count <- 0
  # liste des grobs (graphical objects)
  grobs_list <- c() # pl_LIST
  # liste des warnings
  warnings_list <- c()
  # # enquo var
  # var <- enquo(var)
  # qq_show(!!var)

  # ----- loop to map trees on each plot
  for (plac in plots_list) {
    # print(plac)
    # plac = 9 # debug
    # -- add count
    count = count + 1

    # -- filter table
    plot_table <- table %>% filter(NumPlac == plac)

    # -- liste des arbres précomptables (NumArbre affiché)
    label_table <- plot_table %>% filter(Diam1 >= 17.5)

    # -- plot settings
    dist_max <- with(
      plot_table,
      if (max(Dist, na.rm = T) < 20) 20 else max(Dist, na.rm = T)
    )

    # -- security : edit map if more than 1 value
    values <- unique(table[, var])
    if (NA %in% values && length(values) > 1) {
      edit_map <- F
      warnings_list <- c(warnings_list, plot)
    } else edit_map <- T

    if (edit_map) {
      # -- plot
      pl <-
        ggplot(
          data = plot_table,
          aes_string(
            x = "Azimut",
            y = "Dist",
            fill = fill_aes,
            size = size_aes,
            label = "NumArbre"
          )
        ) +
        geom_hline(
          yintercept = seq(5, dist_max, 5),
          colour = "grey",
          linetype = 2,
          alpha = 1
        ) +
        geom_vline(
          xintercept = c(0, 100, 200, 300, 400),
          colour = "grey",
          size = 0.5
        ) +
        geom_point(alpha = 0.6, shape = 21) +

        # titre
        ggtitle(paste0(forest_name, " - ", i18n()$t("Placette"), " ", plac)) +
        # label NumArbre
        geom_text(
          label_table,
          mapping = aes_string(y = "Dist", x = "Azimut"),
          color = "navyblue",
          size = 2,
          vjust = 2,
          fontface = "bold"
        ) +
        # annotations
        annotate(
          "text",
          x = rep(seq(100, 400, 100), (dist_max - 5) / 5 + 1),
          y = sort(rep(seq(5, dist_max, 5), (400 - 100) / 100 + 1)),
          label = paste0(sort(rep(seq(5, dist_max, 5), (400 - 100) / 100 + 1)), " m"),
          size = 2,
          colour = "grey",
          fontface = "bold",
          vjust = -0.8,
          angle = rep(c(-90, 180, 90, 0), (dist_max - 5) / 5 + 1),
          alpha = 1
        ) +

        # legends
        scale_size_manual(
          name = size_legend_title,
          values = size_legend_values,
          label = size_legend_labels,
          drop = F
        ) +
        scale_fill_manual(
          name = fill_legend_title,
          values = fill_legend_values,
          label = fill_legend_labels,
          guide = F,
          drop = F
        ) +
        guides(fill = guide_legend(
          order = 1,
          override.aes = list(shape = 21, size = 5)
        ),
        size = guide_legend(
          order = 2,
          override.aes = list(shape = 1))
        ) +
        # scales
        scale_y_continuous(limits = c(0, dist_max), expand = c(0, 0))+
        scale_x_continuous(
          limits = c(0, 400),
          expand = c(0, 0),
          label = paste0(c(0, 100, 200, 300, 400), " gr")
        ) +

        # theme
        theme_bw() +
        theme(
          text  = element_text(size = 6),
          axis.text.x  = element_text(colour = "blue"),
          axis.title.x  = element_blank(),
          axis.title.y  = element_blank(),
          axis.text.y = element_blank(),
          axis.line = element_blank(),
          legend.position = "bottom",
          legend.box = "vertical",
          legend.spacing.y = unit(1, "pt"),

          axis.ticks.y  = element_blank(),

          panel.grid = element_blank(),
          panel.grid.minor.y = element_blank(),
          panel.border = element_blank(),
          plot.margin = unit(c(0.3, 0.3, 0.3, 0.3), "cm"),
          legend.key = element_rect(colour = "white")
        ) +

        # polar coord
        coord_polar()

      # grobs layout
      grobs_list[[count]] <- pl

      # ----- print grobs
      if (count == 4 | plac == plots_list[length(plots_list)]) {
        # -- cas où page non remplie (no more grobs)
        if (count < 4) {
          # number of missing grobs to fill 1 page
          missing_grobs_nb <- 4 - count
          # boucle pour créer figure vide
          for (i in 1:missing_grobs_nb) {
            grobs_list[[count+i]] <- ggplot() + theme_void()
          } # end of loop 'i in 1:missing_grobs_nb'
        } # end of cond 'count < 4'

        # -- final layout
        # legend
        mylegend <- g_legend(grobs_list[[1]])
        # layout
        grid.arrange(
          arrangeGrob(
            grobs_list[[1]] + theme(legend.position = "none"),
            grobs_list[[2]] + theme(legend.position = "none"),
            grobs_list[[3]] + theme(legend.position = "none"),
            grobs_list[[4]] + theme(legend.position = "none"),
            ncol = 2, nrow = 2
          ),
          mylegend, nrow = 2, heights = c(8, 2.5)
        )
        # reset count
        count = 0
      } # end of cond 'count == 4 | plac == plots_list[length(plots_list)]'
    } # end of cond 'edit_map'
  } # end of loop 'plac in plots_list'

  # -- print warnings
  if (length(warnings_list) > 0) {
    if (length(warnings_list) > 1) {
      # msg label
      msg_label <- paste0(
        "Les placettes N° ",
        paste0(plots_list[warnings_list], collapse = ", "),
        " n'ont aucun ", var, " non vide.\nPas de plans créés pour ces placettes"
      )

      # warning msg
      warning(msg_label)
      msg <- tk_messageBox(
        type = "ok",
        label = msg_label
      )
    } else {
      # msg label
      msg_label <- paste0(
        "La placette N° ",
        paste0(plots_list[warnings_list], collapse = ", "),
        " n'a aucun ", var, " non vide.\nPas de plan créé pour cette placette"
      )

      # warning msg
      warning(msg_label)
      msg <- tk_messageBox(
        type = "ok",
        label = msg_label
      )
    }
  } # end of cond 'length(warnings_list) > 0'
}

table <- t1
var = "Diam1"
# size_aes <- "Size_Loc"
size_aes <- paste0("range_", var)
size_legend_title <- i18n()$t("Ordres de grandeur\r\nde Diam1 (cm)") # debug
size_legend_values <- Palette_Size # debug
size_legend_labels <- names(Palette_Size) # debug

fill_aes <- "Essence" # debug
fill_legend_title <- i18n()$t("Essence") # debug
fill_legend_values <- species_palette # debug
fill_legend_labels <- names(species_palette) # debug

map_trees(
  table, var = var,
  forest_name = forest_name,

  size_aes = size_aes,
  size_legend_title = size_legend_title,
  size_legend_values = size_legend_values,
  size_legend_labels = size_legend_labels,

  fill_aes = fill_aes,
  fill_legend_title = fill_legend_title,
  fill_legend_values = fill_legend_values,
  fill_legend_labels = fill_legend_labels
)
@
\clearpage

\EditIf{\Sexpr{eval_evol}}{TRUE}{
\section{\Sexpr{i18n()$t("Accroissement en diamètre")}}
<<map_trees_AcctD, fig.height = 10, fig.show = 'asis', eval = eval_appendix && eval_evol, include = eval_appendix && eval_evol>>=
table <- t1
# table <- head(table) # debug
var = "AcctD" # ou Diam1 ici d'ailleurs
# size_aes <- "Size_Loc"
size_aes <- "range_Diam1"
size_legend_title <- i18n()$t("Ordres de grandeur\r\nde Diam1 (cm)") # debug
size_legend_values <- Palette_Size
size_legend_labels <- names(Palette_Size)

# fill_aes <- "Size_AcctD"
fill_aes <- paste0("range_", var)
fill_legend_title <- i18n()$t("Ordres de grandeur\r\nde AcctD (cm/an)")
fill_legend_values <- acctD_palette
fill_legend_labels <- names(acctD_palette)

map_trees(
  table, var = var,
  forest_name = forest_name,

  size_aes = size_aes,
  size_legend_title = size_legend_title,
  size_legend_values = size_legend_values,
  size_legend_labels = size_legend_labels,

  fill_aes = fill_aes,
  fill_legend_title = fill_legend_title,
  fill_legend_values = fill_legend_values,
  fill_legend_labels = fill_legend_labels
)
@
\clearpage


\fancyappendicestyle
\chapter{\Sexpr{i18n()$t("Prélèvements par placettes")}}

<<harvests_by_plot_table, size = 'footnotesize', results = 'asis', eval = eval_evol, include = eval_evol>>=

##### fonction pour obtenir les taux de prélèvements par groupe et par placette #####
get_harvested_shares_by_plot_table <- function(
  table = NULL,
  group = NULL,
  cycles = last_cycle - 1,
  var = NULL,
  add_total_by_group = F,
  show_share = T,

  font_share = " \\scriptsize{\\textcolor{CornflowerBlue}{(_arg_\\%)}}",
  font_total = "\\textbf{\\textcolor{white}{_arg_}}",

  digits_table = NULL
) {
# table <- gfDispFpied_EssenceCoupe # debug
# group <- "Essence" # debug
# var = c("Gha", "Vha", "VcHa") # debug

# groups
# groups <- c("NumForet", "Cycle", "Coupe", group)
# groups_without_Coupe <- c("NumForet", "Cycle", group)

  # -- split fonts
  # TODO : mettre une sécurité si pas possible d'avoir 2 éléments
  if (!is.null(font_share)) font_share <- str_split(font_share, "_arg_", simplify = T)
    if (!is.null(font_total)) font_total <- str_split(font_total, "_arg_", simplify = T)

# -- harvested table
    # table = lost_wood_shared_by_cat # debug
table <-
  table %>%
  filter(NumForet == forest_num & Cycle %in% cycles) %>%

  # remove NumForet
  select(-NumForet) %>%

  mutate(
    # format 'Coupe'
    Coupe = gsub("PF/", "", Coupe),
    Coupe = gsub("PF", "", Coupe),
    Coupe = ifelse(is.na(Coupe), "", Coupe),

    # sécurités au cas où prélèvement(s) serai(en)t manquants
    Coupe = factor(Coupe, levels = c("E", "C", ""))
  ) %>%
  complete(!!!syms(c("NumPlac", "Cycle", "Coupe", group))) %>%

  # pivot
  select(!!!syms(c("NumPlac", "Cycle", "Coupe", group)), var) %>%
  pivot_longer(
    cols = var,
    names_to = "variable",
    values_to = "value"
  ) %>%

  # sum (useless ?)
  group_by(!!!syms(c("NumPlac", "Cycle", "Coupe", group)), variable) %>%
  summarise(value = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # format
  mutate(variable = factor(variable, levels = var))

# -- total by group
total_by_group <-
  table %>%
  group_by(!!!syms(c("NumPlac", "Cycle", group)), variable) %>%
  summarise(total = sum(value, na.rm = T)) %>%
  ungroup()

# -- total share of lost wood (harvested + fallen) by group
total_lost_wood_by_group <-
  table %>%

  # filter only E/C elements
  filter(is.element(Coupe, c("E", "C"))) %>%

  # somme des coupes + chablis
  group_by(!!!syms(c("NumPlac", "Cycle", group)), variable) %>%
  summarise(total_lost_wood = sum(value, na.rm = T)) %>%
  ungroup() %>%

  # join total
  left_join(
    total_by_group,
    by = c("NumPlac", "Cycle", group, "variable")
    ) %>%

  # calcul part de '(C+E)/total'
  mutate(
    share = round(total_lost_wood / total * 100),

    # label ...
    label = NA,
    label = case_when(
    # ... pour la table total
      is.null(group) ~ paste0(font_total[1], share, font_total[2]),
    # ... pour les autres
      !is.null(group) ~ paste0(share, " \\%")
      ),
    # vide si valeur nulle
    label = case_when(total_lost_wood > 0 ~ label)#,
    # label = if_else(total_lost_wood > 0, label, ""), # another way
  ) %>%

  # remove total & share
  select(-total, -share)

# add total by group ? -> pour le tableau 'harvests_table'
if (add_total_by_group) {
  total_lost_wood_by_group <-
    total_lost_wood_by_group %>%

    # format
    left_join(digits_table, by = c("variable" = "var")) %>%
    mutate(
      # si VcHa/Vha/PU -> 0 digits. cf digits table
      total_lost_wood = round(total_lost_wood, digits),

      # set variable & total_lost_wood to character to pivot
      # label = as.character(label),
      total_lost_wood = as.character(total_lost_wood)
    ) %>%

    # rename label & total_lost_wood
    rename(share = label, total = total_lost_wood) %>%

    # pivot
    pivot_longer(
      cols = c("share", "total"),
      names_to = "Coupe",
      values_to = "label"
    ) %>%
    select(NumPlac, Cycle, group, Coupe, variable, label)
} else {
  total_lost_wood_by_group <-
    total_lost_wood_by_group %>%
    mutate(Coupe = "share") %>%
    select(NumPlac, Cycle, group, Coupe, variable, label)
}

# -- main table
table <-
  table %>%
  # filtre -> éléments C/E uniquement
  filter(is.element(Coupe, c("E", "C"))) %>%

  # calcul des parts des différents membres du groupe
  group_by(NumPlac, Cycle, Coupe, variable) %>%
  mutate(share = round(value / sum(value) * 100)) %>%
  ungroup() %>%

  # format
  left_join(digits_table, by = c("variable" = "var")) %>%
  mutate(value = round(value, digits),
    # precision needed or not
    # digits = case_when(
    #     variable == "Gha" & precision_needed == F ~ digits,
    #     variable == "Gha" & value < 0.1 & precision_needed == T ~ 2,
    # )

    # label ...
    label = NA,
    label = case_when(
      # ... pour la table total
      is.null(group) ~ paste0(font_total[1], value, font_total[2]),
      # ... pour les autres
      !is.null(group) & show_share == T ~
        paste0(value, font_share[1], share, font_share[2]),
      !is.null(group) & show_share == F ~ as.character(value)
    ),
    # replace 0 by NA
    label = case_when(value > 0 ~ label)
  ) %>%
  select(NumPlac, Cycle, Coupe, group, variable, label) %>%

  # stack totals
  rbind(total_lost_wood_by_group)

# cond if group is NULL
table <-
  if (!is.null(group)) {
    table %>% rename("group" = group)
  } else {
    table %>%
      mutate(group = paste0(font_total[1], "Total", font_total[2]))
  }

  # sort
  table <-
    table %>%
    arrange(group, variable, Coupe) %>%
    select(NumPlac, Cycle, Coupe, group, variable, label)

# -- return from 'get_harvested_shares_table'
return(table)
}

# -- variables to use
var <- c("Gha", "Vha", "VcHa", "PU")

    # -- table digits (round values)
# TODO : mettre une sécurité si manque une variable (après le join)
digits_table <- tibble(
  var = factor(var, levels = var),
  digits = c(1, 0, 0, 0)
)

lost_wood_shared_by_cat <-
  gfPlaFpied_CatCoupe %>%
  mutate(
    # translation
    Cat = i18n()$t(Cat),
    Cat = factor(Cat, levels = rev( names(colour_aes_for_diameter_category) )[-1] ),
    # N.B : ...[-1] to remove 'PER'

    # calculate PU
    PU = VcHa / Vha
  ) %>%

  # get harvested values
  get_harvested_shares_by_plot_table(
    group = "Cat",
    var = var,
    cycles = 1:(last_cycle - 1),
    show_share = F,
    font_share = NULL,
    font_total = NULL,
    digits_table = digits_table
  ) %>%
  filter(Coupe %in% c("E", "C"))

lost_wood <-
  gfPlaFpied_Coupe %>%
  # calculate PU
  mutate(PU = VcHa / Vha) %>%

  # get harvested values
  get_harvested_shares_by_plot_table(
    group = NULL,
    var = var,
    cycles = 1:(last_cycle - 1),
    add_total_by_group = T,
    show_share = F,
    font_share = NULL,
    font_total = NULL,
    digits_table = digits_table
  )

# -- final table
table <- rbind(
  lost_wood_shared_by_cat,
  lost_wood
) %>%

  # factor & arrange
  mutate(Coupe = factor(Coupe, levels = c("E", "C", "total", "share"))) %>%

  # sort
  arrange(NumPlac, Cycle, Coupe) %>%

  # pivot
  pivot_wider(
    id_cols = c("NumPlac", "Cycle", "variable"),
    names_from = c("Coupe", "group"),
    values_from = "label"
  ) %>%

  # join periods
  mutate(Cycle = Cycle + 1) %>%
  left_join(periods_table[, c( "Cycle", "period")], by = c("Cycle")) %>%
  select(NumPlac, period, everything(), -Cycle) %>% 
  # sort
  arrange(as.numeric(NumPlac)) %>% 
  
  # create id to use multirow
  mutate(
    Id = paste0(as.numeric(factor(period)), "-", as.numeric(NumPlac)),
    Id = factor(Id, levels = unique(Id))
  ) %>%
  arrange(Id)
  
  
  # -- split table with page size
# nombre de lignes du tableau par page
row_length <- 60
# nombre de placettes par pages
plot_nb <- row_length / 4
row_count = 0
sheets_nb <- ceiling( nrow(table) / row_length )

for (k in 1:sheets_nb) { # loop 'k in 1:sheets_nb'
# k=1# debug
  if (k < sheets_nb) { # cond 'k < sheets_nb'
    # tmp table
    tmp <- table[ (row_count + 1):(row_count + row_length), ]
    # update page count
    row_count <- row_count + nrow(tmp)
  } else {
    # tmp table
    tmp <- table[ (row_count + 1):nrow(table), ]
  }
  
  # table
tmp <- 
  tmp %>% 
  set_multirow_table(c(1, 16)) %>%
  mutate(
    period = ifelse(
      !is.na(Id), paste0("\\multirow{4}{*}{", period, "}"), NA
    ),
    Id = NULL
  ) %>%

  # format total columns (LightGray)
  mutate(
    E_Total = ifelse(
      !is.na(E_Total),
      paste0("\\cellcolor{LightGray}{", E_Total, "}"),
      "\\cellcolor{LightGray}{}"
    ),

    C_Total = ifelse(
      !is.na(C_Total),
      paste0("\\cellcolor{LightGray}{", C_Total, "}"),
      "\\cellcolor{LightGray}"
    ),

    total_Total = ifelse(
      !is.na(total_Total) & total_Total != 0,
      paste0("\\cellcolor{DimGray} \\textbf{\\textcolor{White}{", total_Total, "}}"),
      "\\cellcolor{DimGray}"
    ),

    share_Total = case_when(
      variable != "PU" & !is.na(share_Total) ~
        paste0("\\multicolumn{1}{c|}{ \\scriptsize{", share_Total, " \\%}}"),
      variable != "PU" & is.na(share_Total) ~ "\\multicolumn{1}{c|}{}"
      # variable == "PU" ~ NA sous-entendu
    )
  ) %>%

  # rename
  rename(
    !!paste0("\\multirow{2}{*}{\\parbox{1cm}{\\centering \\textbf{", i18n()$t("\\No Plac"), "}}}") := "NumPlac",
    !!paste0("\\multirow{2}{*}{\\parbox{1.4cm}{\\centering \\textbf{", i18n()$t("Périodes"), "}}}") := "period",
    !!paste0("\\multirow{2}{*}{\\parbox{1cm}{\\centering \\textbf{", i18n()$t("Variable"), "}}}") := "variable",
    !!paste0("\\multirow{2}{*}{\\parbox{1.9cm}{\\centering \\textbf{", i18n()$t("Total des prélèvements"), "}}}") := "total_Total",
    !!paste0("\\multicolumn{1}{c|}{\\multirow{2}{*}{\\parbox{1.7cm}{\\centering \\textbf{", i18n()$t("Taux de prélèvement"), "}}}}") := "share_Total"
  )


# -- print set up
# 1. position changement placette
pos_Plot <- which(!is.na( tmp[, grep(i18n()$t("\\No Plac"), names(tmp))] ))[-1]
# 2.position changement Cycle.
pos_Cycle <- which(!is.na( tmp[, grep(i18n()$t("Périodes"), names(tmp))] ))[-1]

# nombre de lignes et colonnes dans 'tmp'
nrow <- nrow(tmp)
ncol <- ncol(tmp)

# -- add hline before period changes
# command to add hhline -> hhline permet de mieux gérer les lignes de séparation des cellules du tableau (paramètre '-' : une simple ligne horizontale de la largeur de la colonne ou '|' : une ligne verticale qui coupe une ligne horizontale; entre autres)
command_to_add_hhline <- paste0(
  "\\hhline{|",  paste0(rep("-", ncol), collapse = "") , "|}\n"
)

# initialisation
pos_list <- as.list(pos_Plot - 1)
command <- rep(command_to_add_hhline, length(pos_Plot))



# add hline before period changes
command_to_add_hhline <- paste0(
  "\\hhline{|~",  paste0(rep("-", ncol - 1), collapse = "") , "|}\n"
)

# initialisation
if (last_cycle > 2) {
  pos_list <- c(pos_list, as.list(pos_Cycle - 1))
  command <- c(
    command, 
    rep(command_to_add_hhline, length(pos_Cycle))
  )
} else {
  pos_Cycle <- nrow(tmp) + 1 # TODO : gérer pos_Cycle d'un bloc ?
  pos_list <- pos_list
  command <-  command
}


# ----- 2.Construction entête :
# -- split names containing "E" or "C" on "_"
# security - check column names containing "E" or "C" (value = 3:ncol-2)
names_to_split_col <- c( grep("E_", names(tmp)), grep("C_", names(tmp)) )
# split names
splitted_names <-
  str_split(names(tmp)[ names_to_split_col ], pattern = "_", simplify = T)


# -- replace values
# replace "E" by "Exploité" & "C" by "Chablis" in splitted_names[,1]
splitted_names[, 1] <- gsub("E", i18n()$t("Exploité"), splitted_names[, 1])
splitted_names[, 1] <- gsub("C", i18n()$t("Chablis"), splitted_names[, 1])

# replace "Total" by "\\cellcolor{LightGray}{Total}" in splitted_names[,1]
splitted_names[, 2] <-
  gsub("Total", "\\\\cellcolor{LightGray}{Total}", splitted_names[, 2])


# -- define table_names (entête)
# add multicolumn (always 5 column)
splitted_names[, 1] <- paste0(
  "\\multicolumn{5}{c|}{\\textbf{", splitted_names[, 1], "}}"
)
# define table_names
table_names <- names(tmp)
# change table names
table_names[ names_to_split_col ] <- splitted_names[, 1]
# remove duplicated names (<=> multicolumns)
table_names <- table_names[ !duplicated(table_names) ]
# collapse table names
table_names <- paste0(table_names, collapse = " & ")
# add hhline
# N.B : arg '~' = une colonne sans ligne horizontale
table_names <- paste0(
  table_names,
  paste0(
    "\\\\ \n\\hhline{|~~~|",
    # line only under multicolumns
    paste0(rep("-", ncol - 5), collapse = ""),
    "|~~|}\n"
  )
)

# -- define 1st row (under table_names)
# changement de names(tmp)
names(tmp) <- c("", "", "", splitted_names[, 2], "", "")
# add multicolumn to the last column -> rajout du trait vertical (hors lignes PU)
names(tmp)[ncol] <- paste0("\\multicolumn{1}{c|}{", names(tmp)[ncol], "}")

# %%%%%%%%%% %%%%%%%%%% #
# ----- 3.Commandes :
# -- rajout des hhline pour les lignes du tableau, excepté pour les lignes PU !
pos <- -1
pos_list <- c(pos_list, list(pos))
command=c(command, paste0("\\hline\n", table_names, "\n"))

row_to_add_hhline <- setdiff(1:(nrow - 1), pos_Cycle - 1)
pos_list <- c(pos_list, as.list(row_to_add_hhline))
command <- c(
  command, # initial value
  rep(
    # command to add hhline (+parameters)
    paste0("\\hhline{|~~|", paste0(rep("-", ncol - 2), collapse = ""), "|}\n"),
    times = length(row_to_add_hhline
    )
  )
)

# last row
pos_list[length(pos_list) + 1] <- nrow
# add hhline to last line
command <- c(
  command,
  paste0("\\hhline{*{", ncol - 1, "}{-}}")
)

print(
  xtable(
    tmp,
    digits = rep(0, ncol(tmp) + 1),
    align = c(
      "M{0cm}|", "|M{1cm}", "|M{1.4cm}", "|M{1cm}",
      rep("|M{0.5cm}", ncol(tmp) - 5), "|M{1.9cm}|", "M{1.7cm}"
    ),
    caption = paste0(
      i18n()$t("Prélèvements constatés au cours des différents inventaires"), 
      i18n()$t(" (distinction par placette) - "), k, "/", sheets_nb),
    label = "harvests_table"
  ),
  caption.placement = "bottom",
  hline.after = F,
  sanitize.text.function = function(x) return(x),
  include.rownames = F,
  add.to.row = list(
    pos = pos_list,
    command = command
  ),
  size = "\\footnotesize"
)
} # end of loop 'k in 1:sheets_nb'
@
\FloatBarrier
\clearpage
}{}
}{}

\fancyappendicestyle
\chapter{\Sexpr{i18n()$t("Fiches de relevés d'inventaire")}}
\clearpage

\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom = {\color[rgb]{0, 0, 0.56}}}
% \begin{landscape}
\begin{center}

\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\arraybackslash }b{#1}}

\pagestyle{plain} % numéros de page

<<field_sheets_set_up, eval = eval_appendix, include = eval_appendix>>=
# -- paramètres
NbLignes <- 38 # nombres de lignes du tableau par page

# -- table - extrait des données
table <- 
  left_join(
    IdArbres, ValArbres, by = "IdArbre"
  ) %>% 
  left_join(EssReg) %>% 
  filter(NumForet == forest_num & Cycle == last_cycle) %>%
  select(
    NumPlac, NumArbre, Essence, Azimut, Dist, #Cycle,
    Diam1, Diam2, 
    # HautT, HautL, Ray1, Dh1, Ray2, Dh2, 
    Qual,
    Observations, #CodeEcolo, (modif Nov 2022)
    Type, Stade
  ) %>%
  
  mutate(
    NumArbre = as.numeric(NumArbre),
    Azimut = round(as.numeric(Azimut), 1),
    # HautT = ifelse(HautT == 0, NA, HautT),
    # HautL = ifelse(HautL == 0, NA, HautL),
    # Ray1 = ifelse(Ray1 == 0, NA, Ray1),
    # Dh1 = ifelse(Dh1 == 0, NA, Dh1),
    # Ray2 = ifelse(Ray2 == 0, NA, Ray2),
    # Dh2 = ifelse(Dh2 == 0, NA, Dh2),

    Observations = gsub("œ", "oe", Observations),
    Observations = gsub("&", "et", Observations),
    Observations = gsub("%", "pour cent", Observations)
  ) %>%
  arrange(NumPlac, NumArbre, Azimut, Dist)

# -- liste des placettes
plots_list <- with(table, sort(as.numeric( unique(NumPlac) )))
@

\renewcommand{\arraystretch}{1.3}  % changement : Hauteur des lignes passe de 1.4 à 1.3
\setlength{\tabcolsep}{1pt} % Espace entre trait et texte d'une colonne

<<field_sheets, results = 'asis', size = 'scriptsize', out.width = "\\textwidth", eval = eval_appendix, include = eval_appendix>>=
for (plac in plots_list) {
  # plac <- plots_list[1] # debug
  # print(plac) # debug
  # -- extraction des données placette
  plot_table <-
    table %>%
    filter(NumPlac == plac) %>%

    mutate(
      NumPlac = NULL,

      Observations = case_when(!is.na(Observations) ~ utf8_to_LaTeX(Observations)),
      # Observations = ifelse(
      #   nchar(Observations) > 19,
      #   paste0(str_sub(Observations, 1, 19), "-", str_sub(Observations, 20, -1)),
      #   Observations
      # ),
      Observations = str_wrap(Observations, 19),

      # CodeEcolo = ifelse(
      #   nchar(CodeEcolo) > 9,
      #   paste0(str_sub(CodeEcolo, 1, 9), "-", str_sub(CodeEcolo, 10, -1)),
      #   CodeEcolo
      # ),
      # CodeEcolo = str_wrap(CodeEcolo, 9),

      # observations_char_nb = nchar(Observations),
      observations_rows_nb = ifelse(
        is.na(Observations), 0, ceiling( nchar(Observations) / 24 )
      ),

      # # code_rows_nb = nchar(CodeEcolo), # initiate
      # code_rows_nb = ifelse(
      #   is.na(CodeEcolo), 0, ceiling( nchar(CodeEcolo) / 10 )
      # ),
      code_rows_nb = 0, # modif Nov 2022

      rows_nb = pmax(observations_rows_nb, code_rows_nb),
      rows_nb = ifelse(rows_nb == 0, 1, rows_nb)
    ) # %>%
    # translate_xlsx(
    #   var = "Arbres",
    #   from_LANG = "FRA",
    #   to_LANG = "DEU",
    #   dictionary = Dictionary_DF,
    #   translate_names = T
    # )

  # -- prise en compte de la largeur max des colonnes (14 characters)
  # nombre de lignes + nb de lignes avec nchar > 14
  nb <- dim(plot_table)[1] + sum(plot_table$rows_nb - 1)

  # calcul du nombre de feuilles
  sheets_nb <- ceiling(nb/NbLignes)

   # editing loop
  count = 0
  for (j in 1:sheets_nb) {
    # -- entête
    # set up
    plot_title <- paste0(
        i18n()$t("Placette"), " : ", plac, " (", j, "/", sheets_nb, ")"
      )
    titre <-
      tibble(
        left_column = c(forest_name, plot_title),
        center_column = c(
          i18n()$t("AFI : Fiche de mesure"),
          paste0("- ", i18n()$t("Cycle"), " ", last_cycle, " -")
        ),
        right_column = c(
          paste0(i18n()$t("Date"), " : ", date_last_inv),
          paste0(i18n()$t("Opérateurs"), " : ", paste0(operators_list, collapse = ", "))
        )
      )# %>%
      #mutate(right_column = str_wrap(right_column, 30))

    # print
    table_format <- c("M{0cm}", "L{4.5cm}", "M{9cm}", "R{4.5cm}")
    print(
      xtable(
        titre,
        align = table_format
      ),
      include.colnames = F,
      # scalebox = ech,
      include.rownames = F,
      floating = F,
      # latex.environments = "center",
      table.placement = "ht",
      hline.after = NULL
    )
    cat("\\vspace{0.5cm}\n\n\\FloatBarrier\n\n")

    # -- sheet table
    # set up
    temp <-
      plot_table[(count + 1):(count + NbLignes), ] %>%
      mutate(
      rows_nb = ifelse(is.na(rows_nb), 1, rows_nb),
      cum_rows_nb = cumsum(rows_nb)
      ) %>%
      filter(cum_rows_nb <= count + NbLignes) %>%
      rename(Num = NumArbre) %>%
      select(-c("observations_rows_nb", "code_rows_nb", "rows_nb", "cum_rows_nb"))
    # -- translation
    names(temp) <- i18n()$t(names(temp))

    if (rv$lang != "Français") { # cond 'rv$lang != "Français"'
     # arrange names for english+german translations
    # 1
    names_to_wrap <- c(
      # English
      "TopHeight", "CrownHeight", "CrownRad1",
      "CrownDiam1", "CrownRad2", "CrownDiam2",
      # Deutsch
      "GesamtHöhe", "KronenHöhe", "KronenRad1",
      "KronenD1", "KronenRad2", "KronenD2"
      )
    pos <- which(names(temp) %in% names_to_wrap)
    names(temp)[pos] <-
      str_wrap( gsub('([[:upper:]])', ' \\1', names(temp)[pos]), 6 )
    # 2 - special cases
    names_to_wrap <- c("Altersstufe")
    names(temp) <- gsub("Altersstufe", "Alters stufe", names(temp))
    } # end of cond 'rv$lang != "Français"'

    # number of rows
    NbLignes2 <- dim(temp)[1]
    count <- count + NbLignes2

    rows <- seq(1, NbLignes2 - 1, by = 2)
    cols <- rep("\\rowcolor[gray]{0.95}", length(rows))

    # print
    Format2 <- c(
      "|M{0cm}", "|M{1cm}",
      # "|M{1cm}", pour Cycle
      "|M{2.5cm}", "|M{1.3cm}", "|M{1.4cm}",

      rep("|M{1.2cm}", 3),
      "|M{4cm}|", #"|M{2.1cm}|" (modif Nov 2022), #"|c", "|c|",
      rep("M{1.2cm}|", 2)
    )
    print(
      xtable(
        temp,
        align = Format2,
        digits = c(
          rep(0, 4), 1, rep(0, 2), 
          # rep(1, 6),
          rep(0, 2), # modif Nov 2022 (mettre 3 si CodeEcolo)
          rep(0, 2)
        )
      ),
      add.to.row = list(pos = as.list(rows), command = cols),
      # scalebox = ech,
      include.rownames = F,
      floating = F,
      # latex.environments = "center",
      hline.after = c(-1:NbLignes2),
      sanitize.text.function = function(x) {return(x)},
      size = "normalsize"
    )

    cat("\\newpage")
  } # end of loop 'j in 1:sheets_nb'
} # end of loop 'plac in plots_list'
@


\newpage
\end{center}
% \end{landscape}

\end{appendices}

\end{document}
