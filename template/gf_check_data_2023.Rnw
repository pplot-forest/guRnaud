\PassOptionsToPackage{svgnames}{xcolor} % permet d'éviter le clash du package xcolor (chargé avec documentclass avec l'option [])

\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[usenames, dvipsnames, svgnames, table]{colortbl}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{pgfsys}
\usepackage{keyval}
\usepackage{subfig}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{array}
\usepackage{float}
\usepackage{helvet}
\usepackage{xifthen}
\renewcommand{\familydefault}{\sfdefault}
% \usepackage{placeins} % gestion des flottants
\usepackage[justification = centering]{caption}
\usepackage{enumitem}
\usepackage[section]{placeins}
% \usepackage{subcaption}
\usepackage{subfig}
\usepackage{multirow}
% \usepackage[output-decimal-marker = {, }]{siunitx}
\usepackage[autolanguage]{numprint}
\usepackage{titlesec}

\captionsetup{width = 9cm}

% Format des titres
\titleformat{\section}[frame]{\normalfont}{\filright\footnotesize\enspace SECTION \thesection\enspace}{8pt}{\Large\bfseries\filcenter}
\titleformat{\subsection}{\normalfont}{\hspace{0em}\large\bfseries\thesubsection}{8pt}{\large\bfseries}
\titleformat{\subsubsection}{\normalfont}{\hspace{5em}\normalsize\bfseries\thesubsubsection}{8pt}{\normalsize\bfseries}
\titleformat{\paragraph}{\normalfont}{\hspace{2em}\normalsize\underline\theparagraph}{3pt}{\normalsize\underline}

% Mise en page
\voffset -2cm
\hoffset 0cm
\oddsidemargin 0cm
\evensidemargin -0.5cm
\textwidth 17cm
\topmargin 1cm
\textheight 25cm
\parindent 0cm
\columnsep 0.7cm

% Définition des types des colonnes (tableaux)
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
\newcolumntype{C}{>{\centering\arraybackslash}c}

% ---------- Gestion des figures sur des pages vides (apparaissaient au milieu de la page)
\makeatletter% Set distance from top of page to first float
\setlength{\@fptop}{5pt}
\makeatother

% ----- Modification du nom des tableaux/figures
\addto\captionsfrench{\def\tablename{\footnotesize Tableau}}
\addto\captionsfrench{\def\figurename{\footnotesize Figure}}

% ----- Réglages des espaces entre floats
\setlength{\textfloatsep}{0.2cm plus 0.1cm minus 0.1cm} % 0.25
\setlength{\floatsep}{0.2cm plus 0.1cm minus 0.1cm}
\setlength{\intextsep}{0.2cm plus 0.1cm minus 0.1cm}
% \intextsep

% ----- Réglages sur la part de texte, le déplacement des floats aux pages suivantes etc...
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\setcounter{tocdepth}{2}     % Dans la table des matieres
\setcounter{secnumdepth}{2}  % Avec un numero.

% Commande édition conditionnelle
\newcommand{\EditIf}[4]{
\ifthenelse{
\equal{#1}{#2}
}{#3}{#4}
}

<<general_options, include = FALSE>>= 
### lancement manuel
# repFigures <- "figures/" # debug
# rep_pdf <- getwd() # debug
### fin lancement manuel

rep_figures <- rv$rep_figures$check_report

# set options
opts_chunk$set(
 concordance = T, include = T, eval = T, tidy = F, cache = FALSE, 
 warning = F, comment = F, error = F, message = F, echo = F, 

 fig.path = rep_figures, dev = 'pdf', fig.align = 'center', fig.show = 'hold', 
 size = 'normalsize', eval.after = 'fig.cap'
)
options(width = 45, guiToolkit = "tcltk")
par(mar = c(0, 0, 0, 0))
@

<<librairies>>=
# ----- Library
# library(rgdal)
library(tools)
library(grid)
library(tidyr)
# library(rgeos)
library(gridExtra)
# library(ggmap)
# library(ggsn)

# library(reshape2)
library(ggplot2)
library(openxlsx)
library(stringr)
library(xtable)
library(dplyr)
# library(doBy)
library(knitr)
library(sf)
library(rlang)
@

<<import>>=
Dev <- T

### lancement manuel
# # Dev <- T
# # repGF <- "/Users/Valentin/Travail/ForestAllia/Lamadeleine/inventaire_PP" # debug
# repGF <- "/Users/Valentin/Travail/Outils/Inventaire_PP" # debug
# app_dir <- "/Users/Valentin/Travail/Outils/Inventaire_PP/scripts/PermGF3"
# 
# repLogos <- file.path(repGF, "images/logos")
# setwd(repGF)
# forest_num <- 1
# load("tables/gfDonneesBrutes.Rdata")
# forest_name <- with(Forets, Nom[ which(NumForet == forest_num) ])
###

# -- arguments pour édition livret
## lancement via shiny
repGF <- wd()
lang <- rv$lang
last_cycle <- rv$last_cycle
last_year <- rv$last_year
forest_num <- rv$forest_num
forest_name <- rv$forest_name
rep_pdf <- rv$rep_pdf


# -- chargement des données
load(paste0(repGF, "/tables/gfDonneesBrutes.Rdata"))

# ----- Données d'inventaire : ----- #
Arbres <-
  left_join(
    IdArbres, ValArbres, 
    by = "IdArbre"
  ) %>%
  filter(NumForet == forest_num)
foret <-
  paste0(
    forest_num, "-", Forets$Nom[Forets$NumForet == forest_num]
  )

# ----- subset des tables d'inventaire
ListDF <- c("Forets", "Cycles", "Echantillonnages", "Placettes", "Regroups", 

            "Arbres", "Reges", "PCQM", "Cercles", "BMSLineaires", "BMSCercles", 
            "Coords", "Reperes", 

            "Tarifs", "AcctD", "EssReg", "EssInd", 
            "Quals", "Cats",
            #"Essences", "Tiers", "Prix", "PouvoirAchat", "VariationPU", "CodeEcolos", "CodeDurete", "CodeEcorce", "CodeTypoArbres", "CoeffBOBIBE", 
            "Listes")
for (df_name in ListDF) {
  # print(df_name)
  df <- get(df_name) %>%
    filter(NumForet == forest_num)
  assign(df_name, df)
}

# Récupération de l'année pour dater le rapport de vérification
An <- as.numeric(format(Sys.time(), "%Y"))


# # Test si les données SIG sont présentes dans le shape importé (sans doute inutile puisque importation faite dans le job1) :
# if (!is.element(forest_num, Placettes_SHP$NumForet)) {
#   stop(
#     "Attention : localisation des placettes non disponible. Remplissez la feuille Coords pour compléter les données."
#   )
# }
# Placettes_SHP <- Placettes_SHP[Placettes_SHP$NumForet %in% forest_num, ]


# ----- Autres arguments :
Eval_Autres <- FALSE
Eval_PCQM <- ifelse(nrow(PCQM) > 0, 
                    TRUE, FALSE)
Eval_Cercles <- ifelse(dim(Cercles)[1] > 0, 
                       TRUE, FALSE)

# ----- Logos
ForestAllia_LOGO <- file.path(rv$rep_logos, "logo_ForestAllia_2.png")
AFI_LOGO <- file.path(rv$rep_logos, "AFI_logo.jpg")
APT_LOGO <- file.path(rv$rep_logos, "APT_LOGO.png")
@

<<functions>>=
##### fonction pour imprimer les éléments d'erreur/oublis rapportés (messsage + tableau éventuellement) #####
  # paramètres d'entrée (debug)
  # error_msg <- "Ecarts entre les diamètres 1 et 2 (|Diam1 - Diam2|) supérieurs à 10 cm détectés : " # debug
  # validation_msg <- "Aucun écart entre les diamètres 1 et 2 (|Diam1 - Diam2|) supérieur à 10 cm détecté" # debug
  # issues_table_label <- "Arbres_gap_btw_diam1_diam2" # debug
  # issues_table_title <- "Arbres présentant un écart entre Diam1 et Diam2 supérieur à 10 cm" # debug
  # error_table <- table # debug
  nrow_max_default <- 0 # écrire les classeurs systématiquement
  print_issues <- function(
    issues_table = NULL, 
    error_msg = NULL,
    validation_msg = NULL,
    issues_table_label = NULL,
    issues_table_title = NULL,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    test_level = NULL, # 1 ou 2
    test = NULL,
    # forest_num = NULL,
    # file_name = NULL # si fichier xlsx listant les variables écrit
    column_width = "1cm"
  ) {
    # -- default print parameters -> everything ok
    issues_msg <- validation_msg
    warning_colour <- "ForestGreen"
    warning_str <-  "Vérifié"
    add_to_msg_str <- NULL
    
    # -- set print parameters
    if (nrow(issues_table) > 0) { # cond 'nrow(issues_table) > 0'
      # set issues msg
      issues_msg <- error_msg
      
      # set 'test' var
      if (test < test_level) test <- test_level
      
      # set string parameters with 'test_level' parameter
      if (test_level == 1) {
        warning_str <- "Remarque"
        warning_colour <- "blue"
      }
      if (test_level == 2) {
        warning_str <- "Correction nécessaire"
        warning_colour <- "red"
      }
      
      # add string for error issues_tables too long to be printed
      add_to_msg_str <- c()
      if (nrow(issues_table) > 20) { # si trop de lignes, on n'imprime pas le issues_tableau et on affiche le nombre d'éléments
        add_to_msg_str <- paste0(nrow(issues_table), " éléments détectés")
      }
    } # else of cond 'nrow(issues_table) > 0'
    
    # -- print issues (or not) message
    cat(paste0(
      "\\textcolor{", warning_colour, "}{\\textbf{", warning_str, 
      "}} - ", issues_msg, ". ", add_to_msg_str, "\\\\ \n\n"
    ))
    
    # -- print issues table
    if (nrow(issues_table) > 0 & nrow(issues_table) <= 20) { # cond 'nrow(issues_table) > 0 & nrow(issues_table) <= 20'
      
      # print parameters
      digits_param <- rep(0, ncol(issues_table) + 1)
      digits_param[which(names(issues_table) == "Dist") + 1] <- 1
      
      # print issues_table
      print(
        xtable(
          issues_table, 
          caption = paste0("\\footnotesize{", issues_table_title, "}"), 
          caption.placement = "bottom", 
          digits = digits_param, 
          align = c(
            "l", 
            paste0("|M{", column_width, "}|"), # 1st column width
            rep("M{1cm}|", ncol(issues_table)-1)
          ), 
          label = issues_table_label
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(issues_table)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier\n")
      
    } # end of cond 'nrow(issues_table) > 0 & nrow(issues_table) <= 20'
    
    # -- return of 'print_issues' function
    return(test)
  }
  
  ##### fonction pour vérifier les coordonnées des arbres #####
# 1/ vérifier qu'il n'y a pas de modification des variables Essence, Azimut et Dist au cours des cycles
  #   - cas où, dans un même classeur, il y a 2 azimut/distance différents pour un même NumArbre
# 2/ vérifier qu'il n'y a pas de doublons (2 arbres au même endroit = avec Azimut et Dist identiques)
  #   - cas où, dans 2 classeurs différents, il y a 2 azimut/distance différents pour un même NumArbre
# table <- Arbres # debug
  check_tree_id <- function(table = NULL) {
    # -- security -> remove trees with NumArbre, Azimut or Dist missing
    table <- 
      table %>% 
      # filter
      # filter(NumPlac == 6 & NumArbre >= 23) %>%
      # filter(!(is.na(NumArbre) | is.na(NumForet) | is.na(NumPlac) | is.na(NumArbre))) %>%
      # sort
      arrange(NumForet, NumPlac, NumArbre) %>% 
      
      # select (facultatif)
      select(
        NumForet, NumPlac, NumArbre, Essence, Azimut, Dist,
        Diam1, Diam2, Qual, Type, Stade
      ) %>% 
      
      # élimine les arbres qui n'ont pas d'Azimut+Dist, à aucun cycle
      # cela permet de repérer les perches avec infose d'Azimut+Dist vides
      # au cycle 1 (par exemple) mais avec infos de Azimut+Dist renseignées
      # ensuite (-> mais pas reportées au cycle 1 - donc à compléter)
      group_by(NumForet, NumPlac, NumArbre) %>% 
      mutate(
        na_count = sum(is.na(Azimut) & is.na(Dist)),
        measures_count = n()
      ) %>% 
      filter(na_count != measures_count) %>% 
      
      # select
      select(
        NumForet, NumPlac, NumArbre, Essence, Azimut, Dist,
        Diam1, Diam2, Qual, Type, Stade
      )
    
    # -- construction de la table des identifiants
    id <- 
      table %>% 
      select(NumForet, NumPlac, NumArbre, Essence, Azimut, Dist) %>% 
      # distinct NumForet, NumPlac et NumArbre but keep Essence, Azimut, Dist
      distinct(NumForet, NumPlac, NumArbre, .keep_all = T) 
    
    # -- construction des identifiants par groupe 'NumForet+NumPlac+NumArbre
    table_with_id_group <- 
      table %>% 
      # filter
      filter(!(is.na(NumArbre) | is.na(NumForet) | is.na(NumPlac))) %>%
      # group
      group_by(NumForet, NumPlac, NumArbre) %>% 
      # build id = rajout d'un identifiant par arbre tous cycles confondus
      mutate(id_group = group_indices()) %>%
      ungroup()# %>% 
    
    # -- table to check
    table_to_check <- 
      table_with_id_group %>% 
      # select only 'Essence', 'Azimut', 'Dist' !
      select(id_group, Essence, Azimut, Dist)
    
    # -- check inventory table : en joignant 'table_to_check' et 'id', on repère les combinaisons de 'id' pour lesquels la combinaison 'NumForet', 'NumPlac', 'NumArbre' est vide -> arbres pour lesquels la combinaison 'Essence', 'Azimut', 'Dist' est modifiée au cours des cycles -> moving trees
    check_inventory <- full_join(
      table_to_check, id, 
      by = c("Essence", "Azimut", "Dist")
    ) %>% 
      filter(is.na(NumForet) | is.na(NumPlac) | is.na(NumArbre))
    
    # table listant les arbres pour lesquels 1 NumArbre correspond à plusieurs coordonnées (Azimut + Dist)
    moving_trees <- 
      table_with_id_group %>% 
      # filter id_group with issues
      filter(id_group %in% check_inventory$id_group) %>% 
      # select
      select(
        NumForet, NumPlac, NumArbre, Essence, Azimut, Dist,
        Diam1, Diam2, Qual, Type, Stade
      )
    
    # -- return of 'check_tree_id'
    return(moving_trees)
  }
  
  ##### fonction pour contrôler la colonne Coupe #####
# arbres_table <- Arbres # debug
  check_cut_trees <- function(table = NULL, last_cycle = NULL) {
    
    # # -- last_cycle
    # last_cycle <- max(table$Cycle, na.rm = T)
    
    trees_to_check <-
      table %>% 
      
      # # exclusion des perches
      #     filter((Diam1 + Diam2) / 2 > 17.5) %>% # ce filtre pose problème pour les bois morts ayant maigri... passe de 20 à 15 et considère donc qu'il a 
      # disparu sans laisser de trace
          filter(!is.na(NumArbre)) %>% 
      # filter(NumPlac == 3 & NumArbre == 19) %>% # debug
      
      # select living trees
      # filter(is.na(Type)) %>% 
      # select trees with NumArbre only # les arbres sans NumArbre (= sans azimut / distance) ne sont pas suivis dans le temps (correspondent normalement à des perches des premiers inventaires) ni identifiés. Impossible de détecter les doublons
      # filter(!is.na(NumArbre)) %>% 
      
      # order
      arrange(NumForet, NumPlac, Azimut, Dist, Cycle) %>% 
      group_by(NumForet, NumPlac, NumArbre) %>%
      
      mutate(
        error = case_when(
          # à un inventaire donné, l'arbre a été mesuré, 
          # à l'inventaire suivant l'arbre n'existe plus et 
          # pourtant la colonne coupe est vide - valable pour vivants et morts
          Cycle != last_cycle & 
            !is.na(Diam1) & is.na(lead(Diam1)) & is.na(Coupe) ~ 1,
          
          # arbre vivant devenu mort et pourtant pas de notation dans la colonne coupe
          is.na(Type) & !is.na(lead(Type)) & is.na(Coupe) ~ 1,
          
          # arbre mort redevenu vivant
          Cycle != last_cycle &
            !is.na(Type) & is.na(lead(Type)) & !is.na(lead(Diam1)) ~ 1,
          
          # arbre coupé revenu dans l'inventaire
          is.na(Type) & is.na(lead(Type)) & # arbres vivants
            !is.na(Coupe) & !is.na(lead(Diam1)) ~ 1,
          !is.na(Type) & !is.na(lead(Type)) & # arbres morts
            !is.na(Coupe) & !is.na(lead(Diam1)) ~ 1,
          
          TRUE ~ 0
        )
      ) %>% 
      # filter
      filter(error == 1) %>%
      distinct() %>% 
      arrange(NumForet, NumPlac, Azimut, Dist, Cycle) %>% 
      select(
        NumForet, NumPlac, NumArbre, Cycle, Essence, Azimut, Dist, 
        Diam1, Diam2, Qual, Type, Stade, Observations, Coupe
      )
    
    # -- return of 'check_cut_trees' function
    return(trees_to_check)
  }
  
  ##### fonction pour écrire les éléments d'erreur au format excel #####
write_issues_in_xlsx <- function(
  # Si trop d'arbres, se donner la possibilité d'éditer un classeur excel listant toutes les erreurs
  issues_table = NULL, # table d'erreur
  issues_msg = NULL, # message d'erreur
  nrow_max = NULL, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
  forest_num = NULL, # numéro du dispositif
  file_name = NULL, # nom du fichier où écrire les erreurs rapportées
  output_dir = rep_pdf # chemin du dossier de sauvegarde
) {
  # file_name = "moving_trees" # debug
  
  if (nrow(issues_table) > nrow_max) { # cond 'length(error) > 20'
    # answ <- tk_messageBox(
    #   type = "yesno",
    #   message = paste0(issues_msg, "\nPlus de ", nrow_max, " erreurs détectées.\n\nEditer un classeur excel listant les erreurs ?")
    # ) # TODO : à réactiver
    answ <- "yes" # debug
    
    if (answ == "yes") { # cond 'answ == "yes"'
      # output directory
      dir.create(output_dir, showWarnings = F, recursive = T)
      # output_dir <- file.path("out/stacking_data", forest_num)
      # output_dir <- rep_pdf
      
      # writing
      file_name <- paste0(forest_num, "-", file_name, ".xlsx")
      file_path <- file.path(output_dir, file_name)
      # file_path <- file_name
      write.xlsx(issues_table, file = file_path)
      
      # msg
      msg <- paste0(
        issues_msg, "voir le fichier '", file_name, "' à l'adresse :\n", file_path
      )
      # answ <- tk_messageBox(type = "ok", message = msg) # TODO : à réactiver
      file_path_trunc <- 
        str_sub( file_path, str_locate(file_path, pattern = "out/")[,1], -1 )
      if (is.na(file_path_trunc)) file_path_trunc <- file_path
      cat(clean_str_for_latex("\\textcolor{purple}{Voir le fichier '",
        file_name, "' à l'adresse :}\\\\", "\\textcolor{blue}{", file_path_trunc, "}"))
    } # end of cond 'answ == "yes"'
  } # end of cond 'length(error) > 20'
}

##### fonction mise en forme texte (string vector) pour édition LaTeX #####
# TODO : fusionner avec clean_names
clean_str_for_latex <- function(string, ...) {
  # -- tableau de correspondance
  lookup_table <- tibble(
    non_ascii_char = c(
      "-", "—", "#", 
      # "{", "}", "$", 
      "_", "&", "œ", 
      "æ", "«", "»", 
      "“", "”", "n°", 
      "N°", "%", "°", 
      "‰", "€", "^", 
      "~", "e\u0302", "a\u0300", 
      "a\u0302", "e\u0301", "e\u0300", 
      "u\u0302", "u\u0308", "i\u0302", 
      "o\u0302", "é\u0301", "è\u0300", 
      "\u00a0", "\u2028", "\\retour\\", 
      "\\saut\\"
    ),
    
    latex_char = c(
      "--", "---", "\\#", 
      # "\\{", "\\}", "\\$", 
      "\\_", "\\&", "\\oe ", 
      "\\ae ", "\\og ", "\\fg{}", 
      "``", "''", "\\no ", 
      "\\No ", "\\%", "\\textdegree", 
      "\\textperthousand", "\\texteuro", "\\textasciicircum",
      "\\textasciitilde", "\u00EA", "\u00E0", 
      "\u00E2", "\u00E9", "\u00E8", 
      "\u00FB", "\u00FC", "\u00EE", 
      "\u00F4", "\u00E9", "\u00E8",
      " ", " ", "\\n", "\\\\"
    )
  )
  
  # -- checking string elements
  string <- paste0(string, ...)
  for (i in 1:dim(lookup_table)[1]) {
    string <- gsub(
      lookup_table$non_ascii_char[i], 
      lookup_table$latex_char[i], 
      string,
      fixed = T
    )
  }
  
  # -- return from print_latex function
    return(string)
}

##### fonction pour contrôler les valeurs vides #####
check_missing_values <- function(
  table = NULL,
  vars_to_check = NULL,
  test_level = NULL,
  test = NULL,
  columns_to_print = 1:10
) {
  # table name
  table_name <- deparse(substitute(table))
  
  # set print parameters with 'test_level' parameter
  if (test_level == 1) {
  add_to_label_str <- "non_essential_vars"
  add_to_title_str <- "non indispensables à l'analyse des données"
  }
  if (test_level == 2) {
    add_to_label_str <- "essential_vars"
    add_to_title_str <- "indispensables à l'analyse des données"
  }
  
  # print paragraph title
  cat(paste0( "\\paragraph{Variables ", add_to_title_str, "}\n" ))
  
  # -- count missing value
  # apply as.character for all vars to check (to allow pivot)
  table[vars_to_check] <- lapply(
    table[vars_to_check],  FUN = function(x) as.character(x)
  )
  
  # -- detect missing values - issues table
  issues_table <-
    table %>%
    # pivot vars to check
    pivot_longer(cols = vars_to_check, names_to = "column") %>% 
    # filter NA values
    filter(is.na(value)) %>% 
    # count NA values
    group_by(column) %>%
    summarise(nb = n()) %>%
    ungroup() %>%
    # rename
    rename("Colonne" = "column", "Nombre de vides" = "nb")
  
  # -- print issues
  error_msg <- clean_str_for_latex(
    "Il manque des informations (vides) dans la table '", table_name, 
    "' pour les variables ", paste0(vars_to_check, collapse = ", ")
  )
  validation_msg <- clean_str_for_latex(
    "Il n'y a aucune valeur vide dans les variables ", add_to_title_str, " (", 
    paste0(vars_to_check, collapse = ", "), 
    ") de la table '", table_name, "'"
  )
  issues_table_label <- 
    paste0(table_name, "-missing_values_for_", add_to_label_str)
  issues_table_title <- clean_str_for_latex(
    "Vides constatés dans les variables ", 
    paste0(vars_to_check, collapse = ", "), 
    ", ", add_to_title_str
  )
  # call print_issues
  test <- print_issues(
    issues_table = issues_table, 
    error_msg = error_msg,
    validation_msg = validation_msg,
    issues_table_label = issues_table_label,
    issues_table_title = issues_table_title,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
    test = test,
    test_level = test_level, # 1 ou 2,
    column_width = "2cm"
  )
  
  # -- return of 'check_missing_values' function
  return(test)
}

##### fonction pour contrôler les doublons #####
check_duplicated_rows <- function(
  table = NULL,
  vars_to_check = NULL,
  test_level = NULL, # essential_vars = NULL,
  test = NULL,
  columns_to_print = if (ncol(table) > 10) 1:10 else 1:ncol(table), # nombre de colonnes ~ 10 avec 1.5cm de largeur de colonne.
  return_issues_table = F
) {
  # table name
  table_name <- deparse(substitute(table))
  
  # set print parameters with 'test_level' parameter
  if (test_level == 1) {
  add_to_label_str <- "non_essential_vars"
  add_to_title_str <- "non indispensables à l'analyse des données"
  }
  if (test_level == 2) {
    add_to_label_str <- "essential_vars"
    add_to_title_str <- "indispensables à l'analyse des données"
  }
  
  # print paragraph title
  cat(paste0( "\\paragraph{Variables ", add_to_title_str, "}\n" ))
  
  # -- issues table
  # sort table
  issues_table <- table %>% arrange(!!!syms(vars_to_check))
  # filter expr -> no NA to test duplicated value
  filter_expr <- 
    quo(!!parse_expr(paste0( paste0("!is.na(", vars_to_check, ")"), collapse = " & ")))
  # filter
  issues_table <- issues_table %>% filter(!!filter_expr)
  # detect duplicated rows
  duplicated_rows <- which(duplicated(issues_table[, vars_to_check]))

  # get duplicated rows from last
  if (length(duplicated_rows) > 0) {
    duplicated_rows_fromLast <- 
      which(duplicated(issues_table[, vars_to_check], fromLast = TRUE))
    duplicated_rows <- sort(unique(c( duplicated_rows, duplicated_rows_fromLast )))
  }
  issues_table <- issues_table[duplicated_rows, columns_to_print]
  
  # -- print issues
  error_msg <- clean_str_for_latex(
    "Information dupliquée dans la table '", table_name, 
    "' pour les variables ", paste0(vars_to_check, collapse = ", ")
  )
  validation_msg <- clean_str_for_latex(
    "Il n'y a aucun doublon détecté dans les variables ", add_to_title_str, " (", 
    paste0(vars_to_check, collapse = ", "), 
    ") de la table '", table_name, "'"
  )
  issues_table_label <- 
    paste0(table_name, "-duplicated_rows_for_", add_to_label_str)
  issues_table_title <- clean_str_for_latex(
    "Doublons constatés sur les variables ", 
    paste0(vars_to_check, collapse = ", "), 
    ", ", add_to_title_str
  )
  # call print_issues
  test <- print_issues(
    issues_table = issues_table, 
    error_msg = error_msg,
    validation_msg = validation_msg,
    issues_table_label = issues_table_label,
    issues_table_title = issues_table_title,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
    test = test,
    test_level = test_level # 1 ou 2
  )
  
  # -- return of 'check_missing_values' function
  if (return_issues_table == T) {
    return(list(test = test, issues_table = issues_table, error_msg = error_msg))
  } else {
    return(test)
  }
}

##### fonction affichage résultat des tests #####
display_check_results <- function(test = NULL) {
  # set parameters
  msg_str <- case_when(
    test == 0 ~ "Table vérifiée - Pas d'anomalie détectée",
    test == 1 ~ "La table peut contenir des irrégularités (cf remarques)",
    test == 2 ~ "La table contient des erreurs = corrections nécessaires"
    )
  msg_colour <- case_when(
    test == 0 ~ "ForestGreen",
    test == 1 ~ "Blue",
    test == 2 ~ "Red"
    )
  
  # print message
  cat(paste0(
    "\\begin{center}\n\\textcolor{", msg_colour, 
    "}{\\textbf{", msg_str, "}}\n\\end{center}\n\n"
  ))
}
  
  ##### fonction contrôle des cycles #####
  # Principe : tous les cycles figurant dans la table admin doivent figurer dans la table # TODO : vérifier
  check_cycle <- function(
    table = NULL, 
    reference_table = NULL, 
    # admin_stands = NULL,
    test_level = NULL,
    test = NULL
  ) {
    # initialize
    table_name <- deparse(substitute(table))
    # table_name <- "Reges" # debug
    reference_table_name <- deparse(substitute(reference_table))
    # reference_table_name <- "Cycles" # debug
    
    # -- setting up table and cycles
    # table
    table <-
      table %>% distinct(NumForet, Cycle) %>% unite(id, NumForet, Cycle, remove = F)
    # cycles (admin)
    reference_table <-
      reference_table %>% distinct(NumForet, Cycle) %>% unite(id, NumForet, Cycle, remove = F)
    
    # -- cycles présents dans 'table' et absents de 'reference_table'
    missing_lookup <- setdiff(reference_table$id, table$id)
    
    # -- incohérences détectées :
    if (length(missing_lookup) > 0) {
      # update 'test' var
      if (test < test_level) test <- test_level
    }
    
    # -- issues table
    issues_table <-
      reference_table %>%
      filter(id %in% missing_lookup) %>%
      distinct() %>%
      mutate( label = paste0("Dispositif ", NumForet, " : Cycle ", Cycle) ) %>% 
      # select label only
      select(label)
    
    # -- print issues
    error_msg <- paste0(
      "Incohérence(s) détectée(s) : un/des cycle(s) figurant dans la table '",
      reference_table_name,
      "' ne figure(nt) pas dans la table '",
      table_name, "' : "
    )
    validation_msg <- clean_str_for_latex(
      "Tous les cycles d'inventaire de la table '", 
      reference_table_name, "' sont présents dans la table '", table_name, "'"
    )
    issues_table_label <- paste0("check_cycle_", table_name)
    issues_table_title <- paste0(
      "Liste des cycles inscrits dans la table '", 
      reference_table_name, 
      "' mais absents de la table '", 
      table_name
    )
    # call print_issues
    test <- print_issues(
      issues_table = issues_table, 
      error_msg = error_msg,
      validation_msg = validation_msg,
      issues_table_label = issues_table_label,
      issues_table_title = issues_table_title,
      nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
      test = test,
      test_level = test_level, # 1 ou 2,
      column_width = "6cm"
    )
    
    # -- return of 'check_cycle' function
    return(test)
  }
  
  ##### fonction contrôle des essences rencontrées #####
# Principe : toutes les essences rencontrées dans l'inventaire doivent figurer dans la table CodeEssence" # TODO : vérifier
check_species <- function(
  table = NULL, 
  species_table = NULL, 
  column = "Essence", # column in species table
  test = NULL
) {
  # detect unknown species
  unknown_species <- with(
    table, 
    unique( Essence[ !is.na(Essence) & !(Essence %in% species_table[, column]) ] )
  )
  
  if (length(unknown_species) > 0) { # cond 'length(unknown_species) > 0'
    # update test
    if (test < 2) test <- 2
    
    # 1 unknown species
    if (length(unknown_species) == 1) { # cond 'length(unknown_species) == 1'
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Pour le dispositif ", 
        forest_num, ", l'essence suivante figure dans la table '", 
        deparse(substitute(table)), "' mais ne figure pas dans la table '", 
        deparse(substitute(species_table)), "' : '", 
        unknown_species, 
        "'.\\\\\n\n"
      ))
      # several unknown species
    } else { # else of cond 'length(unknown_species) == 1'
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Pour le dispositif ", 
        forest_num, ", les essences suivantes figurent dans la table '", 
        deparse(substitute(table)), 
        "' mais ne figurent pas dans la table '", 
        deparse(substitute(species_table)), "' : '", 
        paste0( sort(unknown_species), collapse = "', '" ), 
        "'.\\\\\n\n"
      ))
    } # end of cond 'length(unknown_species) == 1'
  } else { # else of cond 'length(unknown_species) > 0'
    cat(paste0(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Pour le dispositif ", 
      forest_num, ", toutes les essences rencontrées dans la table '", 
      deparse(substitute(table)), "' sont présentes dans la table '", 
      deparse(substitute(species_table)), "'.\\\\\n\n"
    ))
  } # end of cond 'length(unknown_species) > 0'
  
  # -- return of 'check_species' function
  return(test)
}
  
##### fonction contrôle si changement de protocole change_protocole : extrait de la table Echantillonnages les cycles concernés par le(s) changement(s) de protocole (s'il(s) existe(nt)) #####
change_protocole <- function (table) {
  # on détecte si le protocole change à travers les cycles d'inventaire
  column_names <- syms(setdiff(names(table), "Cycle"))
  table <-
    table %>%
    distinct(!!!column_names, .keep_all = T)
  # on recrée une table avec les paramètres du plus
  # grand dénominateur commun entre les 2 (ou plus) protocoles d'inventaire
  # différents
  table <-
    table %>%
    group_by(NumForet, Strate) %>%
    mutate(
      DiamLim1 = min(DiamLim1), 
      Rayon1 = min(Rayon1), 

      DiamLim2 = min(DiamLim2), 
      Rayon2 = min(Rayon2), 

      DiamLim3 = min(DiamLim3), 
      Rayon3 = min(Rayon3), 

      DiamLim = min(DiamLim), 
      Coeff = max(Coeff), 

      # Identifiant pour retrouver les arbres concernés par le
      # changement de protocole
      echant_ID  = 
        paste0(
          NumForet, "-", Cycle, "-", Strate
        ), 
      Observations = NULL
    ) %>%
    ungroup()
  # retour fonction change_protocole
  return(table)
}

##### fonction contrôle cohérence des placettes entre elles #####
check_missing_plots <- function(
  table = NULL, 
  reference_table = NULL, 
  # admin_stands = NULL,
  test_level = NULL,
  test = NULL
) {
  # initialize
    table_name <- deparse(substitute(table))
    # table_name <- "Arbres" # debug
    reference_table_name <- deparse(substitute(reference_table))
    # reference_table_name <- "Placettes" # debug
  
  # security check
 if (nrow(table) > 0) { # cond 'nrow(table) > 0'
   
    # -- setting up plots lists
   # liste des placettes dans la table d'inventaire
   plots_list_by_cycle_in_table <- 
     table %>% distinct(Cycle, NumPlac)
   # liste des placettes dans la table 'Placettes'
   plots_list_by_cycle <- 
     reference_table %>% distinct(Cycle, NumPlac)
   
   # -- issues table
   issues_table <- full_join(
     plots_list_by_cycle_in_table %>% 
       mutate(table_mark = "placette absente de la table"), 
     plots_list_by_cycle %>% 
       mutate(reference_table_mark = "placette absente de la table"),
     by = c("NumPlac", "Cycle")
   ) %>% 
     filter(is.na(table_mark) | is.na(reference_table_mark)) %>% 
     select(Cycle, NumPlac, everything()) %>% 
     arrange(Cycle, NumPlac)
   
   # -- incohérences détectées :
   if (nrow(issues_table) > 0) {
     # update 'test' var
     if (test < test_level) test <- test_level
     
     # change column names
     issues_table <- issues_table %>% 
       rename(
       !!table_name := "table_mark",
       !!reference_table_name := "reference_table_mark"
     )
   }
   
   # -- print issues
   error_msg <- paste0(
     "Incohérence(s) détectée(s) : Les listes des placettes d'inventaire de la table '", 
      reference_table_name, "' et de la table '", table_name, "' ne sont cohérentes'"
    )
    validation_msg <- clean_str_for_latex(
      "Les listes des placettes d'inventaire de la table '", 
      reference_table_name, "' et de la table '", table_name, "' sont cohérentes'"
      )
    issues_table_label <- paste0("check_missing_plots_", table_name)
    issues_table_title <- paste0(
      "Liste des incohérences entre les placettes d'inventaire inscrites dans la table '", 
      reference_table_name, 
      "' et celles inscrites dans la table '", 
      table_name
    )
    # call print_issues
    test <- print_issues(
      issues_table = issues_table, 
      error_msg = error_msg,
      validation_msg = validation_msg,
      issues_table_label = issues_table_label,
      issues_table_title = issues_table_title,
      nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
      test = test,
      test_level = test_level, # 1 ou 2,
      column_width = "6cm"
    )
 } # end of cond 'nrow(table) > 0'
    
    # -- return of 'check_cycle' function
    return(test)
}

##### fonction de contrôle des qualités (~ identique à check_species) #####
check_qual <- function( # Controle_Qual
 table = NULL, 
 qual_table = Qual, 
 column = "Nom", 
 test = test
) {
  # detect unknown qual
  unknown_qual <- with(
    table, 
    unique( Qual[ !is.na(Qual) & !(Qual %in% qual_table[, column]) ] )
  )
  
  if (length(unknown_qual) > 0) { # cond 'length(unknown_qual) > 0'
    # update test
    if (test < 2) test <- 2
    
    # 1 unknown qual
    if (length(unknown_qual) == 1) { # cond 'length(unknown_qual) == 1'
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Pour le dispositif ", 
        forest_num, ", la qualité suivante figure dans la table '", 
        deparse(substitute(table)), "' mais ne figure pas dans la table '", 
        deparse(substitute(qual_table)), "' : '", 
        unknown_qual, 
        "'.\\\\\n\n"
      ))
      # several unknown qual
    } else { # else of cond 'length(unknown_qual) == 1'
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Pour le dispositif ", 
        forest_num, ", les qualités suivantes figurent dans la table '", 
        deparse(substitute(table)), 
        "' mais ne figurent pas dans la table '", 
        deparse(substitute(qual_table)), "' : '", 
        paste0( sort(unknown_qual), collapse = "', '" ), 
        "'.\\\\\n\n"
      ))
    } # end of cond 'length(unknown_qual) == 1'
  } else { # else of cond 'length(unknown_qual) > 0'
    cat(paste0(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Pour le dispositif ", 
      forest_num, ", toutes les qualités rencontrées dans la table '", 
      deparse(substitute(table)), "' sont présentes dans la table '", 
      deparse(substitute(qual_table)), "'.\\\\\n\n"
    ))
  } # end of cond 'length(unknown_qual) > 0'
  
  # -- return of 'check_qual' function
  return(test)
}


































##### 1/ Fonction mise en forme texte (string vector) pour édition LaTeX #####
utf82LaTeX <- function(string, ...) {
  string <- paste0(string, ...)
  string <- gsub("-", "--", string, fixed = T)
  string <- gsub("—", "---", string, fixed = T)
  string <- gsub("#", "\\#", string, fixed = T)
  # string <- gsub("{", "\\{", string, fixed  = T)
  # string <- gsub("}", "\\}", string, fixed  = T)
  # string <- gsub("$", "\\$", string, fixed = T)
  string <- gsub("_", "\\_", string, fixed = T)
  string <- gsub("&", "\\&", string, fixed = T)
  string <- gsub("œ", "\\oe ", string, fixed = T)
  string <- gsub("æ", "\\ae ", string, fixed = T)
  string <- gsub("«", "\\og ", string, fixed = T)
  string <- gsub("»", "\\fg{}", string, fixed = T)
  string <- gsub("“", "``", string, fixed = T)
  string <- gsub("”", "''", string, fixed = T)
  string <- gsub("n°", "\\no ", string, fixed = T)
  string <- gsub("N°", "\\No ", string, fixed = T)
  string <- gsub("%", "\\%", string, fixed = T)
  string <- gsub("°", "\\textdegree", string, fixed = T)
  string <- gsub("‰", "\\textperthousand", string, fixed = T)
  string <- gsub("€", "\\texteuro", string, fixed = T)
  string <- gsub("^", "\\textasciicircum", string, fixed = T)
  string <- gsub("~", "\\textasciitilde", string, fixed = T)
  # cat(string)
  return(string)
}

##### 2/ Fonction conversion vecteur en table sur 5 colonnes #####
Vector2Table_Print <- function(
  vector, caption, label
) {
  # Calcul du nombre de lignes (distribution des essences dans un tableau à 5 colonnes... A voir)
  nrows <- ceiling(length(vector)/5)
  df <-
    data.frame(
      vector[1:nrows], 
      vector[(nrows + 1):(nrows * 2)], 
      vector[(nrows * 2 + 1):(nrows * 3)], 
      vector[(nrows * 3 + 1):(nrows * 4)], 
      vector[(nrows * 4 + 1):(nrows * 5)]
    )
  # mise en forme tableau dans un tableau où nrows~2/3ncols
  nrows <- ceiling(length(vector) / 5) # divise par 6 (nombre maximal de colonnes de 2.5cm qui peuvent tenir sur une feuille de 17cm de largeur de texte)
if (nrows < 10) {
  ncols <- ceiling(length(vector) / nrows)
  while (nrows < 2 / 3 * ncols) {
    nrows = nrows + 1
    ncols <- ceiling(length(vector) / nrows)
  }
} else {
  ncols = 5
}

  df <- data.frame(rep(NA, nrows))
  count = 0
  for (i in 1:ceiling(ncols)) {
    df[, i] <- vector[(count + 1):(count + nrows)]
    count = count + nrows
  }

  # Impresssion
  print(
    xtable(
      df, 
      caption = paste0("\\footnotesize{", caption, "}"), 
      caption.placement = "bottom", 
      digits = rep(0, ncol(df) + 1), 
      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
      label = label
    ), 
    include.rownames = FALSE, 
    include.colnames = FALSE, 
    hline.after = c(0:nrow(df)), 
    size = "\\scriptsize"
  )
}

##### 3/ Fonction contrôle des Cycles #####
ControlCycle <- function(
  Table, Test = 0
) {
  if (dim(Table)[1] > 0) {
    temp <- Table
    temp$Mark <- 1
    CycleTab <- unique(
      full_join(
        Cycles, temp[, c("NumForet", "Cycle", "Mark")], 
        by = c("NumForet", "Cycle")
      )
    )

    pos <- which(is.na(CycleTab$Mark) & CycleTab$Annee < An)
    # &
    #                !CycleTab$NumForet %in% str_sub(ListDisp_Verif, 
    #                                               1, 
    #                                               str_locate(ListDisp_Verif, "-")[, 1]-1))
    if (length(pos) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - un/des cycle(s) figurant dans la table 'Cycles' ne figure(nt) pas dans la table '", 
          deparse(substitute(Table)), "' :"
        )
      )
      df <-
        CycleTab[pos, c("NumForet", "Cycle")] %>%
        distinct() %>%
        mutate(
          ListDisp_Verif  = 
            paste0(
              NumForet, "-", Forets$Nom[match(NumForet, Forets$NumForet)], 
              " : Cycle ", Cycle
            ), 
          NumForet = NULL, 
          Cycle = NULL
        ) %>%
        unlist()

      label <- paste0("TabMissCycle_", deparse(substitute(Table)))

      Vector2Table_Print(
        df, 
        utf82LaTeX(
          paste0(
            "Liste des dispositifs inscrits dans la table administrateur 'Cycles' mais absents de la table '", deparse(substitute(Table))
          )
        ), "'", 
        label)
      cat("\\FloatBarrier
          ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les cycles indiqués dans la table 'Cycles' du fichier administrateur sont renseignés dans la table '", 
          deparse(substitute(Table)), "'\\\\"
        )
      )
    }

  } else {
    Test = 1
    cat(
      utf82LaTeX(
        "\\textcolor{Blue}{\\textbf{Remarque}} - La feuille ", 
        deparse(substitute(Table)), " ne contient pas de données."
      )
    )
  }
  return(Test)
}

##### 4/ Fonction contrôle des essences rencontrées #####
# Principe : toutes les essences rencontrées dans l'inventaire doivent figurer dans la table CodeEssence"
Controle_Essence <- function(
  df = NULL, essence_DF = Essences, column = "Nom", Test = 0
) {
  Liste <- which(!(df$Essence %in% essence_DF[, column]) & !is.na(df$Essence))

  if (length(Liste) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Liste) == 1) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - l'essence suivante figure dans la table '", 
          deparse(substitute(df)), "' mais ne figure pas dans la table '", 
          deparse(substitute(essence_DF)), "' : '", 
          paste0(unique(df$Essence[Liste]), collapse = "', '"), 
          "'.\\\\

               "
        )
      )
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - les essences suivantes figurent dans la table '", 
          deparse(substitute(df)), 
          "' mais ne figurent pas dans la table '", 
          deparse(substitute(essence_DF)), "' : '", 
          paste0(sort(unique(df$Essence[Liste])), collapse = "', '"), 
          "'.\\\\

               "
        )
      )
    }
  } else {
    Test = 0
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les essences rencontrées dans la table '", 
        deparse(substitute(df)), "' sont présentes dans la table '", 
        deparse(substitute(essence_DF)), "'."
      )
    )
  }
  return(Test)
}

##### 5/ Fonction contrôle des stades de décomposition #####
Controle_Durete <- function(
  CodeDurete, Table, Test = 0
) {
  pos <- which(!is.element(Table$StadeD, c(NA, CodeDurete$Code)))

  if (length(pos) > 0) {
    Test <- 2
    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) de décomposition non conforme(s) détecté(s) dans la table '", 
          deparse(substitute(Table)), "' :"
        )
      )
      df <- Table[pos, c(1:4, match("StadeD", names(Table)))]
      print(
        xtable(
          df, 
          caption  = 
            paste0(
              "\\footnotesize{Liste des stades de décomposition non reconnus dans la table '", 
              deparse(substitute(Table)), "'.}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
          label = paste0("Tab-", deparse(substitute(Table)))
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")

    } else {

      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) de décomposition non conforme(s) détecté(s) dans la table '", 
          deparse(substitute(Table)), 
          "' : ", length(pos), " erreurs détectées."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes de décomposition rencontrés dans la table '", 
        deparse(substitute(Table)), "' sont conformes."
      )
    )
  }
  return(Test)
}

##### 6/ Fonction contrôle des stades d'écorce #####
Controle_Ecorce <- function(
  CodeEcorce, Table, Test = 0
) {
  pos <- which(!is.element(Table$StadeE, c(NA, CodeEcorce$Code)))

  if (length(pos) > 0) {
    Test <- 2
    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) écorce non conforme(s) détecté(s) dans la table '", 
          deparse(substitute(Table)), "' :"
        )
      )
      df <- Table[pos, c(1:4, match("StadeE", names(Table)))]
      print(
        xtable(
          df, 
          caption  = 
            paste0(
              "\\footnotesize{Liste des stades écorce non reconnus dans la table '", deparse(substitute(Table)), "'.}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = paste0("Tab-", deparse(substitute(Table)))
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) écorce non conforme(s) détecté(s) dans la table '", deparse(substitute(Table)), 
          "' : ", length(pos), " erreurs détectées."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes écorce rencontrés dans la table '", 
        deparse(substitute(Table)), "' sont conformes."
      )
    )
  }
  return(Test)
}

##### fonction de préparation de la table Arbres #####
# TODO : rajouter les autres tables en arguments
prep_df <- function(
  df = NULL, echant_DF = NULL, 
  code_qual = NULL, code_essreg = NULL,
  code_tarif = NULL, code_prix = NULL,
  diam_cat = NULL
) {
  df <-
    df %>%
    # filter(NumPlac == "21_3308") %>% # debug
    left_join(
      code_qual %>% select(-Couleur), 
      by = c("NumForet", "Qual" = "Nom")
    ) %>%
    left_join(
      code_essreg %>% select(-Couleur), 
      by = c("NumForet", "Essence")
    ) %>%
    mutate(
      Cycle = as.numeric(Cycle), 
      # NumArbre = as.numeric(NumArbre), 
      Limite = 1, 
      Dist = as.numeric(Dist), 
      Azimut = as.numeric(Azimut), 
      Diam1 = as.numeric(Diam1), 
      Diam2 = as.numeric(Diam2), 
      Haut = as.numeric(Haut), 
      Stade = as.numeric(Stade), 
      Diam1 = ifelse(is.na(Diam1), Diam2, Diam1), 
      Diam2 = ifelse(is.na(Diam2), Diam1, Diam2), 
      Diam1 = ifelse(Diam1 == 0, Diam2, Diam1), 
      Diam2 = ifelse(Diam2 == 0, Diam1, Diam2), 
      Diam = (Diam1 + Diam2) / 2, 
      Classe = floor(Diam / 5 + 0.5) * 5, 
      # définition de Cat à partir de Diam et pas Diam1 car on veut que la 
      # population ait un sens au point de vue dendrométrique 
      # (mais attention, calculs toujours fondés sur Diam1)
      Cat = cut(
        Diam, 
        breaks = c(diam_cat$Diam, Inf), 
        labels = diam_cat$Cat, 
        include.lowest = T, 
        right = F
      ), 
      Cat = as.character(Cat), 
      Nha = NA
    ) %>%
    left_join(code_tarif, by = c("NumForet", "Essence", "Strate")) %>%
    left_join(code_prix, by = c("NumForet", "Essence", "Classe", "Reg1" = "Qual")) %>%
    mutate(PU = ifelse(
      Classe < 7.5 & !is.na(Classe), 0, PU
    )) %>%
    arrange(NumForet, NumPlac, NumArbre, Cycle) %>%
    filter(
      !is.na(Diam1) | !is.na(Diam2) | Diam1 == 0 | Diam2 == 0
    )
  
  # -- retour fonction prep_df
  return(df)
}

##### 8/ Fonction de calcul du poids de la table Arbres #####
calculs_Nha <- function(df = NULL) {
  # ---------- Cas des perches sans mesure de distance
  pos <- with(
    df, 
    which(Cat == "PER" & is.na(Dist) & Diam1 >= DiamLim1 & is.na(Type))
  ) 
  # Changement Verif_Calculs : rajout de la condition "Diam1 >= DiamLim1"
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / df$Rayon1[pos] ^ 2
    df$Limite[pos] <- NA
  }
  
  # ---------- Cercles uniques
  pos <- with(
    df, 
    which(
      is.na(Nha) & is.na(DiamLim2) & Diam1 >= DiamLim1 &
        Dist <= Rayon1 * CoeffPente & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / df$Rayon1[pos] ^ 2
    df$Limite[pos] <- NA
  }
  # ---------- Cercles concentriques
  # 3eme cercle
  # pos <- with(
  #   df, 
  #   which(
  #     is.na(Nha) & !is.na(DiamLim3) & Diam1 >= DiamLim3 &
  #       Dist <= Rayon3 * CoeffPente & is.na(Type)
  #   )
  # )
  # if (length(pos) > 0) {
  #   df[pos, "Nha"] <- 10000 / pi / df$Rayon3[pos] ^ 2
  #   df$Limite[pos] <- NA
  # }
  # 2eme cercle avec 3eme cercle
  pos <- with(
    df, 
    which(
      is.na(Nha) & !is.na(DiamLim3) & Diam1 >= DiamLim2 & Diam1 < DiamLim3 &
        Dist <= Rayon2 * CoeffPente & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / df$Rayon2[pos] ^ 2
    df$Limite[pos] <- NA
  }
  # 2eme cercle sans 3eme cercle
  pos <- with(
    df, 
    which(
      is.na(Nha) & is.na(DiamLim3) & Diam1 >= DiamLim2 &
        Dist <= Rayon2 * CoeffPente & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / df$Rayon2[pos] ^ 2
    df$Limite[pos] <- NA
  }
  # 1er cercle avec 2eme cercle
  pos <- with(
    df, 
    which(
      is.na(Nha) & !is.na(DiamLim2) & Diam1 >= DiamLim1 &
        Diam1 < DiamLim2 & Dist <= Rayon1 * CoeffPente & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / df$Rayon1[pos] ^ 2
    df$Limite[pos] <- NA
  }
  
  # ---------- Angle fixe
  pos <- which(df$Diam1 < df$DiamLim & is.na(df$Type))
  if (length(pos) > 0) {
    df[pos, "Coeff"] <- NA
  }
  pos <- which(df$Diam1 >= df$DiamLim & is.na(df$Type)) # Changement Verif_Calculs Diam devient Diam1 -> indispensable sinon arbre de 29 par 32 sera inventorié ni par surface ni par angle fixe
  if (length(pos) > 0) {
    df[pos, "Nha"] <- NA # Remise à zéro au cas où il y aurait déjà des valeurs renseignées (cercle(s))
    df[pos, "Limite"] <- 1
  }
  pos <- with(
    df, 
    which(
      !is.na(Coeff) & Diam1 >= Dist * Coeff & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10 ^ 4 * df$Coeff[pos] ^ 2 / pi / df$Diam1[pos] ^ 2
    df$Limite[pos] <- NA
  }
  # cas des Arbres à inventorier par angle relascopique qui auraient été considérés comme non limite parce
  # que > DiamLim1, mais qui en fait sont hors inventaire
  pos <- with(
    df, 
    which(
      !is.na(Coeff) & Diam1 < Dist * Coeff & is.na(Type)
    )
  )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- NA
    df$Limite[pos] <- 1
  }
  
  
  
  
  # -- spécifique inventaire PP La Madeleine 
  # protocole BMP : 
  # + 1 cercle de 10m pour les Diam < 30
  # + 1 cercle de 20m pour les Diam >= 30
  pos <-
    with(
      df,
      which(
        is.na(Nha) & Diam1 >= 30 &
          Dist <= 20 & !is.na(Type)
      )
    )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / 20 ^ 2
    df$Limite[pos] <- NA
    df$TypeTarif[pos] <- "SchL" # default tarif for BMP
    df$NumTarif[pos] <- 6
  }
  # 1er cercle avec 2eme cercle pour les BMP
  pos <-
    with(
      df,
      which(
        is.na(Nha) & Diam1 < 30 &
          Dist <= 10 & !is.na(Type)
      )
    )
  if (length(pos) > 0) {
    df[pos, "Nha"] <- 10000 / pi / 10 ^ 2
    df$Limite[pos] <- NA
    df$TypeTarif[pos] <- "SchL" # default tarif for BMP
    df$NumTarif[pos] <- 6
  }
  
  # Nha mis à 0 pour les arbres limites
  pos <- which(df$Limite == 1)
  if (length(pos) > 0) df[pos, "Nha"] <- 0
  
  rm(pos)
  # -- retour fonction calculs_Nha
  return(df)
}


##### 9/ Fonction contrôle des qualités #####
Controle_Qual <- function(
  df, qual_DF = Quals, column = "Nom", Test = 0
) {
  Liste <- which(!(df$Qual %in% qual_DF[, column]) & !is.na(df$Qual))

  if (length(Liste) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Liste) == 1) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - la qualité suivante figure dans la table 'Arbres' mais ne figure pas dans la table '", 
          deparse(substitute(qual_DF)), "' : '", 
          paste0(unique(df$Qual[Liste]), collapse = "', '"), 
          "'.\\\\

               "
        )
      )
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - les qualités suivantes figurent dans la table 'Arbres' mais ne figurent pas dans la table '", 
          deparse(substitute(qual_DF)), "' : '", 
          paste0(sort(unique(df$Qual[Liste])), collapse = "', '"), 
          "'.\\\\

               "
        )
      )
    }
  } else {
    Test = 0
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les qualités rencontrées dans la table 'Arbres' sont présentes dans la table '", 
        deparse(substitute(qual_DF)), "'."
      )
    )
  }
  return(Test)
}

##### 10/ Fonction contrôle des notations de la colonne 'Coupe' #####
Controle_Coupe <- function(
  Table, Test = 0
) {
  if (!is.na(unique(Table$Coupe))) {
    pos <- which(!is.element(Table$Coupe, c(NA, "E", "Ch", "PF")))

    if (length(pos) > 0) {
      Test <- 2
      if (length(pos) <= 20) {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Notation 'Coupe' non conforme(s) détectée(s) dans la table 'Arbres' :"
          )
        )
        df <- Table[pos, c(1:4, match("Coupe", names(Table)))]
        print(
          xtable(
            df, 
            caption  = 
              paste0(
                "\\footnotesize{Liste des notations 'Coupe' non reconnue(s) dans la table 'Arbres'.}"
              ), 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
            label = paste0("Tab-", deparse(substitute(Table)))
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")

      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Notation(s) 'Coupe' non conforme(s) détectée(s) dans la table 'Arbres' : ", 
            length(pos), " erreurs détectées."
          )
        )
      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les notations de la colonne 'Coupe' rencontrées dans la table 'Arbres' sont conformes."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{Blue}{\\textbf{Remarque}} - Aucune notation renseignée dans la colonne 'Coupe' de la table 'Arbres'."
      )
    )
  }
  return(Test)
}

##### 11/ Fonction contrôle si changement de protocolechange_protocole : extrait de la table Echantillonnages les cycles concernés par le(s) changement(s) de protocole (s'il(s) existe(nt)) #####
change_protocole <- function (echant_DF) {
  # on détecte si le protocole change à travers les cycles d'inventaire
  echant_NAMES <- syms(setdiff(names(echant_DF), "Cycle"))
  echant_DF <-
    echant_DF %>%
    distinct(!!!echant_NAMES, .keep_all = T)
  # on recrée une table "echant_DF" avec les paramètres du plus
  # grand dénominateur commun entre les 2 (ou plus) protocoles d'inventaire
  # différents
  echant_DF <-
    echant_DF %>%
    group_by(NumForet, Strate) %>%
    mutate(
      DiamLim1 = min(DiamLim1), 
      Rayon1 = min(Rayon1), 

      DiamLim2 = min(DiamLim2), 
      Rayon2 = min(Rayon2), 

      DiamLim3 = min(DiamLim3), 
      Rayon3 = min(Rayon3), 

      DiamLim = min(DiamLim), 
      Coeff = max(Coeff), 

      # Identifiant pour retrouver les arbres concernés par le
      # changement de protocole
      echant_ID  = 
        paste0(
          NumForet, "-", Cycle, "-", Strate
        ), 
      Observations = NULL
    ) %>%
    ungroup()
  # retour fonction change_protocole
  return(echant_DF)
}

##### 12/ Fonction contrôle cohérence des placettes entre elles #####
miss_plot <- function(
  Table, vect = c("NumForet", "NumPlac")
) {
  if (dim(Table)[1] > 0) {
    if (deparse(substitute(Table)) == "Arbres") {
      temp1 <-
        Table %>%
        filter(!is.na(NumArbre)) %>%
        select(one_of("NumForet", "NumPlac", "Cycle")) %>%
        distinct()
    } else {
      temp1 <-
        Table %>%
        select(one_of(vect)) %>%
        distinct()
    }

    temp1$Corresp1 <- 1
    temp2 <- Placettes[, vect]
    temp2$Corresp2 <- 2
    temp3 <- full_join(temp1, temp2)
    temp3 <-
      temp3 %>%
      filter(is.na(temp3$Corresp1) | is.na(temp3$Corresp2))

    List1 <- which(is.na(temp3$Corresp1))
    List2 <- which(is.na(temp3$Corresp2))

    if (length(List2) > 0) {
      if (length(List2) <= 30) {
        Test <- ifelse(Test >= 2, Test, 2)

        cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - A travers les différents inventaires, un/des numéro(s) de placette(s) figure(nt) dans la table '", 
                       deparse(substitute(Table)), 
                       "' mais ne figure(nt) pas dans la table 'Placettes'\\\\"))

        t <- temp3[List2, ] %>% select(one_of(vect)) %>% distinct()

        print(
          xtable(
            t, 
            caption = utf82LaTeX("\\footnotesize{Liste des placettes renseignées dans la table '", 
                                 deparse(substitute(Table)), 
                                 "' mais ne figurant pas dans la table 'Placettes'.}"), 
            caption.placement = "bottom", 
            digits = rep(0, dim(t)[2] + 1), 
            align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2] - 1)), 
            label = paste0("TabMiss2_", deparse(substitute(Table)), "Placettes")
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:dim(t)[1]), 
          size = "\\scriptsize")
        cat("\\FloatBarrier
            ")
      } else {
        cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - A travers les différents inventaires, des numéros de placettes figurent dans la table '", 
                              deparse(substitute(Table)), 
                              "' mais pas dans la table 'Placettes' : ", 
                              length(List2), " erreurs détectées.\\\\")))
      }
    }
    if (length(List1) > 0) {
      if (length(List1) <= 30) {
        Test <- ifelse(Test > 0, Test, 1)

        cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - A travers les différents inventaires, un/des numéro(s) de placette(s) figure(nt) dans la table 'Placettes' mais ne figure(nt) pas dans la table '", 
                              deparse(substitute(Table)), "' : \\\\")))
        # }
        t <- temp3[List1, ] %>% select(one_of(vect)) %>% distinct()

        print(
          xtable(
            t, 
            caption = utf82LaTeX("\\footnotesize{Liste des placettes renseignées dans la table 'Placettes' mais ne figurant pas dans la table '", 
                                 deparse(substitute(Table)), "'.}"), 
            caption.placement = "bottom", 
            digits = rep(0, dim(t)[2] + 1), 
            align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2] - 1)), 
            label = paste0("TabMiss3_", deparse(substitute(Table)), "Placettes")
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:dim(t)[1]), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
            ")
      } else {
        Test <- ifelse(Test > 0, Test, 1)
        cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - A travers les différents inventaires, des numéros de placettes figurent dans la table 'Placettes' mais ne figure(nt) pas dans la table '", 
                       deparse(substitute(Table)), "' : ", length(List1), 
                       " éléments détectés\\\\"))
      }
    }
    if (length(List1) == 0 & length(List2) == 0) {
      cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table '", 
                     deparse(substitute(Table)), 
                     "' et la table 'Placettes' sont cohérentes."))
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table '", 
                   deparse(substitute(Table)), "' est vide."))
  }
  # retour fonction miss_plot
  return(Test)
}


# Miss2_bis <- function(Table) {
#   if (dim(Table)[1] > 0) {
#     temp1 <- distinct(Table, 
#                       # one_of("NumForet", "NumPlac", "Cycle"), 
#                       NumForet, NumPlac)
#     temp1$Corresp1 <- 1
#     temp2 <- Placettes[, c("NumForet", "NumPlac")]
#     temp2$Corresp2 <- 2
#     temp3 <- full_join(temp1, temp2, all = T, 
#                        by = c("NumForet" = "NumForet", 
#                             "NumPlac" = "NumPlac"))
#     temp3 <- temp3[which(is.na(temp3$Corresp1) | is.na(temp3$Corresp2)), ]
#
#     List1 <- which(is.na(temp3$Corresp1))
#     List2 <- which(is.na(temp3$Corresp2))
#
#     if (length(List2) > 0) {
#       if (length(List2) <= 20) {
#         Test <- ifelse(Test >= 2, Test, 2)
#         cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers inventaires : un/des numéro(s) de placette(s) figure(nt) dans la table '", 
#                    deparse(substitute(Table)), 
#                    "' mais ne figure(nt) pas dans la table 'Placettes'.\\\\
#
#                    ")))
#
#         t <- distinct(temp3[List2, ], 
#                       NumForet, NumPlac) %>%
#           group_by(NumForet) %>%
#           mutate(NbrePlac = length(NumPlac)) %>%
#           ungroup() %>%
#           select(NumForet, NumPlac)
#
#         print(xtable(t, 
#                      caption = utf82LaTeX(paste0("\\footnotesize{Liste des placettes renseignées dans la table '", 
#                                                  deparse(substitute(Table)), 
#                                                  "' mais ne figurant pas dans la table 'Placettes'.}")), 
#                      caption.placement = "bottom", 
#                      digits = rep(0, dim(t)[2]+1), 
#                      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2]-1)), 
#                      label = paste0("TabMiss2_", deparse(substitute(Table)), "Placettes")), 
#               include.rownames = FALSE, 
#               include.colnames = TRUE, 
#               hline.after = c(-1:dim(t)[1]), 
#               size = "\\scriptsize")
#         cat("\\FloatBarrier
#             ")
#       } else {
#         cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table '", 
#                    deparse(substitute(Table)), 
#                    "' mais pas dans la table 'Placettes' : ", 
#                    length(List2), " erreurs détectées.")))
#         # ListDisp_Verif <- unique(temp3$NumForet[List2])
#         # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
#         # Vector2Table_Print(ListDisp_Verif, 
#         #                    paste0("Liste des dispositifs de la base PSDRF ayant des placettes renseignées dans la table", 
#         #                           deparse(substitute(Table)), 
#         #                           "mais pas dans la table Placettes."), 
#         #                    paste0("TabMiss2_", deparse(substitute(Table)), "Placettes"))
#       }
#     }
#     if (length(List1) > 0) {
#       if (length(List1) <= 20) {
#         if (deparse(substitute(Table)) == "Cycles") {
#           Test <- ifelse(Test >= 2, Test, 2)
#           cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table 'Placettes' mais ne figure(nt) pas dans la table 'Cycles' :\\\\")))
#         } else {
#           Test <- ifelse(Test > 0, Test, 1)
#         cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table 'Placettes' mais ne figure(nt) pas dans la table '", 
#                    deparse(substitute(Table)), 
#                    "' :\\\\")))
#         }
#         t <- distinct(temp3[List1, ], 
#                       NumForet, NumPlac) %>%
#           group_by(NumForet) %>%
#           mutate(NbrePlac = length(NumPlac)) %>%
#           ungroup() %>%
#           select(NumForet, NumPlac)
#
#         print(xtable(t, 
#                      caption = utf82LaTeX(paste0("\\footnotesize{Liste des placettes renseignées dans la table 'Placettes' mais ne figurant pas dans la table '", 
#                                                  deparse(substitute(Table)), "'.}")), 
#                      caption.placement = "bottom", 
#                      digits = rep(0, dim(t)[2]+1), 
#                      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2]-1)), 
#                      label = paste0("TabMiss3_", deparse(substitute(Table)), "Placettes")), 
#               include.rownames = FALSE, 
#               include.colnames = TRUE, 
#               hline.after = c(-1:dim(t)[1]), 
#               size = "\\scriptsize")
#         cat("\\FloatBarrier
#             ")
#       } else {
#         if (deparse(substitute(Table)) == "Cycles") {
#           Test <- ifelse(Test >= 2, Test, 2)
#           cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table 'Placettes' mais ne figure(nt) pas dans la table 'Cycles' : ", 
#                                 length(List1), " erreurs détectées.")))
#         } else {
#           Test <- ifelse(Test > 0, Test, 1)
#         cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table 'Placettes' mais ne figure(nt) pas dans la table '", 
#                    deparse(substitute(Table)), 
#                    " : ", length(List1), "' éléments détectés.")))
#         }
#         # ListDisp_Verif <- unique(temp3$NumForet[List1])
#         # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
#         # Vector2Table_Print(ListDisp_Verif, 
#         #                    paste0("Liste des dispositifs de la base PSDRF ayant des placettes renseignées dans la table Placettes mais pas dans la table ", 
#         #                           deparse(substitute(Table)), 
#         #                           " des fichiers d'inventaire."), 
#         #                    paste0("TabMiss3_", deparse(substitute(Table)), "Placettes"))
#       }
#     }
#     if (length(List1) == 0 & length(List2) == 0) {
#       cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table '", 
#                  deparse(substitute(Table)), 
#                  "' et la table 'Placettes' sont cohérentes.")))
#     }
#   } else {
#     cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table '", deparse(substitute(Table)), "' est vide.")))
#   }
#   return(Test)
# }
@

\begin{document}
\textcolor{red}{\Large ATTENTION checl de EssReg à revoir}

% -- 1st page
\thispagestyle{empty} % la page en tour n'a pas de numéro de page

\begin{center}

\begin{figure}[ht]
\centering

\includegraphics[height = 2.5cm]{\Sexpr{ForestAllia_LOGO}}
\end{figure}

\vspace*{5cm}
\textbf{Rapport automatique de vérification des données GF de la forêt\\
\vspace{0,5cm}
\Sexpr{basename(file_path_sans_ext(forest_name))}}\\
\vspace{1cm}
\vspace{0,5cm}
\date{\year}
\end{center}

\begin{center}
\today\\
% \vspace{15cm}
\vfill


\begin{multicols}{3}
\begin{flushleft}
\includegraphics[height = 1.5cm]{\Sexpr{AFI_LOGO}}
\end{flushleft}

\scriptsize{Conçu et développé par\\ Max Bruciamacchie et Valentin Demets\\ en collaboration avec Julien Tomasini}

\begin{flushright}
\includegraphics[height = 1.5cm]{\Sexpr{APT_LOGO}} % changement
\end{flushright}
\end{multicols}

\end{center}
% -- fin 1st page

\newpage\null\thispagestyle{empty}\newpage

\section*{Introduction}
Que ce soit à l'échelle d'une propriété, d'un massif ou d'un territoire, un réseau de placettes permanentes fournit aux décideurs les éléments nécessaires à des audits réguliers des espaces forestiers dont ils sont maîtres d'ouvrage, et il sert aux gestionnaires à optimiser la gestion qu'ils sont chargés de mettre en \oe uvre.\\
Ce rapport présente de manière succincte l'état de complétude et de validation des données pour la forêt \Sexpr{Forets$Nom} (fichier source : \Sexpr{paste0(basename(foret), ".xlsx")}). Il est généré automatiquement grâce au logiciel RStudio.


\tableofcontents
\thispagestyle{empty} % la page en tour n'a pas de numéro de page
\setcounter{page}{0}
\newpage

\section{Tables principales/administrateur}
\subsection{Table Foret}
<<Foret, results = 'asis'>>= 
test = 0

##### 1/ Contrôle des valeurs vides des variables #####
cat("\\subsubsection{Contrôle des valeurs vides}\n")

# variables indispensables
vars_to_check <- "NumForet"
test_level <- 2 # possible values = 1/0

test <- check_missing_values(
  table = Forets, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

# variables non indispensables
vars_to_check <- setdiff(names(Forets), "NumForet")
test_level <- 1 # possible values = 1/0

test <- check_missing_values(
  table = Forets, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

##### 2/ Contrôle des valeurs dupliquées #####
cat("\\subsubsection{Contrôle des valeurs dupliquées}\n")

# variables indispensables
vars_to_check <- "NumForet"
test_level = 2

test <- check_duplicated_rows(
  table = Forets, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

# variables non indispensables
vars_to_check <- setdiff(names(Forets), c("NumForet", "Observations"))
test_level = 1

 test <- check_duplicated_rows(
  table = Forets, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

##### Fin #####
display_check_results(test)
@
\FloatBarrier

\subsection{Table Cycle}
<<Cycle, results = 'asis'>>=
test = 0

if (nrow(Cycles) > 0) { # cond 'nrow(Cycles) > 1'
 last_cycle <- max(Cycles$Cycle)

 ##### 1/ Contrôle des valeurs vides des variables #####
 cat("\\subsubsection{Contrôle des valeurs vides}\n")

 # variables indispensables
vars_to_check <- c("NumForet", "Cycle", "Annee")
test_level <- 2 # possible values = 1/0

test <- check_missing_values(
  table = Cycles, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

# variables non indispensables
vars_to_check <- 
  setdiff(names(Cycles), c("NumForet", "Cycle", "Annee", "Observations"))
test_level <- 1 # possible values = 1/0

test <- check_missing_values(
  table = Cycles, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)
 
 ##### 2/ Contrôle des valeurs dupliquées #####
cat("\\subsubsection{Contrôle des valeurs dupliquées}\n")

# variables indispensables
vars_to_check <- c("NumForet", "Cycle", "Annee")
test_level = 2

test <- check_duplicated_rows(
  table = Cycles, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

# variables non indispensables
vars_to_check <- 
  setdiff(names(Cycles), c("NumForet", "Cycle", "Annee", "Observations"))
test_level = 1

test <- check_duplicated_rows(
  table = Cycles, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test
)

##### 3/ Contrôle de la cohérence avec les tables d'inventaire #####
cat(paste0("\\subsubsection{Contrôle sur les numéros d'inventaire (cycles) rencontrés dans les tables d'inventaire}\nPrincipe : tous les cycles rencontrées dans l'inventaire doivent figurer dans la table Cycles\\\\ \n"))

cat(paste0("\\paragraph{Cycles de la table Arbres}\n"))
test <- check_cycle(
  table = Cycles, 
  reference_table = Arbres, 
  test_level = 2,
  test = test
)
if (nrow(Reges) > 0) { # cond 'nrow(Reges) > 0'
  cat(paste0("\\paragraph{Cycles de la table Reges}\n"))
  test <- check_cycle(
    table = Cycles, 
    reference_table = Reges, 
    test_level = 2,
    test = test
  )
} # end of cond 'nrow(Reges) > 0'
if (nrow(Cercles) > 0) { # cond 'nrow(Cercles) > 0'
  cat(paste0("\\paragraph{Cycles de la table Cercles}\n"))
  test <- check_cycle(
    table = Cycles, 
    reference_table = Cercles, 
    test_level = 2,
    test = test
  )
} # end of cond 'nrow(Cercles) > 0'
if (nrow(PCQM) > 0) { # cond 'nrow(PCQM) > 0'
  cat(paste0("\\paragraph{Cycles de la table PCQM}\n"))
  test <- check_cycle(
    table = Cycles, 
    reference_table = PCQM, 
    test_level = 2,
    test = test
  )
} # end of cond 'nrow(PCQM) > 0'
if (nrow(BMSLineaires) > 0) { # cond 'nrow(BMSLineaires) > 0'
  cat(paste0("\\paragraph{Cycles de la table BMSLineaires}\n"))
  test <- check_cycle(
    table = Cycles, 
    reference_table = BMSLineaires, 
    test_level = 2,
    test = test
  )
} # end of cond 'nrow(BMSLineaires) > 0'
if (nrow(BMSCercles) > 0) { # cond 'nrow(BMSCercles) > 0'
  cat(paste0("\\paragraph{Cycles de la table BMSCercles}\n"))
  test <- check_cycle(
    table = Cycles, 
    reference_table = BMSCercles, 
    test_level = 2,
    test = test
  )
} # end of cond 'nrow(BMSCercles) > 0'

##### 4/ Contrôle qu'il n'y ait pas des cycles qui sautent (passe de 1 à 3) #####
 if (last_cycle > 2) { # end of cond 'last_cycle > 2'
   cat(paste0(
     "\\subsubsection{Contrôle des numéros d'inventaire pour le dispositif ", 
     forest_num, "}\n"
   ))
   
   # détection des différences entre valeur max et décompte des cycles
   table <-
     Cycles %>% 
     # security : distinct values + filter NA values
     distinct(NumForet, Cycle) %>% 
     filter(!is.na(Cycle)) %>% 
     
     # calculate cycle nbre + cycle max
     group_by(NumForet) %>% 
     summarise(
       cycle_nb = n(),
       cycle_max = max(Cycle)) %>%
     ungroup()
   
   # liste des dispositifs montrant une incohérence entre les cycles
   stand_with_cycle_issues <- with(table, NumForet[which(cycle_nb != cycle_max)])
   
   if (length(stand_with_cycle_issues) > 0) { # cond 'length(stand_with_cycle_issues) > 0'
     # set 'test' var
     if (test < 2) test <- 2 # error detected : major = 2 / minor = 1
     
     # print error message
     cat(paste0(
       "\\textcolor{red}{\\textbf{Correction nécessaire}} - Cycle(s) manquant(s) (exemple : passage du cycle 1 au cycle 3) détecté dans la table 'Cycles' pour le dispositif ", 
       forest_num, "\\\\"
     ))
     
   } else { # else of cond 'length(stand_with_cycle_issues) > 0'
     
     # print message
     cat(paste0(
       "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Pas de cycle sautés (exemple : passage du cycle 1 au cycle 3) dans la table 'Cycles' pour le dispositif ", 
       forest_num, "\\\\"
     ))
   } # end of cond 'length(stand_with_cycle_issues) > 0'
 } # end of cond 'last_cycle > 2'

} # end of cond 'nrow(Cycles) > 1'
 
 ##### Fin #####
 display_check_results(test)
@
\FloatBarrier

\subsection{Table Echantillonnage}
<<Echantillonnage, results = 'asis'>>=
test = 0

if (nrow(Echantillonnages) > 0) { # cond 'nrow(Echantillonnages) > 1'
  last_cycle <- max(Echantillonnages$Cycle)
  
  ##### 1/ Contrôle des valeurs vides des variables #####
  cat("\\subsubsection{Contrôle des valeurs vides}\n")
  
  # variables indispensables
  vars_to_check <- c("NumForet", "Cycle", "Strate")
  test_level <- 2 # possible values = 1/0
  
  test <- check_missing_values(
    table = Echantillonnages, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  # variables non indispensables
  vars_to_check <- 
    setdiff(names(Echantillonnages), c("NumForet", "Cycle", "Strate", "Observations"))
  test_level <- 1 # possible values = 1/0
  
  test <- check_missing_values(
    table = Echantillonnages, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  ##### 2/ Contrôle des valeurs dupliquées #####
  cat("\\subsubsection{Contrôle des valeurs dupliquées}\n")
  
  # variables indispensables
  vars_to_check <- c("NumForet", "Cycle", "Strate")
  test_level = 2
  
  test <- check_duplicated_rows(
    table = Echantillonnages, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  # variables non indispensables
  vars_to_check <- 
    setdiff(names(Echantillonnages), c("NumForet", "Cycle", "Strate", "Observations"))
  test_level = 1
  
  test <- check_duplicated_rows(
    table = Echantillonnages, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  ##### 4/ Contrôle qu'il n'y ait pas des cycles qui sautent (passe de 1 à 3) #####
  if (last_cycle > 2) { # end of cond 'last_cycle > 2'
    cat(paste0(
      "\\subsubsection{Contrôle des numéros d'inventaire pour le dispositif ", 
      forest_num, "}\n"
    ))
    
    # détection des différences entre valeur max et décompte des cycles
    table <-
      Echantillonnages %>% 
      # security : distinct values + filter NA values
      distinct(NumForet, Cycle) %>% 
      filter(!is.na(Cycle)) %>% 
      
      # calculate cycle nbre + cycle max
      group_by(NumForet) %>% 
      summarise(
        cycle_nb = n(),
        cycle_max = max(Cycle)) %>%
      ungroup()
    
    # liste des dispositifs montrant une incohérence entre les cycles
    stand_with_cycle_issues <- with(table, NumForet[which(cycle_nb != cycle_max)])
    
    if (length(stand_with_cycle_issues) > 0) { # cond 'length(stand_with_cycle_issues) > 0'
      # set 'test' var
      if (test < 2) test <- 2 # error detected : major = 2 / minor = 1
      
      # print error message
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Cycle(s) manquant(s) (exemple : passage du cycle 1 au cycle 3) détecté dans la table 'Echantillonnages' pour le dispositif ", 
        forest_num, "\\\\"
      ))
      
    } else { # else of cond 'length(stand_with_cycle_issues) > 0'
      
      # print message
      cat(paste0(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Pas de cycle sautés (exemple : passage du cycle 1 au cycle 3) dans la table 'Echantillonnages' pour le dispositif ", 
        forest_num, "\\\\"
      ))
    } # end of cond 'length(stand_with_cycle_issues) > 0'
  } # end of cond 'last_cycle > 2'
  
  
  ##### 5/ Contrôle si changement de protocole #####
  if (last_cycle > 1) {
    cat(paste0(
      "\\subsubsection{Contrôle des protocoles d'inventaire (changement de protocole)}"
    ))
    
    # find protocole modifications
    warnings_table <- change_protocole(Echantillonnages)
    warnings_cycle <- unique(warnings_table$Cycle)
    
    if (nrow(warnings_table) > 0) { # cond 'nrow(warnings_table) > 0'
      # print message
      cat(paste0(
        "\\textcolor{Blue}{\\textbf{Remarque}} - Dans la table 'Echantillonnage', il y a eu un changement de protocole détecté entre les inventaires ", 
        paste0(warnings_cycle, collapse = " et "), 
        "\\\\"
      ))
    } # end of cond 'nrow(warnings_table) > 0'
  }
  
  ##### 6/ Contrôle de valeurs particulières #####
  cat("\\subsubsection{Contrôle des valeurs d'angle relascopique, des colonnes 'Taillis' et 'BMP'}\n")
  
  # -- angle relascopique
  cat("\\paragraph{Angle relascopique}")
  
  # table
  table <- Echantillonnages %>% filter(!is.na(Coeff))
  
  if (nrow(table) > 0) { # cond 'nrow(table) > 0'
    # detect angle issues
    angle_issues <- with(Echantillonnages, which( !is.na(Coeff) & Coeff >= 1 ))
    
    if (length(angle_issues) > 0) { # cond 'length(angle_issues) > 0'
      # print error message
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a un/des coefficient(s) d'angle inférieur(s) à 1 renseigné(s) dans la table 'Echantillonnages' pour le dispositif ", 
        forest_num, 
        "\\\\\nRappel : pour un angle de 3%, noter 0.03 dans la colonne Coeff de la feuille 'Echantillonnages'\\\\\n"
      ))
    } else { # else of cond 'length(angle_issues) > 0'
      
      # print error message
      cat(paste0(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun coefficient d'angle supérieur à 1 renseigné(s) dans la table 'Echantillonnages' pour le dispositif ", 
        forest_num, "\\\\\n"
      ))
    } # end of cond 'length(angle_issues) > 0'
  } else { # else of cond 'nrow(table) > 0'
    
    # print error message
    cat(paste0(
      "\\textcolor{Red}{\\textbf{Correction nécessaire}} - Aucun angle relascopique renseigné pour le dispositif ",
      forest_num, "\\\\\n"
    ))
  } # end of cond 'nrow(table) > 0'
  
  
  # -- colonne 'Taillis'
  cat("\\paragraph{Colonne 'Taillis'}")
  
  # table
  table <- Echantillonnages %>% filter(!is.na(Taillis))
  
  if (nrow(table) > 0) { # cond 'nrow(table) > 0'
    # detect angle issues
    coppice_issues <- 
      with(Echantillonnages, which( !is.na(Taillis) & !is.numeric(Taillis) ))
    
    if (length(coppice_issues) > 0) { # cond 'length(coppice_issues) > 0'
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a une/des valeur(s) non numérique(s) renseignée(s) dans la colonne 'Taillis' de la table 'Echantillonnages' pour le dispositif ", 
        forest_num, 
        "\\\\\nRappel : pour un inventaire par surface fixe ou par PCQM, indiquer le rayon maximum de prospection (ex : 10 m par surface fixe, 25 m pour le PCQM)\\\\\n"
      ))
    } else { # else of cond 'length(coppice_issues) > 0'
      
      # print error message
      cat(paste0(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune valeur non numérique renseignée dans la colonne 'Taillis' de la table 'Echantillonnages' pour le dispositif ", 
        forest_num, "\\\\\n"
      ))
    } # end of cond 'length(coppice_issues) > 0'
  } else { # else of cond 'nrow(table) > 0'
    
    # print error message
    cat(paste0(
      "\\textcolor{Red}{\\textbf{Correction nécessaire}} - Aucun paramètre d'échantillonnage renseigné pour le 'Taillis' pour le dispositif ",
      forest_num, "\\\\\n"
    ))
  } # end of cond 'nrow(table) > 0'
  
  
  # -- colonne 'BMP'
  cat("\\paragraph{Colonne 'BMP'}")
  
  # table
  table <- Echantillonnages %>% filter(!is.na(BMP))
  
  if (nrow(table) > 0) { # cond 'nrow(table) > 0'
    # detect angle issues
    standing_deadwood_issues <- 
      with(Echantillonnages, which( !is.na(BMP) & !is.numeric(BMP) ))
    
    if (length(standing_deadwood_issues) > 0) { # cond 'length(standing_deadwood_issues) > 0'
      # print error message
      cat(paste0(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a une/des valeur(s) non numérique(s) renseignée(s) dans la colonne 'BMP' de la table 'Echantillonnages' pour le dispositif ", 
        forest_num, 
        "\\\\\nRappel : pour un inventaire par surface fixe ou par PCQM, indiquer le rayon maximum de prospection (ex : 10 m par surface fixe, 25 m pour le PCQM)\\\\\n"
      ))
    } else { # else of cond 'length(standing_deadwood_issues) > 0'
      
      # print error message
      cat(paste0(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune valeur non numérique renseignée dans la colonne 'BMP' de la table 'Echantillonnages' pour le dispositif ", 
        forest_num, "\\\\\n"
      ))
    } # end of cond 'length(standing_deadwood_issues) > 0'
  } else { # else of cond 'nrow(table) > 0'
    
    # print error message
    cat(paste0(
      "\\textcolor{Red}{\\textbf{Correction nécessaire}} - Aucun paramètre d'échantillonnage renseigné pour le 'BMP' pour le dispositif ",
      forest_num, "\\\\\n"
    ))
  } # end of cond 'nrow(table) > 0'
  cat("\\FloatBarrier")
  
} else { # else of cond 'nrow(Tarifs) > 0'
  # set 'test' var
  if (test < 2) test <- 2
  
  # print error message
  cat(paste0(
    "\\textcolor{Red}{\\textbf{Correction nécessaire}} - Aucune information renseignée dans la table 'Echantillonnages' pour le dispositif ", 
    forest_num, "\\\\"
  ))
} # end of cond 'nrow(Tarifs) > 0'


##### Fin #####
display_check_results(test)
@
\FloatBarrier

\subsection{Table Placettes}
<<Placettes, results = 'asis'>>=
 test = 0

if (nrow(Placettes) > 0) { # cond 'nrow(Placettes) > 1'
  last_cycle <- max(Placettes$Cycle)
  
  ##### 1/ Contrôle des valeurs vides des variables #####
  cat("\\subsubsection{Contrôle des valeurs vides}\n")
  
  # variables indispensables
  vars_to_check <- c("NumForet", "NumPlac", "Cycle", "Strate", "PoidsPlacette")
  test_level <- 2 # possible values = 1/0
  
  test <- check_missing_values(
    table = Placettes, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  # variables non indispensables
  vars_to_check <- 
    setdiff(names(Placettes), c("NumForet", "NumPlac", "Cycle", "Strate", "PoidsPlacette", "Observations"))
  test_level <- 1 # possible values = 1/0
  
  test <- check_missing_values(
    table = Placettes, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  ##### 2/ Contrôle des valeurs dupliquées #####
  cat("\\subsubsection{Contrôle des valeurs dupliquées}\n")
  
  # variables indispensables
  vars_to_check <- c("NumForet", "NumPlac", "Cycle", "Strate", "PoidsPlacette")
  test_level = 2
  
  test <- check_duplicated_rows(
    table = Placettes, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  # variables non indispensables
  vars_to_check <- 
    setdiff(names(Placettes), c("NumForet", "NumPlac", "Cycle", "Strate", "PoidsPlacette", "Observations"))
  test_level = 1
  
  test <- check_duplicated_rows(
    table = Placettes, 
    vars_to_check = vars_to_check,
    test_level = test_level,
    test = test
  )
  
  ##### 3/ Contrôle de la cohérence avec les tables d'inventaire #####
cat(paste0("\\subsubsection{Contrôle sur les placettes listées dans les tables d'inventaire}\nPrincipe : tous les cycles rencontrées dans l'inventaire doivent figurer dans la table Placettes\\\\ \n"))

cat(paste0("\\paragraph{Placettes de la table Arbres}\n"))
test <- check_missing_plots(
  table = Arbres, 
  reference_table = Placettes,
  test_level = 2,
  test = test
)
if (nrow(Reges) > 0) { # cond 'nrow(Reges) > 0'
  cat(paste0("\\paragraph{Cycles de la table Reges}\n"))
  test <- check_missing_plots(
    table = Reges, 
    reference_table = Placettes,
    test_level = 1,
    test = test
  )
} # end of cond 'nrow(Reges) > 0'
if (nrow(Cercles) > 0) { # cond 'nrow(Cercles) > 0'
  cat(paste0("\\paragraph{Cycles de la table Cercles}\n"))
  test <- check_missing_plots(
    table = Cercles, 
    reference_table = Placettes,
    test_level = 1,
    test = test
  )
} # end of cond 'nrow(Cercles) > 0'
if (nrow(PCQM) > 0) { # cond 'nrow(PCQM) > 0'
  cat(paste0("\\paragraph{Cycles de la table PCQM}\n"))
   test <- check_missing_plots(
    table = PCQM, 
    reference_table = Placettes,
    test_level = 1,
    test = test
  )
} # end of cond 'nrow(PCQM) > 0'
if (nrow(BMSLineaires) > 0) { # cond 'nrow(BMSLineaires) > 0'
  cat(paste0("\\paragraph{Cycles de la table BMSLineaires}\n"))
  test <- check_missing_plots(
    table = BMSLineaires, 
    reference_table = Placettes,
    test_level = 1,
    test = test
  )
} # end of cond 'nrow(BMSLineaires) > 0'
if (nrow(BMSCercles) > 0) { # cond 'nrow(BMSCercles) > 0'
  cat(paste0("\\paragraph{Cycles de la table BMSCercles}\n"))
  test <- check_missing_plots(
    table = BMSCercles, 
    reference_table = Placettes,
    test_level = 1,
    test = test
  )
} # end of cond 'nrow(BMSCercles) > 0'

##### 4/ Contrôle qu'il n'y ait pas des cycles qui sautent (passe de 1 à 3) #####
 if (last_cycle > 2) { # end of cond 'last_cycle > 2'
   cat(paste0(
     "\\subsubsection{Contrôle des numéros d'inventaire pour le dispositif ", 
     forest_num, "}\n"
   ))
   
   # détection des différences entre valeur max et décompte des cycles
   table <-
     Placettes %>% 
     # security : distinct values + filter NA values
     distinct(NumForet, Cycle) %>% 
     filter(!is.na(Cycle)) %>% 
     
     # calculate cycle nbre + cycle max
     group_by(NumForet) %>% 
     summarise(
       cycle_nb = n(),
       cycle_max = max(Cycle)) %>%
     ungroup()
   
   # liste des dispositifs montrant une incohérence entre les cycles
   stand_with_cycle_issues <- with(table, NumForet[which(cycle_nb != cycle_max)])
   
   if (length(stand_with_cycle_issues) > 0) { # cond 'length(stand_with_cycle_issues) > 0'
     # set 'test' var
     if (test < 2) test <- 2 # error detected : major = 2 / minor = 1
     
     # print error message
     cat(paste0(
       "\\textcolor{red}{\\textbf{Correction nécessaire}} - Cycle(s) manquant(s) (exemple : passage du cycle 1 au cycle 3) détecté dans la table 'Cycles' pour le dispositif ", 
       forest_num, "\\\\"
     ))
     
   } else { # else of cond 'length(stand_with_cycle_issues) > 0'
     
     # print message
     cat(paste0(
       "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Pas de cycle sautés (exemple : passage du cycle 1 au cycle 3) dans la table 'Cycles' pour le dispositif ", 
       forest_num, "\\\\"
     ))
   } # end of cond 'length(stand_with_cycle_issues) > 0'
 } # end of cond 'last_cycle > 2'
 

   ##### 5/ Contrôle si ajout/suppression de placettes (continuité) #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des ajouts/suppressions de placettes.}"))

# issues table
  issues_table <-
    Placettes %>%
    select(NumForet, NumPlac, Cycle) %>%
    # filter(NumPlac %in% c(46, 47, 48)) %>% # debug
    complete(NumPlac, nesting(Cycle)) %>%
    arrange(NumForet, NumPlac, Cycle) %>%
    filter(is.na(NumForet)) %>%
    select(-NumForet)

  if (nrow(issues_table) > 0) {
    # update test var
    test = ifelse(test > 1, test, 1)

    if (nrow(issues_table) <= 40) {

      cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Placette non retrouvée à travers les différents inventaires (ajout/suppression de placette ?) dans la table 'Placettes' : \\\\"))

      print(
        xtable(
          issues_table, 
          caption = "\\footnotesize{Liste des placettes non retrouvées à certains cycles d'inventaire dans la table 'Placettes'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(issues_table) + 1), 
          align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(issues_table) - 1)), 
          label = "TabSuiviPlac_Placettes"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(issues_table)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Placette non retrouvée à travers les différents inventaires (ajout/suppression de placette ?) dans la table 'Placettes' : ", 
                   nrow(issues_table), " éléments détectés\\\\")
      )
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun ajout/suppression de placette détecté dans la table 'Placettes'\\\\

      ")
  }


  ##### Fin #####
  display_check_results(test)
  } else {  # else of cond 'nrow(Placettes) > 1'
  cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Aucune information renseignée dans la table 'Placettes'\\\\"))
}
@
\FloatBarrier

\subsection{Table Regroup}
<<Regroup, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(Regroups)[1] > 0) {
  ##### 1/ Contrôle des valeurs vides des variables #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  ListName <- c()
  for (name in names(Regroups)) {
    pos <- which(is.na(Regroups[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <-
      ListName[ListName %in% c("NumForet", "NumPlac", "Cycle")]
    Annexe <- ListName[!ListName %in% c(Vital, "Observations")] #, "Surface1"

    # --- Variables "vitales"
    cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))

    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)

      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", paste0(Vital, collapse = ", "), 
          "\\\\"
        )
      )

      df <-
        Regroups %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <-
      #   summaryBy(
      #     list(Vital, "NumForet"), data = Regroups, 
      #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
      #   )
      df <-
        if (length(Vital) == 1) {
          df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
        } else df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) df <- df %>% select(-NumForet)

      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <-
        paste0(Vital, " : nombre de vides")

      print(
        xtable(
          df, 
          caption  = 
            utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Vital, collapse = ", "), 
                ", indispensables à l'analyse des données}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissVital_Placettes"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("
          ")

    } else {
      Vital <- c("NumForet", "NumPlac", "Cycle")
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
          paste0(Vital, collapse = ", "), 
          ")\\\\"
        )
      )
    }

    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))

    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)

      cat(
        utf82LaTeX(
          "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", paste0(Annexe, collapse = ", "), 
          "\\\\"
        )
      )

      df <-
        Regroups %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <-
      #   summaryBy(
      #     list(Annexe, "NumForet"), data = Regroups, 
      #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
      #   )
      df <-
        if (length(Annexe) == 1) {
          df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
        } else df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Annexe)) df <- df %>% select(-NumForet)

      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
        paste0(Annexe, " : nombre de vides")

      print(
        xtable(
          df, 
          caption  = 
            utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Annexe, collapse = ", "), 
                ", non indispensables à l'analyse des données}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissAnnexe_Regroup"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
          ")
    } else {
      Vital <- c("NumForet", "NumPlac", "Cycle")
      Annexe <- names(Regroups)[!names(Regroups) %in% c(Vital, "Observations")]
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
          paste0(Annexe, collapse = ", "), 
          ")\\\\"
        )
      )
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'Regroup'\\\\"))
  }


  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Regroups <- arrange(Regroups, 
                      NumForet, NumPlac, Cycle)
  pos1 <- which(duplicated(Regroups))
  pos2 <- which(duplicated(Regroups, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\")
      df <- Regroups[Dupl, ]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table 'Regroup'.}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_Regroups"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(sort(unique(Regroups$NumPlac[Dupl])), collapse = ", "))))
      #, paste0(unique(Regroups$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Regroups$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table 'Regroup'", 
      #                    "TabDoublon_Regroups")
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'Regroup'\\\\

      ")
  }



  ##### 5/ Contrôle si ajout/suppression de placettes (continuité) #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des ajouts/suppressions de placettes}"))

  df <-
    Regroups %>%
    select(NumForet, NumPlac, Cycle) %>%
    # filter(NumPlac %in% c(46, 47, 48)) %>% # debug
    complete(NumPlac, nesting(Cycle)) %>%
    arrange(NumForet, NumPlac, Cycle) %>%
    filter(is.na(NumForet)) %>%
    select(-NumForet)

  if (nrow(df) > 0) {
    Test = ifelse(Test > 1, Test, 1)

    if (nrow(df) <= 40) {

      cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Placette non retrouvée à travers les différents inventaires (ajout/suppression de placette ?) dans la table 'Regroup' : \\\\"))

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des placettes non retrouvées à certains cycles d'inventaire dans la table 'Regroup'}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabSuiviPlac_Regroups"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Placette non retrouvée à travers les différents inventaires (ajout/suppression de placette ?) dans la table 'Regroup' : \\\\", 
                   nrow(df), " éléments détectés\\\\")
      )
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun ajout/suppression de placette détecté dans la table 'Regroups'\\\\

      ")
  }


  ##### 6/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(Regroups, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Aucune information renseignée dans la table 'Regroup'\\\\"))
}
@
\FloatBarrier

\subsection{Table Tarifs}
<<Tarifs, results = 'asis'>>= 
 test = 0
 
 if (nrow(Tarifs) > 0) { # cond 'nrow(Tarifs) > 0'
   
   ##### 1/ Contrôle des valeurs vides des variables #####
   cat("\\subsubsection{Contrôle des valeurs vides}\n")
   
   # variables indispensables
   vars_to_check <- c("NumForet", "Essence", "TypeTarif", "NumTarif")
   test_level <- 2 # possible values = 1/0
   
   test <- check_missing_values(
     table = Tarifs, 
     vars_to_check = vars_to_check,
     test_level = test_level,
     test = test
   )
   
   ##### 2/ Contrôle des valeurs dupliquées #####
   cat("\\subsubsection{Contrôle des valeurs dupliquées}\n")
   
   # variables indispensables
   vars_to_check <- c("NumForet", "Essence", "TypeTarif", "NumTarif") # debug
   test_level = 2
   
   test <- check_duplicated_rows(
     table = Tarifs, 
     vars_to_check = vars_to_check,
     test_level = test_level,
     test = test,
     columns_to_print = 1:4
   )
   
   ##### 3/ Essences inventoriées dans la table Tarifs #####
   cat(paste0(
     "\\subsubsection{Contrôle sur les essences listées dans la table 'Tarifs' pour le dispositif ", 
     forest_num, "}\n"
   ))
   
   # -- essences de la table 'Tarifs' bien présentes dans la table 'Essences' ?
   test <- check_species(
     table = Tarifs, 
     species_table = Essences,
     column = "Nom",
     test = test
   )
   
   # -- essences de la table 'Arbres' bien présentes dans la table 'Tarifs' ?
   test <- check_species(
     table = Arbres, 
     species_table = Tarifs,
     column = "Essence",
     test = test
   )
   cat("\\FloatBarrier")
   
 } else { # else of cond 'nrow(Tarifs) > 0'
   # set 'test' var
   if (test < 2) test <- 2
   
   # print error message
   cat(paste0(
     "\\textcolor{Red}{\\textbf{Correction nécessaire}} - Aucune information de tarif renseignée pour le dispositif ", 
     forest_num, "\\\\"
   ))
 } # end of cond 'nrow(Tarifs) > 0'
 
 
 ##### Fin #####
 display_check_results(test)
@
\FloatBarrier

\subsection{Table AccD}
<<AccD, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', eval = T, include = T>>=
if (dim(AcctD)[1] > 0) {
  Test = 0

  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}"))
  Test <- Test + Controle_Essence(AcctD)
  cat("\\FloatBarrier ")


  # ----- Contrôle des valeurs vides des variables :
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données.}"))
  ListName <- c()
  for (name in names(AcctD)) {
    pos <- which(is.na(AcctD[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <-
      ListName[ListName %in% c(
        "NumForet", "Strate", "Essence", "Classe"
        )]
    Annexe <- ListName[!ListName %in% c(Vital, "AcctD")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
          paste0(Vital, collapse = ", "), 
          "\\\\"
        )
      )

      df <-
        AcctD %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <-
      #   summaryBy(
      #     list(Vital, "NumForet"), data = AcctD, 
      #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
      #   )
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(
        xtable(
          df, 
          caption = utf82LaTeX(
            "\\footnotesize{Vides constatés dans les variables ", 
            paste0(Vital, collapse = ", "), 
            ", indispensables à l'analyse des données.}"
          ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissVital_AcctD"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
          ")
    } else {
      Vital <- c("NumForet", "Strate", "Essence", "Classe")
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
          paste0(Vital, collapse = ", "), 
          ")\\\\
               \\FloatBarrier
               "
        )
      )
    }

    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données.}"))
    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)
      cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Annexe, 
                                   collapse = ", "), 
                            " :")))

      df <-
        AcctD %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Annexe, "NumForet"), data = AcctD, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Annexe)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
        paste0(Annexe, " : nombre de vides")
      print(
        xtable(
          df, 
          caption = utf82LaTeX(
            "\\footnotesize{Vides constatés dans les variables ", 
            paste0(Vital, collapse = ", "), 
            ", non indispensables dans l'analyse des données.}"
          ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissAnnexe_AcctD"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
          ")
    } else {
      Vital <- c("NumForet", "Essence", "TypeTarif", "NumTarif")
      Annexe <- names(AcctD)[!names(AcctD) %in% c(Vital, "AcctD")]

      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
          paste0(Annexe, collapse = ", "), 
          ")\\\\"
        )
      )
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'AcctD'\\\\"))
  }


  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  AcctD <- AcctD %>% arrange(NumForet, Strate, Essence, Classe, AccD)
  pos1 <- which(duplicated(AcctD[, c("NumForet", "Strate", "Essence", "Classe")]))
  pos2 <- which(duplicated(AcctD[, c("NumForet", "Strate", "Essence", "Classe")], 
                           fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'AcctD' : \\\\")
      df <- AcctD[Dupl, c("NumForet", "Strate", "Essence", "Classe", "AccD")]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'AcctD'}", 
          caption.placement = "bottom", 
          # digits = rep(0, ncol(df) + 1), 
          digits = c(rep(0, ncol(df)), 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_AcctD"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'AcctD' : ", 
          length(Dupl), " doublons détectés\\\\"
        )
      )
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'AcctD' pour cette forêt\\\\")
  }


  # Contrôle des Essences de AcctD :
  cat(utf82LaTeX("\\subsubsection{Cohérence avec les essences listées dans les autres tables}"))
  # --- feuille Arbres
  cat(utf82LaTeX("\\paragraph{Arbres}"))
  ListEss <- setdiff(unique(Arbres$Essence), unique(AcctD$Essence))
  ListEss <- ListEss[!is.na(ListEss)]
  if (length(ListEss) > 0) {
    Test = ifelse(Test >= 1, Test, 1)
    cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Certaines essences rencontrées dans la feuille 'Arbres' ne sont pas renseignées dans la table 'AcctD' :\\\\"))
    Vector2Table_Print(
      ListEss, 
      "Liste des essences n'apparaissant pas dans la table 'AcctD'", 
      "TabEssArbres_AcctD"
    )
    cat("\\FloatBarrier
        ")
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les essences rencontrées dans la feuille 'Arbres' sont bien renseignées dans la table 'AcctD'"))
  }

    # --- feuille PCQM
  if (nrow(PCQM) > 0) {
      cat(utf82LaTeX("\\paragraph{PCQM}"))
    ListEss <- setdiff(unique(PCQM$Essence), unique(AcctD$Essence))
    ListEss <- ListEss[!is.na(ListEss)]
    if (length(ListEss) > 0) {
      Test = ifelse(Test >= 1, Test, 1)
      cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Remarque}} - Certaines essences rencontrées dans la feuille 'PCQM' ne sont pas renseignées dans la table 'AcctD' :\\\\"))
      Vector2Table_Print(
        ListEss, 
        "Liste des essences n'apparaissant pas dans la table 'AcctD'", 
        "TabEssPCQM_AcctD"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les essences rencontrées dans la feuille 'PCQM' sont bien renseignées dans la table 'AcctD'"))
    }
  }

    # --- feuille Cercles
  if (dim(Cercles)[1]) {
      cat(utf82LaTeX("\\paragraph{Cercles}"))
    ListEss <- setdiff(unique(Cercles$Essence), unique(AcctD$Essence))
    ListEss <- ListEss[!is.na(ListEss)]
    if (length(ListEss) > 0) {
      Test = ifelse(Test >= 1, Test, 1)
      cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Certaines essences rencontrées dans la feuille 'Cercles' ne sont pas renseignées dans la table 'AcctD' :\\\\"))
      Vector2Table_Print(
        ListEss, 
        "Liste des essences n'apparaissant pas dans la table 'AcctD'", 
        "TabEssCercles_AcctD"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les essences rencontrées dans la feuille 'Cercles' sont bien renseignées dans la table 'AcctD'"))
    }
  }
  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
}

if (dim(AcctD)[1] == 0 & last_cycle == 1) {
  cat(utf82LaTeX("\\textcolor{DarkViolet}{\\textbf{Attention}} - Aucune information d'accroissement en diamètre renseignée pour la forêt\\\\"))
}
if (dim(AcctD)[1] == 0 & last_cycle > 1) {
  cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Aucune information d'accroissement en diamètre renseignée pour la forêt\\\\"))
}
@
\FloatBarrier
\clearpage

\section{Tables d'inventaire/contenant les relevés}
\subsection{Table Arbres}
\subsubsection{Présentation de la table}
\paragraph{Essences inventoriées}
Les essences rencontrées dans la feuille Arbres de la forêt \Sexpr{paste0(forest_num, "-", Forets$Nom)} sont listées dans le tableau \ref{TabEssences}.\\
% \textcolor{red}{Contrôler les qualités vides !!}
<<Arbres1-Presentation, results = 'asis'>>=
##### 1/ Préparation de la table Arbres_DF #####
# --- 1.1/ Paramètres d'échantillonnage
Angle <-
  with(Echantillonnages, Coeff[NumForet == forest_num & Cycle == last_cycle] * 100)

# --- 1.2/ Fusion de tables
Arbres <-
  Arbres %>% 
  # filter(!is.na(Essence) & !is.na(Azimut) & !is.na(Dist)) %>%
  # et les éléments de bois mort ou non repérés ????
  # filtre ci-dessus important. Sinon pblme dcast accroissement
  left_join(
    Placettes[, c(
      "NumForet", 
      "NumPlac", 
      "Cycle", 
      "Strate", 
      "PoidsPlacette", 
      "Pente", 
      "CoeffPente", 
      "Parcelle", 
      "Station"
    )], 
    by = c("NumForet", "NumPlac", "Cycle")
  ) %>%
  mutate(Qual = as.character(Qual)) %>%
  mutate(
    # NumPlac = as.character(NumPlac), 
    Diam1 = as.numeric(Diam1), 
    Diam2 = as.numeric(Diam2)
  ) %>%
  left_join(
    Echantillonnages[, c(
      "NumForet", 
      "Cycle", 
      "Strate", 
      "Surface", "NbPlac", 
      "DiamLim1", "Rayon1", 
      "DiamLim2", "Rayon2", 
      "DiamLim3", "Rayon3", 
      "Coeff", "DiamLim"
    )], 
    by = c(
      "NumForet" = "NumForet", 
      "Cycle" = "Cycle", 
      "Strate" = "Strate"
    )
  ) %>%
  mutate(Coeff = Coeff * 100) # correction nécessaire car 28 >= 14 * 0.02 * 100 est faux (tests B.Meheux)
# --- 1.3/ Calcul du poids
Arbres_DF <- Arbres %>% 
  prep_df(
    echant_DF, 
    code_qual = Quals, code_essreg = EssReg,
    code_tarif = Tarifs, code_prix = Prix,
    diam_cat = Cats
    ) %>% 
  calculs_Nha()


Test = 0

##### 2/ Essences inventoriées dans la table Arbres #####
cat(
  utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}")
)

Test <- Test + Controle_Essence(Arbres)

v <- unique(Arbres$Essence)

# Tableau listant les essences de l'inventaire (Arbres) présentes (et figurant dans la liste des essences de la feuille Essences).
pos <- which(!v %in% Essences$Nom)

if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
  v_Error <- v[pos]
  v <- v[-pos]
}

# Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
# v <- Essences$Code[match(v, Essences$Nom)]
v <- sort(v)
v <-
  paste0(
    Essences$Code[match(v, Essences$Nom)], " - ", v, " - ", 
    Essences$Latin[match(v, Essences$Nom)]
  )

# ----- Plusieurs cas
# -- length(v) < 60 (correspondrait à 6 colonnes (max) de 10 lignes chacunes)
#  = > respecter un rapport de nrows = 2/3 ncols
nrows <- ceiling(length(v) / 5) # divise par 6 (nombre maximal de colonnes de 2.5cm qui peuvent tenir sur une feuille de 17cm de largeur de texte)

if (nrows < 10) {
  ncols <- ceiling(length(v) / nrows)
  while (nrows < 2 / 3 * ncols) {
    nrows = nrows + 1
    ncols <- ceiling(length(v) / nrows)
  }
} else {
  ncols = 5
}

df <- data.frame(rep(NA, nrows))

count = 0
for (i in 1:ncols) {
  df[, i] <- v[(count + 1):(count + nrows)]
  count = count + nrows
}

# Impression du tableau des essences
print(
  xtable(
    df, 
    caption = "\\footnotesize{Liste des essences rencontrées dans la table}", 
    caption.placement = "bottom", 
    digits = rep(0, ncol(df)+1), 
    align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
    label = "TabEssences"
  ), 
  include.rownames = FALSE, 
  include.colnames = FALSE, 
  hline.after = c(0:nrow(df)), 
  size = "\\scriptsize"
)

##### 3/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

Test <- miss_plot(Arbres, vect = c("NumForet", "NumPlac", "Cycle"))
cat("\\FloatBarrier ")


##### 4/ Présentation succincte des données #####
cat(utf82LaTeX("\\paragraph{Présentation succincte des données}"))

Cycles <- Cycles %>% arrange(Cycle)

# --- 4.1/ Nombre de passages en inventaires :
cat(
  utf82LaTeX(
    "Nombre de passages en inventaires : ", length(Cycles$Cycle), " (", 
    paste0(Cycles$Annee, collapse = " - "), ")\\\\"
  )
)
# --- 4.2/ Nombre d'arbres (IdArbres)
cat(
  utf82LaTeX(
    "Nombre d'arbres identifiés sur l'ensemble des inventaires : ", 
    dim(IdArbres[IdArbres$NumForet == forest_num, ])[1], 
    "\\\\"
  )
)
# --- 4.3/ Nombre d'arbres (ValArbres)
cat(
  utf82LaTeX(
    "Nombre de mesures d'arbres sur l'ensemble des inventaires : ", 
    dim(Arbres[Arbres$NumForet == forest_num, ])[1]
  )
)
# --- 4.4/ Valeurs déclinées par cycle
if (length(Cycles$Cycle) > 0) {
  cat("\\begin{itemize}\n\\setlength\\itemsep{0em}")

  for (cycle in Cycles$Cycle) {
    # cycle <- Cycles$Cycle[1] # debug
    annee <- Cycles$Annee[Cycles$Cycle == cycle]
    cat(
      utf82LaTeX(
        "\\item Inventaire ", cycle, " (", annee, ") :\\\\ \\noindent "
      )
    )
    # - 4.4.1/ Nombre d'arbres au cycle donné
    cat(
      utf82LaTeX(
        "Nombre d'arbres identifiés sur l'inventaire : ", 
        dim(Arbres[Arbres$NumForet == forest_num & Arbres$Cycle == cycle, ])[1], 
        "\\\\"
      )
    )
    # - 4.4.2/ Valeurs d'Azimut
    az_MAX <- max(as.numeric(Arbres$Azimut[Arbres$Cycle == cycle]), na.rm = T)
    if (az_MAX >= 400) {
      if (az_MAX < 800) {
        az_MAX <- paste0("\\textbf{\\textcolor{Blue}{", az_MAX, " -> Placettes miroirs ?}}")
      } else {
        az_MAX <- paste0("\\textbf{\\textcolor{Red}{", az_MAX, "}}")
      }
    }
    az_MIN <- min(as.numeric(Arbres$Azimut[Arbres$Cycle == cycle]), na.rm = T)
    if (az_MIN < 0) {
      az_MIN <- paste0("\\textbf{\\textcolor{Red}{", az_MIN, "}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des azimuts : ", 
        az_MIN, 
        "-", 
        az_MAX, 
        "\\\\"
      )
    )
    # - 4.4.3/ Valeurs de Dist
    dist_MAX <- max(as.numeric(Arbres$Dist[Arbres$Cycle == cycle]), na.rm = T)
    if (dist_MAX >= 40) {
      dist_MAX <- paste0("\\textbf{\\textcolor{Red}{", dist_MAX, "}}")}
    dist_MIN <- min(as.numeric(Arbres$Dist[Arbres$Cycle == cycle]), na.rm = T)
    if (dist_MIN < 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, "}}")}
    if (dist_MIN == 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des distances : ", 
        dist_MIN, 
        "-", 
        dist_MAX, 
        "\\\\"
      )
    )
    # - 4.4.4/ Valeurs de Diam1
    d1_MAX <- max(as.numeric(Arbres$Diam1[Arbres$Cycle == cycle]), na.rm = T)
    if (d1_MAX >= 200) {
      d1_MAX <- paste0("\\textbf{\\textcolor{Red}{", d1_MAX, "}}")
    }
    d1_MIN <- min(as.numeric(Arbres$Diam1[Arbres$Cycle == cycle]), na.rm = T)
    if (d1_MIN < 4) {
      d1_MIN <- paste0("\\textbf{\\textcolor{Red}{", d1_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des Diam1 : ", 
        d1_MIN, 
        "-", 
        d1_MAX, 
        "\\\\"
      )
    )
    # - 4.4.5/ Valeurs de Diam2
    d2_MAX <- max(as.numeric(Arbres$Diam2[Arbres$Cycle == cycle]), na.rm = T)
    if (d2_MAX >= 200) {
      d2_MAX <- paste0("\\textbf{\\textcolor{Red}{", d2_MAX, "}}")
    }
    d2_MIN <- min(as.numeric(Arbres$Diam2[Arbres$Cycle == cycle]), na.rm = T)
    if (d2_MIN < 4) {
      d2_MIN <- paste0("\\textbf{\\textcolor{Red}{", d2_MIN, "  !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des Diam2 : ", 
        d2_MIN, 
        "-", 
        d2_MAX, 
        "\\\\"
      )
    )
    # - 4.4.6/ Description des hauteurs (sélection des valeurs non vides pour le cycle "cycle")
    pos <-
      with(Arbres, which(!is.na(Haut[Cycle == cycle])))

    if (length(pos) > 0) {
      cat(
        utf82LaTeX(
          "Valeurs extrêmes des hauteurs : ", 
          min(
            as.numeric(Arbres$Haut[
              Arbres$Cycle == cycle
              ]), 
            na.rm = T
          ), 
          "-", 
          max(
            as.numeric(Arbres$Haut[
              Arbres$Cycle == cycle
              ]), 
            na.rm = T
          ), 
          "\\\\

          "
        )
      )
    }
    # - 4.4.7/ Qualités inventoriées
    ListQual <-
      with(
        Arbres, 
        sort(unique(Qual[NumForet == forest_num & Cycle == cycle & is.na(Type)]), na.last = T)
      )
    ListQual <- replace_na(ListQual, "\\textbf{\\textcolor{DarkViolet}{NA !!}}")

    cat(
      utf82LaTeX(
        "Qualités inventoriées (sur les arbres vivants) : '", 
        paste0(
          #   sort(unique(Arbres$Qual[
          #     Arbres$NumForet == forest_num & Arbres$Cycle == cycle
          #     ]), 
          #     na.last = T), 
          ListQual, 
          collapse = "', '"
        ), 
        "'\\\\"
      )
    )
  }
  cat("\\end{itemize}\n")
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - Aucune information disponible pour la forêt ", 
      forest_num, " dans la table 'Cycles'\\\\"
    )
  )
}

##### 5/ Notations Ecorce et Pourriture #####
StadeCodes_DF <-
  expand.grid(CodeEcorce$Code, CodeDurete$Code) %>%
  unite(Stade, Var1, Var2, sep = "")
if (length(which(!is.na(Arbres$Stade))) > 0) {
  df <-
    Arbres %>%
    filter(!is.na(Stade) & Stade %in% StadeCodes_DF$Stade)
  if (nrow(df) > 0) {

    df <-
      df %>%
      mutate(
        StadeE = floor(Stade / 10), 
        StadeD = Stade - StadeE * 10
      )
    # --- 5.1/ Codes écorce
    if (length(which(!is.na(df$StadeE))) > 0) {
      # - 5.1.1/ Fréquence
      cat(utf82LaTeX("Fréquence des stades d'écorce :\\\\"))

      df_FreqStadeE <-
        data.frame(
          table(df$StadeE), 
          stringsAsFactors = F
        ) %>%
        rename("Stade écorce" = "Var1", 
                "Occurence" = "Freq")
      print(
        xtable(
          df_FreqStadeE, 
          digits = rep(0, dim(df_FreqStadeE)[2] + 1), 
          align = c(
            "l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeE)[2] - 1)
          )
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:dim(df_FreqStadeE)[1]), 
        size = "\\scriptsize"
      )
      # - 5.1.2/ Contrôle des stades écorce
      cat(utf82LaTeX("\\subsubsection{Contrôle des stades d'écorce}"))

      Test <-
        Controle_Ecorce(
          CodeEcorce, df, Test
        )
      cat("\\FloatBarrier ")
    }
    # --- 5.2/ Codes Dureté
    if (length(which(!is.na(df$StadeD))) > 0) {
      # - 5.2.1/ Fréquence
      cat(utf82LaTeX("\\FloatBarrier Fréquence des stades de décomposition :\\\\"))

      df_FreqStadeD <-
        data.frame(
          table(df$StadeD), 
          stringsAsFactors = F
        ) %>%
        rename(
          "Stade de\ndécomposition" = "Var1", 
          "Occurence" = "Freq"
        )
      print(
        xtable(
          df_FreqStadeD, 
          digits = rep(0, dim(df_FreqStadeD)[2] + 1), 
          align = c(
            "l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeD)[2]-1)
          )
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:dim(df_FreqStadeD)[1]), 
        size = "\\scriptsize"
      )
      # - 5.2.2. Contrôle des stades dureté
      cat("\\subsubsection{Contrôle des stades de décomposition}")

      Test <-
        Controle_Durete(
          CodeDurete, df, Test
        )
      cat("\\FloatBarrier ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Valeurs de la colonne Stade non reconnues\\\\"
      )
    )
  }
}

@
\FloatBarrier

<<Arbres2-Echantillonnage_DiamDist, fig.pos = 'H', fig.height = 4, fig.cap =  "\\footnotesize{Vérification de l'échantillon (\\textbf{pour les arbres repérés azimut/distance du dernier inventaire)}}">>=

##### 1/ Préparation des data.frame #####
# ----- Marquage des arbres limites
ArbresLimite_DF <-
  Arbres_DF %>%
  filter(Limite == 1) %>%
  mutate(
    Type = as.character(Type), 
    Limite = as.factor(Limite)
  )

# Palettes graphiques
Type_PALETTE <- c(21:24)
names(Type_PALETTE) <- c("AV", "A", "C", "S")

Type_PALETTE2 <- c("limegreen", "black", "black", "black")
names(Type_PALETTE2) <- c("AV", "A", "C", "S")

Type_PALETTE3 <- c(0.3, 1, 1, 1)
names(Type_PALETTE3) <- c("AV", "A", "C", "S")

Limite_PALETTE <- c("red", "black")
names(Limite_PALETTE) <- c(1, 0)

ArbresPlot_DF <-
  Arbres_DF %>%
  mutate(
    Type  = 
      ifelse(
        is.na(Type), "AV", Type
      ), 
    Type = factor(Type, levels = names(Type_PALETTE)), 

    Limite  = 
      ifelse(
        is.na(Limite), 0, Limite
      ), 
    Limite = factor(Limite, levels = names(Limite_PALETTE))
  ) %>%
  filter(Cycle == last_cycle)

# Limites entre les inventaires :
cercles_DiamLim <- with(
  Echantillonnages %>% filter(Cycle == last_cycle), 
  c(DiamLim1, DiamLim2, DiamLim3, DiamLim)
)
cercles_DiamLim <- cercles_DiamLim[ which(!is.na(cercles_DiamLim)) ]
cercles_Rayon <- with(
  Echantillonnages %>% filter(Cycle == last_cycle), 
  c(Rayon1, Rayon2, Rayon3)
)
cercles_Rayon <- cercles_Rayon[ which(!is.na(cercles_Rayon)) ]

##### 2/ Graphiques #####
p1 <-
  ArbresPlot_DF %>%
  ggplot() +
  geom_point(
    mapping  = 
      aes(
        Dist, Diam1, 
        shape = Type, 
        fill = Type, 
        colour = Limite, 
        alpha = Type
      )
  ) +
  scale_shape_manual(
    values = Type_PALETTE, 
    label = c(
      "Arbres vivants", "Bois mort sur pied (arbre)", 
      "Bois mort sur pied (chandelle)", "Bois mort sur pied (souche)")
  ) +
  scale_fill_manual(
    values = Type_PALETTE2, 
    label = c(
      "Arbres vivants", "Bois mort sur pied (arbre)", 
      "Bois mort sur pied (chandelle)", "Bois mort sur pied (souche)"
    )
  ) +
  scale_alpha_manual(
    values = Type_PALETTE3, 
    label = c(
      "Arbres vivants", "Bois mort sur pied (arbre)", 
      "Bois mort sur pied (chandelle)", "Bois mort sur pied (souche)"
    )
  ) +
  scale_colour_manual(
    values = Limite_PALETTE, 
    label = c("Arbre limite", "Arbre de l'inventaire")
  ) +

  geom_hline(
    yintercept = as.numeric(cercles_DiamLim), colour = "dodgerblue3", linetype = 2, size = 0.5
  ) +
  geom_abline(
    intercept = 0, slope = Angle, colour = "dodgerblue3", linetype = 2
  ) +
  geom_vline(
    xintercept = as.numeric(cercles_Rayon), colour = "dodgerblue3", linetype = 2, size = 0.5
  ) +
  scale_x_continuous(
    expand = c(0, 0), 
    limits = c(0, max(ArbresPlot_DF$Dist, na.rm = T) * 1.1), 
    breaks = seq(0, 
                 floor(max(ArbresPlot_DF$Dist, na.rm = T) / 5 + 0.5) * 5 * 1.3, 
                 5)
  ) +
  scale_y_continuous(
    expand = c(0, 0), 
    limits = c(0, max(ArbresPlot_DF$Diam1, na.rm = T) * 1.1), 
    breaks = seq(0, 
                 floor(max(ArbresPlot_DF$Diam1, na.rm = T) / 5 + 0.5) * 5 * 1.3, 
                 10)
  ) +
  guides(
    shape = guide_legend(order = 1), 
    fill = guide_legend(order = 1), 
    alpha = guide_legend(order = 1), 
    colour = guide_legend(
      order = 2, 
      override.aes = list(shape = 1, size = 1.75, alpha = 0.5)
    )
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 8), 
    axis.title.x = element_text(size = 9), 
    axis.title.y = element_text(size = 9), 
    axis.text.y = element_text(size = 8), 
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
  )

p1
@
\FloatBarrier


<<Arbres3-Arbres_vivants, results = 'asis'>>=

##### 3/ Contrôle des écarts de diamètre #####
cat("\\subsubsection{Contrôle des écarts Diam1 - Diam2 (par défaut on détecte les écarts > 10 cm)}\n")

# -- issues table
issues_table <-
 Arbres %>%
 select(
  NumForet, NumPlac, NumArbre, Cycle, Essence, Azimut, Dist, 
  Diam1, Diam2
 ) %>%
 mutate(
  difference = abs(Diam1 - Diam2)
 ) %>%
 filter(difference > 10)


# -- print issues
error_msg <- 
  "Ecart(s) entre les diamètres 1 et 2 (|Diam1 - Diam2|) supérieur(s) à 10 cm détecté(s) : "
validation_msg <- 
  "Aucun écart entre les diamètres 1 et 2 (|Diam1 - Diam2|) supérieur à 10 cm détecté"
issues_table_label <- "Arbres_gap_btw_diam1_diam2"
issues_table_title <- 
  "Arbre(s) présentant un écart entre Diam1 et Diam2 supérieur à 10 cm"
# call print_issues
test <- print_issues(
  issues_table = issues_table, 
  error_msg = error_msg,
  validation_msg = validation_msg,
  issues_table_label = issues_table_label,
  issues_table_title = issues_table_title,
  nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
  test = test,
  test_level = 1 # 1 ou 2
)

# -- impression des erreurs au format excel si trop de lignes
write_issues_in_xlsx(
  issues_table = issues_table, 
  issues_msg = error_msg,
  nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
  forest_num = forest_num,
  file_name = "gap_btw_diam1_diam2"
)

if (last_cycle > 1) {
  ##### 3/ Contrôle de la continuité de la combinaison Essence+Azimut+Dist #####
  cat("\\subsubsection{Contrôle de la continuité des valeurs d'Essence, d'Azimut et de Dist des éléments de la table 'Arbres' au cours des différents inventaires.}\n")
  # -- issues table
  issues_table <- check_tree_id(Arbres)
  
  # -- print issues
  error_msg <- 
    "Arbre(s) avec les valeurs d'Essence, Azimut et/ou Dist variant entre les différents inventaires détecté : "
  validation_msg <- 
    "Aucun arbre avec les valeurs d'Essence, Azimut et/ou Dist variant entre les différents inventaires détecté"
  issues_table_label <- "Arbres_moving_trees"
  issues_table_title <- 
    "Arbre(s) présentant des valeurs d'Essence, Azimut et Dist incohérents entre les inventaires"
  # call print_issues
  test <- print_issues(
    issues_table = issues_table, 
    error_msg = error_msg,
    validation_msg = validation_msg,
    issues_table_label = issues_table_label,
    issues_table_title = issues_table_title,
    nrow_max = 10, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    test = test,
    test_level = 2 # 1 (remarque) ou 2 (erreur)
  )
  
  # -- impression des erreurs au format excel si trop de lignes
  write_issues_in_xlsx(
    issues_table = issues_table, 
    issues_msg = error_msg,
    nrow_max = 10, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    forest_num = forest_num,
    file_name = "moving_trees"
  )
}

##### XXXXXX/ Contrôle des doublons sur les identifiants d'arbre (Azimut+Dist) #####
cat("\\subsubsection{Contrôle des doublons sur les valeurs d'Azimut et de Dist (position des arbres) : pour une placette donnée, la combinaison 'Azimut' et 'Dist' ne peut correspondre qu'à 1 seul arbre}\n")

# -- issues table
# variables indispensables - NumForet+NumPlac+Azimut+Dist
vars_to_check <- c("NumForet", "NumPlac", "Cycle", "Azimut", "Dist")
test_level = 2

# save test in duplicated_trees (re-used below)
duplicated_rows_checked <- check_duplicated_rows(
  table = Arbres, 
  vars_to_check = vars_to_check,
  test_level = test_level,
  test = test,
  columns_to_print = c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1", "Diam2", "Qual"
  ),
  return_issues_table = T
)
test <- duplicated_rows_checked$test
issues_table <- duplicated_rows_checked$issues_table
error_msg <- duplicated_rows_checked$error_msg

# -- impression des erreurs au format excel si trop de lignes
write_issues_in_xlsx(
  issues_table = issues_table, 
  issues_msg = error_msg,
  nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
  forest_num = forest_num,
  file_name = "duplicated_trees"
)

if (last_cycle > 1) {
  ##### 3/ Contrôle des notations de la colonne 'Coupe' #####
  cat("\\subsubsection{Contrôle des notations de la colonne 'Coupe' (arbre sur pied, coupé ou exploité)}\n")
  # -- issues table
  issues_table <- check_cut_trees(
    table = Arbres %>% 
      # filtre des arbres repérés Azimut + Dist
      filter(! (is.na(NumArbre) | is.na(Azimut) | is.na(Dist)) ), 
    last_cycle = last_cycle
  ) %>% 
    select(-Type, -Stade, -Observations)
  
  # -- print issues
  error_msg <- 
    "Incohérence(s) détectée(s) dans la colonne 'Coupe' (arbres disparus sans suivi de coupe/chablis / arbres notés coupés puis revenus dans l'inventaire) : "
  validation_msg <- 
    "Aucune incohérence détectée dans la colonne 'Coupe' (arbres disparus sans suivi de coupe/chablis / arbres notés coupés puis revenus dans l'inventaire)"
  issues_table_label <- "cut_record_mistake"
  issues_table_title <- "Incohérences sur les notations de la colonne 'Coupe'"
  
  test <- print_issues(
    issues_table = issues_table, 
    error_msg = error_msg,
    validation_msg = validation_msg,
    issues_table_label = issues_table_label,
    issues_table_title = issues_table_title,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    test = test,
    test_level = 2 # 1 (remarque) ou 2 (erreur)
  )
  
  # -- impression des erreurs au format excel si trop de lignes
  write_issues_in_xlsx(
    issues_table = issues_table, 
    issues_msg = error_msg,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    forest_num = forest_num,
    file_name = "missing_cut_trees"
  )
  
  
  ##### 4/ Contrôle des accroissements en diamètre #####
  cat("\\subsubsection{Contrôle des valeurs d'accroissement en diamètre (valeurs d'accroissement en diamètre négatives pour les bois vivants, positives pour les bois morts sur pied)}\n")
  
  # # Mise en colonne des valeurs Essence, Azimut, Dist
  # if (nrow(duplicated_rows_checked$issues_table) > 0 & Contrôle cycle) {
  #  cat("\\textcolor{DarkViolet}{\\textbf{Attention}} - Contrôle des accroissements des arbres morts sur pied impossible s'il existe des doublons sur l'association NumForet-NumPlac-NumArbre de la table Arbres (identifiant)\\\\")
  
  # -- issues table
  issues_table <-
    Arbres %>% 
    # remove arbres non repérés Azimut+Dist
    filter(!is.na(Azimut) & !is.na(Dist)) %>%
    arrange(NumPlac, NumArbre, Cycle) %>%
    group_by(NumForet, NumPlac, NumArbre) %>% 
    mutate(
      error_diam_inc = case_when(
        # arbres vivants
        is.na(Type) & is.na(lag(Type)) & lag(Diam1) > Diam1 ~ 1,
        is.na(Type) & is.na(lag(Type)) & lag(Diam2) > Diam2 ~ 1,
        is.na(Type) & is.na(lead(Type)) & Diam1 > lead(Diam1) ~ 1,
        is.na(Type) & is.na(lead(Type)) & Diam2 > lead(Diam2) ~ 1,
        
        # arbres morts
        !is.na(lag(Type)) & !is.na(Type) & lag(Diam1) < Diam1 ~ 1,
        !is.na(lag(Type)) & !is.na(Type) & lag(Diam2) < Diam2 ~ 1,
        !is.na(Type) & Diam1 < lead(Diam1) ~ 1,
        !is.na(Type) & Diam2 < lead(Diam2) ~ 1,
        
        TRUE ~ 0
      )
    ) %>%
    ungroup() %>%
    filter(error_diam_inc == 1) %>%
    select(NumPlac, NumArbre, Cycle, Essence, Azimut, Dist, Diam1, Diam2, Type)
  
  # -- print issues
  error_msg <- "Incohérence(s) sur les valeurs d'accroissement en diamètre détecté(s) - il y a des valeurs négatives pour des bois vivants et/ou des valeurs positives pour des bois morts sur pied : "
  validation_msg <- "Aucune incohérence sur les valeurs d'accroissement en diamètre détectée"
  issues_table_label <- "error_diam_inc"
  issues_table_title <- "Incohérences sur les valeurs d'accroissement en diamètre"
  # call print_issues
  test <- print_issues(
    issues_table = issues_table, 
    error_msg = error_msg,
    validation_msg = validation_msg,
    issues_table_label = issues_table_label,
    issues_table_title = issues_table_title,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel,
    test = test,
    test_level = 2
  )
  
  # -- impression des erreurs au format excel si trop de lignes
  write_issues_in_xlsx(
    issues_table = issues_table, 
    issues_msg = error_msg,
    nrow_max = nrow_max_default, # nombre d'éléments seuil pour proposer d'écrire les erreurs rapportées dans un classeur excel
    forest_num = forest_num,
    file_name = "error_diam_inc"
  )
}
  
  ##### -- distinction des populations BMP et Arbres #####
 # BMP
 BMP <- Arbres %>% filter(!is.na(Type))
 # Précomptables
 Arbres <- Arbres %>% filter(is.na(Type))

 # distinction des précomptables et perches (plus vraiment les perches mais la population inventoriée sur le cercle de 10 m et < 17,5m - en fait cela devrait être la population inventoriée sur le cercle et 17,5 devait être paramétrable)
 # Arbres <- Arbres %>% filter(Diam >= 17.5)
 # Perches <- Arbres %>% filter(Diam < 17.5) # Diam >= 7.5 écarté volontairement pour voir les erreurs dans le jeux de données



##### 5/ Contrôle des qualités des arbres #####
# pos <- which(!is.na(Arbres_DF$Qual))
# 
# if (length(pos) > 0) {
 cat("\\subsubsection{Contrôle des qualités}\n")

test <- check_qual(
  table = Arbres,
  qual_table = Quals, 
  column = "Nom", 
  test = test
)
Test <- test
@

<<Arbres4-Bois_morts_sur_pied, results = 'asis'>>=
# Eval_BMP_Arbres
cat(
  utf82LaTeX(
    "\\subsubsection{Contrôle incohérences sur les données de Bois Mort sur Pied}"
  )
)
# Présence de BMP dans la table Arbres
# pos <- which(!is.na(Arbres$Type))

if (nrow(BMP) > 0) {
  ##### 1/ Contrôle des types de bois mort sur pied #####
  cat(utf82LaTeX("\\paragraph{BMP : Contrôle des types de bois mort sur pied}"))

  # pos <- which(!is.na(Arbres$Type) & !Arbres$Type %in% CodeTypoArbres$Code)
  pos <-
    with(BMP, which(!Type %in% CodeTypoArbres$Code))

  if (length(pos) > 0) {
    Test <- ifelse(Test > 1, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des types de bois mort sur pied non reconnus\\\\
        Rappel : les seuls types reconnus sont '", 
        paste0( CodeTypoArbres$Code, collapse = "', '"), 
        "' (respectivement '", 
        paste0(CodeTypoArbres$Descriptif, collapse = "', '"), 
        "').\\\\", length(pos), " valeur(s) non reconnue(s)"
      )
    )
    if (length(pos) < 5) cat(" : '", BMP$Type[pos], "'\\\\") else cat("\\\\")

  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les types de bois mort sur pied sont reconnus.\\\\"
      )
    )
  }

  ##### 2/ Contrôle du respect des hauteurs #####
  # --- 2.1/ Hauteur des souches
  cat(utf82LaTeX("\\paragraph{BMP : Souches > 1, 30m}"))

  pos <- which(BMP$Haut > 1.30 & BMP$Type == "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant strictement plus d'1, 30m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        BMP[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en souche et faisant plus d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = c(rep(0, ncol(df) - 1), 1, 0), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-1"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans cette table : ", 
          length(pos), 
          " erreurs détectées\\\\"
        )
      )
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de plus d'1, 30m classé en 'Souche' dans la table\\\\"
      )
    )
  }

  # --- 2.2/ Hauteur des chandelles des chandelles et des arbres
  cat(utf82LaTeX("\\paragraph{BMP : Arbres ou chandelles < 1, 30m}"))

  pos <- which(BMP$Haut < 1.30 & BMP$Type != "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        BMP[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-2"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : ", 
          length(pos), " erreurs détectées\\\\"
        )
      )

      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de moins d'1, 30m classé en 'Arbre' ou en 'Chandelle' dans la table\\\\"
      )
    )
  }

  ##### 3/ Incohérences sur les données Type - Haut - StadeD - StadeE des BMP #####
  cat(
    utf82LaTeX(
      "\\paragraph[Incohérences entre les colonnes Type - Haut - Stade]{Incohérences entre les colonnes Type - Haut - Stade\\footnote{\\textit{\\underline{Rqe :} on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici\\\\
      \\indent \\underline{Attention :} il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas}}}"
    )
  )

  # cat(
  #   utf82LaTeX(
  #     "\\textit{Rqe : on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici}\\\\
  #     \\textit{Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}\\\\\\\\"
  #   )
  # )
  ListDisp_Verif <- c()
  pos_BM <-
    with(BMP, which(!is.na(Type) | !is.na(Haut) | !is.na(Stade)))

  BMP_Temp <- BMP[pos_BM, ]

  pos <- c()
  for (name in c("Type", "Haut", "Stade")) {
    if (name == "Haut") {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name]) & BMP_Temp$Type != 1
          )
        ))

    } else {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name])
          )
        ))

    }
  }

  if (length(pos) > 0) {
    Test = ifelse(Test >= 1, Test, 1)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{Blue}{\\textbf{Remarque}} - Il peut y avoir des informations manquantes pour les BMP : \\\\"
        )
      )

      df <-
        BMP_Temp[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Diam2", 
          "Type", "Haut", "Stade"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP pour lesquels il peut manquer des informations}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df) - 1)), 
          label = "TabMissBMP"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{blue}{\\textbf{Remarque}} - Il peut y avoir des informations manquantes pour les BMP : ", length(pos), " manques détectés\\\\"
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence entre les colonnes Type - Haut - Stade pour les BMP\\\\"
      )
    )
  }

  ##### 4/ Contrôle suivi des arbres morts entre les différents inventaires #####
  # --- Contrôle de IdArbre
  if (last_cycle > 1) {

    # --- 4.2/ Contrôle AcctD
    cat(utf82LaTeX("\\paragraph{Contrôle des valeurs d'accroissement en diamètre (valeurs d'accroissement en diamètre positives)}"))

    # Mise en colonne des valeurs Essence, Azimut, Dist
    if (length(Dupl) > 0) {
      cat(
        utf82LaTeX(
          "\\textcolor{DarkViolet}{\\textbf{Attention}} - Contrôle des accroissements des arbres morts sur pied impossible s'il existe des doublons sur l'association NumForet-NumPlac-NumArbre de la table Arbres (identifiant)\\\\"
        )
      )

    } else {
      t <-
        Arbres_DF %>%
        select(
          NumForet, NumPlac, NumArbre, Cycle, Essence, Azimut, Dist
        ) %>%
        melt(
          id = c("NumForet", "NumPlac", "NumArbre", "Cycle")
        ) %>%
        dcast(
          NumForet + NumPlac + NumArbre + variable ~ Cycle
        ) %>%
        arrange(NumForet, NumPlac, NumArbre, variable)

      # - 4.2.1/ Contrôle si AcctD < 0
      # Mise en colonne des valeurs Essence, Azimut, Dist
      t <-
        Arbres_DF %>%
        select(
          NumForet, NumPlac, NumArbre, Cycle, Diam1, Diam2, Type
        ) %>%
        filter(!is.na(Type)) %>% # Sélection des arbres morts
        melt(
          id = c("NumForet", "NumPlac", "NumArbre", "Cycle", "Type")
        ) %>%
        dcast(
          NumForet + NumPlac + NumArbre + variable ~ Cycle
        ) %>%
        arrange(NumForet, NumPlac, NumArbre, variable)

      # Note : on distingue quand il y a 2 cycles et 1 seul
      if (last_cycle > 2) { # Cas où un arbre présent au cycle 1, disparaît au cycle 2 et réapparaît au cycle3
        # --- Distingue 1 sous-ensemble : BMP doivent avoir été présent au passage précédent :
        pos_Error <- c()
        df_temp <- t

        for (i in 6:(dim(t)[2])) { # toutes les valeurs doivent être décroissantes au cours du temps
          pos_Error <- c(pos_Error, which(df_temp[, i] > df_temp[, i - 1]))
        }
        pos_Error <- unique(pos_Error)
        df_Error <- df_temp[pos_Error, ]
      } else { # Cas où on n'a que 2 cycles
        pos_Error <-
          which(!is.na(t[, 5]) & !is.na(t[, 6]) & t[, 5] < t[, 6])
        pos_Error <- unique(pos_Error)
        df_Error <- t[pos_Error, ]
      }

      # Affichage des erreurs
      if (dim(df_Error)[1] > 0) {
        Test = ifelse(Test > 1, Test, 1)

        cat(
          utf82LaTeX(
            "\\textcolor{DarkViolet}{\\textbf{Attention}} - Accroissement(s) sur le diamètre positif(s) constaté(s) sur la population d'arbres morts sur pied entre les différents inventaires : \\\\"
          )
        )

        List_Error <-
          df_Error %>%
          select(NumForet, NumPlac, NumArbre) %>%
          distinct() %>%
          group_by(NumForet, NumPlac) %>%
          summarise(NbError = length(NumArbre)) %>%
          ungroup() %>%
          mutate(
            Label = paste0("Plac ", NumPlac, " : ", NbError, " erreur(s)"), 
            NumForet = NULL, 
            NumPlac = NULL, 
            NbError = NULL
          ) %>%
          unlist() %>%
          unname()

        Vector2Table_Print(
          List_Error, 
          "Liste des placettes présentant des Diam1 ou Diam2 d'arbres morts sur pied augmentant au cours des inventaires", 
          "TabIncoherence_AcctD"
        )
      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun accroissement sur le diamètre positif (Diam1 ou Diam2) constaté sur la population d'arbres morts sur pied entre les différents inventaires\\\\"
          )
        )
      }
    }
  }

  ##### 5/ Détection des arbres morts sur pied redevenus "vivants" #####
  if (last_cycle > 1) {
    cat(utf82LaTeX("\\paragraph{Détection des arbres morts sur pied 'redevenus vivants'}"))
    df <-
      BMP %>%
      select(NumForet, NumPlac, NumArbre, Cycle, Essence, Azimut, Dist, Diam1, Type) %>%
      filter(!is.na(NumArbre)) %>% 
      arrange(NumForet, NumPlac, NumArbre, Cycle) %>%
      group_by(NumForet, NumPlac, NumArbre) %>%
      mutate(TestBMP = ifelse(!is.na(lag(Type)) & is.na(Type), 1, 0)) %>%
      ungroup() %>%
      filter(TestBMP == 1) %>%
      select(NumPlac, NumArbre)

    if (nrow(df) > 0) {
      if (nrow(df) <= 30) {
        df <- df %>% rename("Placette (NumPlac)" = "NumPlac")

        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Certains arbres ayant été inventoriés comme arbres morts sur pied sont redevenus des arbres vivants. Impossible dans cette table : ", 
            nrow(df), 
            " erreurs détectées\\\\"
          )
        )
        cat("\\FloatBarrier
        ")

        print(
          xtable(
            df, 
            caption = "\\footnotesize{Incohérences - Liste des arbres morts sur pied 'redevenus vivants'}", 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c("l", "|M{2.5cm}|", "M{2.5cm}|"), 
            label = "Tab_BMP2Alive"
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")
      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Certains arbres morts sur pied ont été inventoriés comme arbres vivants ('redevenus' vivants). Impossible dans cette table : ", 
            nrow(df), 
            " erreurs détectées\\\\"
          )
        )
        cat("\\FloatBarrier
        ")
      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence détectée (BMP redevenu vivant) dans la table 'Arbres'\\\\"
        )
      )
    }
  }
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun bois mort sur pied renseigné dans la table 'Arbres'\\\\"
    )
  )
}
@

<<Arbres5-Valeurs_vides, results = 'asis'>>=

##### 1/ Contrôle des valeurs vides #####
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

# --- 1.1/ Contrôle présence de Diam2 pour les arbres de Diam1 > 30
cat(utf82LaTeX("\\paragraph{Diam1 > 30cm et Diam2 vide}"))

pos <- which(Arbres$Diam1 > 30 & is.na(Arbres$Diam2) & is.na(Arbres$Type))

if (length(pos) > 0) {
  Test = ifelse(Test >= 2, Test, 2)

  if (length(pos) <= 20) {
    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des Diam2 vides pour des arbres vivants de Diam1 > 30 cm : \\\\"
      )
    )

    df <-
      Arbres[pos, c(
        "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Diam2", "Type"
      )]

    print(
      xtable(
        df, 
        caption = "\\footnotesize{Liste des arbres de Diam1 > 30cm avec Diam2 manquant}", 
        caption.placement = "bottom", 
        digits = rep(0, ncol(df) + 1), 
        align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
        label = "TabMissDiam2"
      ), 
      include.rownames = FALSE, 
      include.colnames = TRUE, 
      hline.after = c(-1:nrow(df)), 
      size = "\\scriptsize"
    )

  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des Diam2 vides pour des arbres vivants de Diam1 > 30 cm : ", length(pos), " erreurs détectées\\\\"
      )
    )

    cat("\\FloatBarrier
        ")
  }
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Les Diam2 sont correctement renseignés\\\\"
    )
  )
}

##### 2/ Autres variables - repérages des vides #####
cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))

# --- 2.1/ Variables "vitales"
# - 2.1.1/ Arbres < 17.5 cm
cat(
    "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item Arbres < 17.5 cm\n\\end{itemize}"
)
Arbres_PER <-
  Arbres %>%
  filter((Diam1 + Diam2) / 2 < 17.5)

Vital <- c()
for (
  name in c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1"
  )
) {
  pos <- which(is.na(Arbres_PER[, name]))

  if (length(pos) > 0) {
    Vital <- c(Vital, name)
  }
}

if (length(Vital) > 0) {
  Test = ifelse(Test >= 2, Test, 2)

  cat(
    utf82LaTeX(
      "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
      paste0(Vital, collapse = ", "), "\\\\"
    )
  )

  df <-
    Arbres_PER %>%
    gather(var, value, Vital) %>%
    mutate(var = paste0(var, ".NbreVides")) %>%
    group_by(NumForet, var) %>%
    summarise(value = length( which(is.na(value)) )) %>%
    ungroup() %>%
    spread(var, value, drop = F)
  # df <-
  #   summaryBy(
  #     list(Vital, "NumForet"), 
  #     data = Arbres_PER, 
  #     FUN = function(x) length(which(is.na(x))), 
  #     fun.names = "NbreVides"
  #   )

  if (length(Vital) == 1) {
    df <-
      df[
        which(
          df[, paste0(Vital, ".NbreVides")] != 0
        ), ]

  } else {
    df <-
      df[
        rowSums(
          df[, paste0(Vital, ".NbreVides")]) != 0
       , ]

  }

  if (!is.element("NumForet", Vital)) {
    df <- df %>% select(-NumForet)

  }
  names(df)[
    names(df) %in% paste0(Vital, ".NbreVides")
    ] <-
    paste0(Vital, " : nombre de vides")

  print(
    xtable(
      df, 
      caption = utf82LaTeX(
        paste0(
          "\\footnotesize{Vides constatés dans les variables ", 
          paste0(Vital, collapse = ", "), 
          ", indispensables à l'analyse des données}"
        )
      ), 
      caption.placement = "bottom", 
      digits = rep(0, ncol(df) + 1), 
      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
      label = "TabMissVital_Arbres51"
    ), 
    include.rownames = FALSE, 
    include.colnames = TRUE, 
    hline.after = c(-1:nrow(df)), 
    size = "\\scriptsize"
  )
  cat("\\FloatBarrier
          ")

} else {
  Vital <- c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1"
  )

  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données des arbres de Diam1 < 17.5 cm (", 
      paste0(Vital, collapse = ", "), ")\\\\"
    )
  )
}

# - 2.1.2/ Arbres ≥ 17.5 cm
cat(
  "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item Arbres $\\geqslant$ 17.5 cm\n\\end{itemize}"
)
Arbres_PREC <-
  Arbres %>%
  filter(Diam1 >= 17.5)

Vital <- c()
for (
  name in c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1"
  )
) {
  pos <- which(is.na(Arbres_PREC[, name]))

  if (length(pos) > 0) {
    Vital <- c(Vital, name)
  }
}

if (length(Vital) > 0) {
  Test = ifelse(Test >= 2, Test, 2)

  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
      paste0(Vital, collapse = ", "), "\\\\"
    )
  )

  df <-
    Arbres_PREC %>%
    gather(var, value, Vital) %>%
    mutate(var = paste0(var, ".NbreVides")) %>%
    group_by(NumForet, var) %>%
    summarise(value = length( which(is.na(value)) )) %>%
    ungroup() %>%
    spread(var, value, drop = F)
  # df <-
  #   summaryBy(
  #     list(Vital, "NumForet"), 
  #     data = Arbres_PREC, 
  #     FUN = function(x) length(which(is.na(x))), 
  #     fun.names = "NbreVides"
  #   )

  if (length(Vital) == 1) {
    df <-
      df[
        which(
          df[, paste0(Vital, ".NbreVides")] != 0
        ), ]

  } else {
    df <-
      df[
        rowSums(
          df[, paste0(Vital, ".NbreVides")]) != 0
       , ]

  }

  if (!is.element("NumForet", Vital)) {
    df <- df %>% select(-NumForet)

  }
  names(df)[
    names(df) %in% paste0(Vital, ".NbreVides")
    ] <-
    paste0(Vital, " : nombre de vides")

  print(
    xtable(
      df, 
      caption = utf82LaTeX(
        paste0(
          "\\footnotesize{Vides constatés dans les variables ", 
          paste0(Vital, collapse = ", "), 
          ", indispensables à l'analyse des données}"
        )
      ), 
      caption.placement = "bottom", 
      digits = rep(0, ncol(df) + 1), 
      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
      label = "TabMissVital_Arbres52"
    ), 
    include.rownames = FALSE, 
    include.colnames = TRUE, 
    hline.after = c(-1:nrow(df)), 
    size = "\\scriptsize"
  )
  cat("\\FloatBarrier
          ")

} else {
  Vital <- c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1"
  )

  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données des arbres de Diam1 $\\geqslant$ 17.5 cm (", 
      paste0(Vital, collapse = ", "), ")\\\\"
    )
  )
}

# - 2.1.2/ Arbres sans Diam1
Arbres_NA <-
  Arbres %>%
  filter(is.na(Diam1))

if (dim(Arbres_NA)[1] > 0) {
  Test = ifelse(Test >= 2, Test, 2)
cat(
  "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item Arbres avec Diam1 vide\n\\end{itemize}"
)

Vital <- c()
for (
  name in c(
    "NumForet", "NumPlac", "NumArbre", "Cycle", 
    "Essence", "Azimut", "Dist", "Diam1"
  )
) {
  pos <- which(is.na(Arbres_NA[, name]))

  if (length(pos) > 0) {
    Vital <- c(Vital, name)
  }
}


  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
      paste0(Vital, collapse = ", "), "\\\\"
    )
  )

  df <-
    Arbres_NA %>%
    gather(var, value, Vital) %>%
    mutate(var = paste0(var, ".NbreVides")) %>%
    group_by(NumForet, var) %>%
    summarise(value = length( which(is.na(value)) )) %>%
    ungroup() %>%
    spread(var, value, drop = F)
  # df <-
  #   summaryBy(
  #     list(Vital, "NumForet"), 
  #     data = Arbres_NA, 
  #     FUN = function(x) length(which(is.na(x))), 
  #     fun.names = "NbreVides"
  #   )

  if (length(Vital) == 1) {
    df <-
      df[
        which(
          df[, paste0(Vital, ".NbreVides")] != 0
        ), ]

  } else {
    df <-
      df[
        rowSums(
          df[, paste0(Vital, ".NbreVides")]) != 0
       , ]

  }

  if (!is.element("NumForet", Vital)) {
    df <- df %>% select(-NumForet)

  }
  names(df)[
    names(df) %in% paste0(Vital, ".NbreVides")
    ] <-
    paste0(Vital, " : nombre de vides")

  print(
    xtable(
      df, 
      caption = utf82LaTeX(
        paste0(
          "\\footnotesize{Vides constatés dans les variables ", 
          paste0(Vital, collapse = ", "), 
          ", indispensables à l'analyse des données}"
        )
      ), 
      caption.placement = "bottom", 
      digits = rep(0, ncol(df) + 1), 
      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
      label = "TabMissVital_Arbres53"
    ), 
    include.rownames = FALSE, 
    include.colnames = TRUE, 
    hline.after = c(-1:nrow(df)), 
    size = "\\scriptsize"
  )
  cat("\\FloatBarrier
          ")
}

@

<<Arbres6-Codes_ecologiques, results = 'asis'>>=

# ---------- Contrôle des codes écologiques : ---------- #
pos <- which(!is.na(Arbres$CodeEcolo))

if (length(pos) > 0) {
  cat(utf82LaTeX("\\subsubsection{Contrôle des codes écologiques inventoriés}"))

  ##### 1/ Vides dans les références de codifications de DMH #####
  cat(utf82LaTeX("\\paragraph{Références aux codifications de DMH}"))

  pos <- which(!is.na(Arbres$CodeEcolo) & is.na(Arbres$Ref_CodeEcolo))

  if (length(pos) > 0) {
    Test = ifelse(Test > 1, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des arbres portant des DMH sans référence de codification renseignée (Ref_CodeEcolo vide pour CodeEcolo non vide) : \\\\"
        )
      )

      df <-
        Arbres[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", 
          "Diam1", "CodeEcolo", "Ref_CodeEcolo"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des arbres porteurs de DMH sans référence de codification renseignée}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissRef_CodeEco"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des arbres portant des DMH sans référence de codification renseignée (Ref_CodeEcolo vide pour CodeEcolo non vide) : ", 
          length(pos), " manques détectés\\\\"
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les arbres porteurs de DMH ont une référence à la codification utilisée\\\\"
      )
    )
  }

  # Affichage de la liste des référence utilisées
  cat(utf82LaTeX("Références utilisées :"))

  df_RefDMH <-
    Arbres %>%
    filter(!is.na(CodeEcolo)) %>%
    group_by(
      NumForet, Cycle, Ref_CodeEcolo
    ) %>%
    summarise(
      Occurence = length(Ref_CodeEcolo)
    ) %>%
    ungroup() %>%
    select(Cycle, Ref_CodeEcolo, Occurence) %>%
    rename("Référence" = "Ref_CodeEcolo") %>%
    data.frame()

  print(
    xtable(
      df_RefDMH, 
      digits = rep(0, dim(df_RefDMH)[2] + 1), 
      align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(df_RefDMH)[2] - 1)), 
      label = "Tab_RefDMH"
    ), 
    include.rownames = FALSE, 
    include.colnames = TRUE, 
    hline.after = c(-1:dim(df_RefDMH)[1]), 
    size = "\\scriptsize"
  )

  ##### 2/ Reconnaissance des codes DMH #####
  cat(utf82LaTeX("\\paragraph{Reconnaissance des codes DMH}"))

  df_Codes <- filter(Arbres, !is.na(Ref_CodeEcolo))

  # if (dim(df_Codes)[1] > 0) {
  posProSilva <-
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) == "prosilva" &
        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo
        )
    )
  posAFI <-
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) == "engref" &
        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo)
    )
  posAFI <- c(
    posAFI, 
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) == "afi" &
        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo)
    )
  )
  posEFI <-
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) == "efi" &
        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo)
    )
  posIRSTEA <-
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) == "irstea" &
        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo)
    )
  posUnknown <-
    which(
      tolower(
        df_Codes$Ref_CodeEcolo) != "irstea" &

        tolower(df_Codes$Ref_CodeEcolo) != "afi" &
        tolower(df_Codes$Ref_CodeEcolo) != "engref" &
        tolower(df_Codes$Ref_CodeEcolo) != "efi" &
        tolower(df_Codes$Ref_CodeEcolo) != "prosilva" &

        !is.na(df_Codes$NumForet) & !is.na(df_Codes$NumPlac) &
        !is.na(df_Codes$NumArbre) & !is.na(df_Codes$CodeEcolo)
    )
  # --- 2.1/ Codification ProSilva
  if (length(posProSilva) > 0) {
    temp <- df_Codes[posProSilva, ]
    List <- temp$CodeEcolo
    List <- str_split(List, boundary("word"))
    pos <- c()
    for (i in 1:(dim(temp)[1])) {
      test <- all(List[[i]] %in% CodeEcolos$Code)
      if (!test) {
        pos <- c(pos, i)
      }
    }
    df_Error_ProSilva <- temp[pos, ]

    # Affichage
    cat(utf82LaTeX("\\emph{Codes DMH ProSilva}\\\\"))

    if (dim(df_Error_ProSilva)[1] > 0) {
      Test = ifelse(Test > 1, Test, 2)

      if (dim(df_Error_ProSilva)[1] <= 20) {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés ProSilva qui ne sont pas reconnus : \\\\"
          )
        )
        df <-
          df_Error_ProSilva[, c(
            "NumForet", "NumPlac", "NumArbre", "Cycle", 
            "CodeEcolo", "Ref_CodeEcolo"
          )]
        # t
        print(
          xtable(
            df, 
            caption = "\\footnotesize{Codes DMH ProSilva non reconnus dans la table 'BMSCercle'.}", 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c(
              "l", rep("|M{1.5cm}", ncol(df) - 2), "|M{2.5cm}", "|M{1.5cm}|"
            ), 
            label = "TabDMHProSilva_BMSCercles"
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")

      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés ProSilva qui ne sont pas reconnus : ", 
            dim(df_Error_ProSilva)[1], " codes DMH non reconnus.\\\\ exemple : ", 
            paste0(head(unique(df_Error_ProSilva$CodeEcolo, 3)), collapse = ", "), 
            "\\\\"
          )
        )
      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes DMH référencés ProSilva ont été reconnus\\\\"
        )
      )
    }
  } else {
    df_Error_ProSilva <- data.frame()
  }
  # --- 2.2/ Codification AFI
  if (length(posAFI) > 0) {
    temp <- df_Codes[posAFI, ]
    Niveaux <-
      tolower(
        unique(
          CodeEcolos$Code[
            CodeEcolos$Codification == "engref"
            ]
        )
      )
    Niveaux <- gsub("10", "010", Niveaux)

    # Decomposition
    NbCodes <- length(Niveaux)
    # temp$CodeEcolo <- gsub("0", "", temp$CodeEcolo)
    temp$CodeEcolo <- tolower(temp$CodeEcolo)
    # temp <- filter(temp, NumPlac == 62 & NumArbre == 4)
    temp$CodeEcolo <- gsub("10", "010", temp$CodeEcolo)

    List <- c()
    pos <- c()
    for (i in 1:dim(temp)[1]) {
      List_temp <-
        str_extract(
          temp$CodeEcolo[i], Niveaux
        )[
          !is.na(
            str_extract(
              temp$CodeEcolo[i], Niveaux
            )
          )
          ]

      pos <- which(List_temp %in% c("m1", "m2"))
      if (length(pos) > 0) {
        List_temp <- List_temp[-which(List_temp == "m")]
      }
      pos <- which(
        List_temp %in% c("t1", "t2", "t3", "t4", "ts", "tc", "tn", "tx")
      )
      if (length(pos) > 0) {
        List_temp <- List_temp[-which(List_temp == "t")]
      }
      List <- c(List, list(List_temp))
      # on a une liste avec tous les codes retrouvés. On reconstruit alors le code pour le comparer à ce qui a été enregistré  = > détection des éléments inconnus
    }
    temp$CodeEcolo_rebuild <- sapply(List, paste0, collapse = "")

    pos <-
      with(
        temp, 
        which(
          CodeEcolo != CodeEcolo_rebuild &
            nchar(CodeEcolo) != nchar(CodeEcolo_rebuild)
        )
      )

    df_Error_AFI <- temp[pos, ]

    # Affichage
    cat(utf82LaTeX("\\emph{Codes DMH AFI/Engref}\\\\"))

    if (dim(df_Error_AFI)[1] > 0) {
      Test = ifelse(Test > 1, Test, 2)

      if (dim(df_Error_AFI)[1] <= 20) {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés AFI/ENGREF qui ne sont pas reconnus : \\\\"
          )
        )

        df <-
          df_Error_AFI[, c(
            "NumForet", "NumPlac", "NumArbre", "Cycle", 
            "CodeEcolo", "Ref_CodeEcolo"
          )]
        # t
        print(
          xtable(
            df, 
            caption = "\\footnotesize{Codes DMH AFI/ENGREF non reconnus dans la table 'BMSCercle'.}", 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c(
              "l", rep("|M{1.5cm}", ncol(df) - 2), "|M{2.5cm}", "|M{1.5cm}|"
            ), 
            label = "TabDMHAFI_BMSCercles"
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")

      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés AFI/ENGREF qui ne sont pas reconnus : ", 
            dim(df_Error_AFI)[1], " codes DMH non reconnus.\\\\ exemple : ", 
            paste0(head(unique(df_Error_AFI$CodeEcolo, 10)), collapse = ", "), 
            "\\\\"
          )
        )

      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes DMH référencés AFI/Engref ont été reconnus\\\\"
        )
      )
    }
  } else {
    df_Error_AFI <- data.frame()
  }
  # --- 2.3/ Codification EFI
  if (length(posEFI) > 0) {
    temp <- df_Codes[posEFI, ]

    List <- toupper(temp$CodeEcolo)
    List <- str_split(List, boundary("word"))

    pos <- c()
    for (i in 1:(dim(temp)[1])) {
      test <- all(List[[i]] %in% CodeEcolos$Code)
      if (!test) {
        pos <- c(pos, i)
      }
    }
    df_Error_EFI <- temp[pos, ]

    # Affichage
    cat(utf82LaTeX("\\emph{Codes DMH EFI}\\\\"))

    if (dim(df_Error_EFI)[1] > 0) {
      Test <- ifelse(Test > 1, Test, 2)
      if (dim(df_Error_EFI)[1] <= 20) {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés EFI qui ne sont pas reconnus : \\\\"
          )
        )

        df <-
          df_Error_EFI[, c(
            "NumForet", "NumPlac", "NumArbre", "Cycle", 
            "CodeEcolo", "Ref_CodeEcolo"
          )]
        # t
        print(
          xtable(
            df, 
            caption = "\\footnotesize{Codes DMH EFI non reconnus dans la table 'BMSCercle'.}", 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c(
              "l", rep("|M{1.5cm}", ncol(df) - 2), "|M{2.5cm}", "|M{1.5cm}|"), 
            label = "TabDMHEFI_BMSCercles"
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")

      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés EFI qui ne sont pas reconnus : ", 
            dim(df_Error_EFI)[1], " codes DMH non reconnus.\\\\ exemple : ", 
            paste0(head(unique(df_Error_EFI$Code, 10)), collapse = ", "), 
            "\\\\"
          )
        )
      }
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes DMH référencés EFI ont été reconnus\\\\"
        )
      )
    }
  } else {
    df_Error_EFI <- data.frame()
  }
  # --- 2.4/ Codification IRSTEA
  if (length(posIRSTEA) > 0) {
    temp <- df_Codes[posIRSTEA, ]
    Niveaux <-
      tolower(
        unique(
          CodeEcolos$Code[
            CodeEcolos$Codification == "irstea"
            ]
        )
      )
    # Decomposition
    NbCodes <-length(Niveaux)
    # temp$CodeEcolo <- gsub("0", "", temp$CodeEcolo)
    temp$CodeEcolo <- tolower(temp$CodeEcolo)

    List <- c()
    for (i in 1:dim(temp)[1]) {
      List <- c(
        List, 
        list(
          str_extract(
            temp$CodeEcolo[i], Niveaux
          )[
            !is.na(
              str_extract(
                temp$CodeEcolo[i], Niveaux
              )
            )
            ]
        )
      )
    }
    temp$CodeEcolo_rebuild <- sapply(List, paste0, collapse = "")
    pos <- which(temp$CodeEcolo != temp$CodeEcolo_rebuild)

    df_Error_IRSTEA <- temp[pos, ]

    # Affichage
    cat(utf82LaTeX("\\emph{Codes DMH IRSTEA}\\\\"))

    if (dim(df_Error_IRSTEA)[1] > 0) {
      Test = ifelse(Test > 1, Test, 2)

      if (dim(df_Error_IRSTEA)[1] <= 20) {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés IRSTEA qui ne sont pas reconnus : \\\\"
          )
        )

        df <-
          df_Error_IRSTEA[, c(
            "NumForet", "NumPlac", "NumArbre", "Cycle", 
            "CodeEcolo", "Ref_CodeEcolo"
          )]
        # t
        print(
          xtable(
            df, 
            caption = "\\footnotesize{Codes DMH IRSTEA non reconnus dans la table 'BMSCercle'.}", 
            caption.placement = "bottom", 
            digits = rep(0, ncol(df) + 1), 
            align = c(
              "l", rep("|M{1.5cm}", ncol(df) - 2), "|M{2.5cm}", "|M{1.5cm}|"
            ), 
            label = "TabDMHIRSTEA_BMSCercles"
          ), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:nrow(df)), 
          size = "\\scriptsize"
        )
        cat("\\FloatBarrier
        ")

      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des codes DMH référencés IRSTEA qui ne sont pas reconnus : ", 
            dim(df_Error_IRSTEA)[1], " codes DMH non reconnus.\\\\ exemple : ", 
            paste0(head(unique(df_Error_IRSTEA$Code, 10)), collapse = ", "), 
            "\\\\"
          )
        )
      }
      cat("\\FloatBarrier
        ")

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes DMH référencés IRSTEA ont été reconnus\\\\"
        )
      )
    }
  } else {
    df_Error_IRSTEA <- data.frame()
  }

  # --- Codification non reconnue
  if (length(posUnknown) > 0) {
    cat(utf82LaTeX("\\\\\\emph{Référence non reconnue}\\\\"))

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des références à des codifications de codes écologiques non reconnues\\\\
        Rappel : les seules codifications reconnues sont celles de l'AFI/ENGREF, de ProSilva, de l'IRSTEA et de l'EFI\\\\"
      )
    )
  }
}


##### Fin #####
if (Test == 0) {
  cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
}
if (Test == 1) {
  cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
}
if (Test >= 2) {
  cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table Reges}
<<Reges, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(Reges)[1] > 0) {
  ##### 1/ Essences inventoriées dans la table Reges #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )

  Test <- Test + Controle_Essence(Reges)
  cat("\\FloatBarrier ")

  ##### 2/ Contrôle des valeurs vides des variables #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  # --- 5.1/ Variables "vitales"
  cat(
    utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}")
  )

  ListName <- c()
  for (name in names(Reges)) {
    pos <- which(is.na(Reges[, name]))
    if (length(pos) > 0) ListName <- c(ListName, name)
  }

  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <-
      ListName[ListName %in% c("NumForet", "NumPlac", "Cycle", "SsPlac", "Essence")]
    Annexe <-
      ListName[!ListName %in% c(Vital, "Observations")]

    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
          paste0(Vital, collapse = ", "), "\\\\"
        )
      )

      df <-
        Reges %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <-
      #   summaryBy(
      #     list(Vital, "NumForet"), data = Reges, 
      #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
      #   )

      df <-
        if (length(Vital) == 1) {
          df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
        } else {
          df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
        }
      # Impression de la table
      if (!is.element("NumForet", Vital)) df <- df %>% select(-NumForet)

      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <-
        paste0(Vital, " : nombre de vides")

      print(
        xtable(
          df, 
          caption  = 
            utf82LaTeX(
              "\\footnotesize{Vides constatés dans les variables ", 
              paste0(Vital, collapse = ", "), 
              ", indispensables à l'analyse des données}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissVital_Reges"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("
          ")

    } else {
      Vital <- c("NumForet", "NumPlac", "Cycle", "SsPlac", "Essence")
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
          paste0(Vital, collapse = ", "), ")\\\\"
        )
      )
    }

    # --- 5.2/ Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))

    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)

      cat(
        utf82LaTeX(
          "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
          paste0(Annexe, collapse = ", "), "\\\\"
        )
      )

      df <-
        Reges %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <-
      #   summaryBy(
      #     list(Annexe, "NumForet"), data = Reges, 
      #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
      #   )

      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      if (!is.element("NumForet", Annexe)) df <- select(df, -NumForet)

      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
        paste0(Annexe, " : nombre de vides")

      print(
        xtable(
          df, 
          caption  = 
            utf82LaTeX(
              "\\footnotesize{Vides constatés dans les variables ", 
              paste0(Vital, collapse = ", "), 
              ", non indispensables dans l'analyse des données}"
            ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
          label = "TabMissAnnexe_Reges"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
          ")

    } else {
      Vital <- c("NumForet", "NumPlac", "Cycle", "SsPlac", "Essence")
      Annexe <-
        names(Reges)[!names(Reges) %in% c(Vital, "Observations")]

      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
          paste0(Annexe, collapse = ", "), ")\\\\"
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table\\\\"
      )
    )
  }

  ##### 3/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  # cat("\\paragraph{Cohérence avec les placettes de la feuille 'Rege'}")
  Test <- miss_plot(Reges, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")


  ##### 4/ Présentation succincte des données #####
  cat(utf82LaTeX("\\paragraph{Présentation succincte des données}"))

  cat(
    utf82LaTeX(
      "La feuille Reges contient des informations pour le(s) cycle(s) : ", 
      paste0(sort(unique(Reges$Cycle)), collapse = ", "), 
      "\\\\"
    )
  )
  # # --- Contrôle des NumForet de Reges :

  ##### 5/ Contrôle des Cycles de Reges #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des numéros d'inventaire (Cycles)}"))
  # Test <- Test + ControlCycle(Reges)


  ##### 6/ Contrôle des valeurs dupliquées #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))

  Reges <- Reges %>% arrange(NumForet, NumPlac, Cycle, SsPlac, Essence)
  pos1 <- which(duplicated(Reges))
  pos2 <- which(duplicated(Reges, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(Dupl) <= 30) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'Reges' : \\\\")

      df <- Reges[Dupl, names(Reges) != "Observations"]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'Reges'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df) - 1)), 
          label = "TabDoublon_Reges"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
          length(Dupl), " doublons détectés sur les placettes \\\\", 
          paste0(sort(unique(Reges$NumPlac[Dupl])), collapse = ", "), "\\\\"
        )
      )
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\

      ")
  }

  ##### 7/ Contrôle des valeurs des colonnes Rejet et Abroutis #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des valeurs des colonnes Rejet et Abroutis}"
    )
  )
  # --- Colonne Rejet
  cat(utf82LaTeX("\\paragraph{Contrôle des valeurs de la colonne Rejet}"))

  pos <- with(Reges, which(!Rejet %in% c(1, 0)))
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Valeur(s) non conforme(s) détectée(s) dans la colonne Rejet\\\\
                   Rappel : les seules valeurs reconnues sont 0 et 1\\\\"
      )
    )
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les valeurs renseignées dans la colonne Rejet sont bien reconnues\\\\"
      )
    )
  }

  # --- Colonne Abroutis
  cat(utf82LaTeX("\\paragraph{Contrôle des valeurs de la colonne Abroutis}"))

  pos <- with(Reges, which(!Rejet %in% c(1, 0)))
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Valeur(s) non conforme(s) détectée(s) dans la colonne Abroutis\\\\
                   Rappel : les seules valeurs reconnues sont 0 et 1\\\\"
      )
    )
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Toutes les valeurs renseignées dans la colonne Abroutis sont bien reconnues\\\\"
      )
    )
  }


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune données de régénération renseignée pour cette forêt\\\\"
    )
  )
}
@
\FloatBarrier

\subsection{Table PCQM}
<<PCQM1-Presentation, results = 'asis', eval = T, include = T>>=
Test = 0

if (nrow(PCQM) > 0) {
  ##### 1/ Contrôle des essences inventoriées dans la table #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )
  cat(
    "Les essences rencontrées dans la table 'PCQM' de la forêt", 
    foret, 
    " sont listées dans le tableau \\ref{ListEssence_PCQM}.\\\\"
  )
  Test <- Test + Controle_Essence(PCQM)
  cat("\\FloatBarrier ")

  v <- unique(PCQM$Essence)

  # Tableau listant les essences de l'inventaire (PCQM) présentes (et figurant dans la liste des essences de la feuille Essences).
  pos <- which(!v %in% Essences$Nom)

  if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
    v_Error <- v[pos]
    v <- v[-pos]
  }

  # Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
  # v <- Essences$Code[match(v, Essences$Nom)]
  v <- sort(v)

  v <- paste0(Essences$Code[match(v, Essences$Nom)], " - ", 
              v, " - ", 
              Essences$Latin[match(v, Essences$Nom)])

  # Impression du tableau des essences
  Vector2Table_Print(
    v, 
    "Liste des essences rencontrées dans la table", 
    "ListEssence_PCQM"
  )


  ##### 2/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(PCQM, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")


  ###### 3/ Présentation succincte des données #####
  cat(utf82LaTeX("\\paragraph{Présentation succincte des données}"))

  df <-
    PCQM %>%
    filter(
      PCQM$NumForet == forest_num & !is.na(PCQM$NumForet) &
        !is.na(PCQM$NumPlac) & !is.na(PCQM$Population)
    ) %>%
    distinct(NumForet, NumPlac, Population)
  # --- 3.1/ Nombre d'éléments
  pos <- which(PCQM$Population == "BMP")
  cat(
    utf82LaTeX(
      "Nombre de BMP tous cycles confondus : (NumForet, NumPlac et Id non vides) : ", 
      length(pos), "\\\\"
    )
  )
  pos <- which(PCQM$Population == "Taillis")
  cat(
    utf82LaTeX(
      "Nombre de Taillis tous cycles confondus : (NumForet, NumPlac et Id non vides) : ", 
      length(pos), "\\\\"
    )
  )
  pos <- which(PCQM$Population != "BMP" & PCQM$Population != "Taillis")
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des populations non reconnues dans la feuille Cercle\\\\
        Rappel : les seules populations reconnues sont 'Taillis' et 'BMP' ('Bois Mort sur Pied').\\\\", 
        length(pos), " valeur(s) non reconnue(s)\\\\"
      )
    )
  }

  # --- 3.2/ Valeurs déclinées par cycle
  cat(
    utf82LaTeX(
      "La feuille PCQM contient des informations pour le(s) cycle(s) : ", 
      paste0(sort(unique(PCQM$Cycle)), collapse = ", "), "\\\\"
    )
  )
if (length(unique(PCQM$Cycle)) > 0) {
  cat("\\begin{itemize}\n\\setlength\\itemsep{0em}")

  for (cycle in sort(unique(PCQM$Cycle))) {
    annee <- Cycles$Annee[Cycles$Cycle == cycle]
    cat(
      utf82LaTeX(
        "\\item Inventaire ", cycle, " (", annee, ") :\\\\ \\noindent "
      )
    )
  # - 3.3.1/ Valeurs d'Azimut
    az_MAX <- max(as.numeric(PCQM$Azimut[PCQM$Cycle == cycle]), na.rm = T)
    if (az_MAX >= 400) {
      if (az_MAX < 800) {
        az_MAX <- paste0("\\textbf{\\textcolor{Blue}{", az_MAX, " -> Placettes miroirs ?}}")
      } else {
        az_MAX <- paste0("\\textbf{\\textcolor{Red}{", az_MAX, "}}")
      }
    }
    az_MIN <- min(as.numeric(PCQM$Azimut[PCQM$Cycle == cycle]), na.rm = T)
    if (az_MIN < 0) {
      az_MIN <- paste0("\\textbf{\\textcolor{Red}{", az_MIN, "}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des azimuts : ", 
        az_MIN, 
        "-", 
        az_MAX, 
        "\\\\"
      )
    )
    # - 3.4/ Valeurs de Dist
    dist_MAX <- max(as.numeric(PCQM$Dist[PCQM$Cycle == cycle]), na.rm = T)
    if (dist_MAX >= 40) {
      dist_MAX <- paste0("\\textbf{\\textcolor{Red}{", dist_MAX, "}}")}
    dist_MIN <- min(as.numeric(PCQM$Dist[PCQM$Cycle == cycle]), na.rm = T)
    if (dist_MIN < 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, "}}")}
    if (dist_MIN == 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des distances : ", 
        dist_MIN, 
        "-", 
        dist_MAX, 
        "\\\\"
      )
    )
    # --- 3.5/ Valeurs de Diam
    d_MAX <- max(as.numeric(PCQM$Diam[PCQM$Cycle == cycle]), na.rm = T)
    if (d_MAX >= 200) {
      d_MAX <- paste0("\\textbf{\\textcolor{Red}{", d_MAX, "}}")
    }
    d_MIN <- min(as.numeric(PCQM$Diam[PCQM$Cycle == cycle]), na.rm = T)
    if (d_MIN < 4) {
      d_MIN <- paste0("\\textbf{\\textcolor{Red}{", d_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des Diam : ", 
        d_MIN, 
        "-", 
        d_MAX, 
        "\\\\"
      )
    )
  }
    cat("\\end{itemize}\n")
}


  ##### 4/ Contrôle des Cycles de Cercles #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des numéros d'inventaire (cf feuille Cycles)}"
    )
  )
  Test <- Test + ControlCycle(PCQM)
}
@

<<PCQM2-Bois_morts_sur_pied, results = 'asis'>>=
# Présence de BMP dans la table Arbres
pos <- which(!is.na(PCQM$Type))

if (length(pos) > 0) {
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle incohérences sur les données de Bois Mort sur Pied}"
    )
  )

  ##### 1/ Contrôle des types de bois mort sur pied #####
  cat(utf82LaTeX("\\paragraph{BMP : Contrôle des types de bois mort sur pied}"))

  # pos <- which(!is.na(PCQM$Type) & !PCQM$Type %in% CodeTypoArbres$Code)
  pos <-
    with(PCQM, which(!is.na(Type) & !Type %in% CodeTypoArbres$Code))

  if (length(pos) > 0) {
    Test <- ifelse(Test > 1, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des types de bois mort sur pied non reconnus\\\\
        Rappel : les seuls types reconnus sont '", 
        paste0( CodeTypoArbres$Code, collapse = "', '"), 
        "' (respectivement '", 
        paste0(CodeTypoArbres$Descriptif, collapse = "', '"), 
        "')\\\\", length(pos), " valeur(s) non reconnue(s)"
      )
    )
    if (length(pos) < 5) cat(" : '", PCQM$Type[pos], "'\\\\") else cat("\\\\")

  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les types de bois mort sur pied sont reconnus\\\\

"
      )
    )
  }

  ##### 2/ Contrôle du respect des hauteurs #####
  # --- 2.1/ Hauteur des souches
  cat(utf82LaTeX("\\paragraph{BMP : Souches > 1, 30m}"))

  pos <- which(PCQM$Haut > 1.30 & PCQM$Type == "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant strictement plus d'1,30m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        PCQM[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en souche et faisant plus d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = c(rep(0, ncol(df) - 1), 1, 0), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-1"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans cette table : ", 
          length(pos), 
          " erreurs détectées\\\\"
        )
      )
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de plus d'1, 30m classé en 'Souche' dans la table\\\\"
      )
    )
  }

  # --- 2.2/ Hauteur des chandelles des chandelles et des arbres
  cat(utf82LaTeX("\\paragraph{BMP : Arbres ou chandelles < 1, 30m}"))

  pos <- which(PCQM$Haut < 1.30 & PCQM$Type != "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1,30 m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        PCQM[pos, c(
          "NumForet", "NumPlac", "Cycle", "Diam", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-2"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : ", 
          length(pos), " erreurs détectées\\\\"
        )
      )

      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de moins d'1, 30m classé en 'Arbre' ou en 'Chandelle' dans la table\\\\"
      )
    )
  }

  ##### 3/ Incohérences sur les données Type - Haut - StadeD - StadeE des BMP #####
  cat(
    utf82LaTeX(
      "\\paragraph[Incohérences entre les colonnes Type - Haut - Stade]{Incohérences entre les colonnes Type - Haut - Stade\\footnote{\\textit{\\underline{Rqe :} on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici\\\\
      \\indent \\underline{Attention :} il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas}}}"
    )
  )

  # cat(
  #   utf82LaTeX(
  #     "\\textit{Rqe : on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici}\\\\
  #     \\textit{Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}\\\\\\\\"
  #   )
  # )
  ListDisp_Verif <- c()
  pos_BM <-
    with(PCQM, which(!is.na(Type) | !is.na(Haut) | !is.na(Stade)))

  BMP_Temp <- PCQM[pos_BM, ]

  pos <- c()
  for (name in c("Type", "Haut", "Stade")) {
    if (name == "Haut") {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name]) & BMP_Temp$Type != 1
          )
        ))

    } else {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name])
          )
        ))

    }
  }

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{blue}{\\textbf{Remarque}} - Il peut y avoir des informations manquantes pour les BMP : \\\\"
        )
      )

      df <-
        BMP_Temp[pos, c(
          "NumForet", "NumPlac", "Cycle", "Quart", "Diam", 
          "Type", "Haut", "Stade"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP pour lesquels il peut manquer des informations}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df) - 1)), 
          label = "TabMissBMP"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il peut y avoir des informations manquantes pour les BMP : ", length(pos), " manques détectés\\\\"
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence entre les colonnes Type - Haut - Stade pour les BMP\\\\"
      )
    )
  }
}
@


\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Diviser l'analyse en 2 : pop BMP puis pop Taillis + contrôler que les numéros de quart correspondent avec les valeurs d'azimut ? + contrôler que si on a du BMP il faut assi renseigner les Stade, Type et Haut}\\}{}
<<PCQM3-Valeurs_vides, results = 'asis'>>=

if (nrow(PCQM) > 0) {
  ##### 1/ Contrôle des valeurs vides des variables #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  for (pop in unique( sort(PCQM$Population, na.last = T) )) {
    cat(
      "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item ", pop, "\n\\end{itemize}"
    )

    if (is.element(pop, c("BMP", "Taillis"))) { # Test si le nom de la population est correct
      # Définition de la table temporaire
      PCQM_temp <- PCQM %>% filter(Population == pop)

      # -------------------- #
      ListName <- c()
      for (name in names(PCQM_temp)) {
        pos <- which(is.na(PCQM_temp[, name]))
        if (length(pos) > 0) {ListName <- c(ListName, name)}
      }
      Vital <- c()
      Annexe <- c()

      if (length(ListName) > 0) { # éventuellement : rajouter "si BMP, alors il faut Haut et Type + contrôle des populations, + contrôle des types
        if (pop == "BMP") {
          Vital <-
            ListName[ListName %in% c(
              "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
              "Essence", "Azimut", "Dist", "Diam"#, 
              # "Haut", "Type"
            )]
        } else {
          Vital <-
            ListName[ListName %in% c(
              "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
              "Essence", "Azimut", "Dist", "Diam"
            )]
        }
        Annexe <-
          ListName[!ListName %in% c(Vital, "Observations", "StadeE", "StadeD")]
        # --- 5.1/ Variables "vitales"
        cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))

        if (length(Vital) > 0) {
          Test = ifelse(Test >= 2, Test, 2)
          cat(
            utf82LaTeX(
              "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
              paste0(Vital, collapse = ", "), "\\\\"
            )
          )

          df <-
            PCQM_temp %>%
            gather(var, value, Vital) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <-
          #   summaryBy(
          #     list(Vital, "NumForet"), data = PCQM_temp, 
          #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
          #   )
          if (length(Vital) == 1) {
            df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
          }
          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Vital)) {
            df <- df %>% select(-NumForet)
          }
          names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <-
            paste0(Vital, " : nombre de vides")
          print(
            xtable(
              df, 
              caption = utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Vital, collapse = ", "), 
                ", indispensables à l'analyse des données}"
              ), 
              caption.placement = "bottom", 
              digits = rep(0, ncol(df) + 1), 
              align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
              label = paste0("TabMissVital_PCQM", pop)
            ), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize"
          )
          cat("
          ")

        } else {
          Vital <- c(
            "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
            "Essence", "Azimut", "Dist", "Diam"
          )
          cat(
            utf82LaTeX(
              "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
              paste0(Vital, collapse = ", "), ")\\\\"
            )
          )
        }

        # --- 5.2/ Variables "annexes"
        cat(
          utf82LaTeX(
            "\\paragraph{Variables non indispensables à l'analyse des données}"
          )
        )
        if (length(Annexe) > 0) {
          Test = ifelse(Test > 1, Test, 1)

          cat(
            utf82LaTeX(
              "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
              paste0(Annexe, collapse = ", "), "\\\\"
            )
          )

          df <-
            PCQM_temp %>%
            gather(var, value, Annexe) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <-
          #   summaryBy(
          #     list(Annexe, "NumForet"), data = PCQM_temp, 
          #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
          #   )
          if (length(Annexe) == 1) {
            df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
          }

          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Annexe)) {
            df <- df %>% select(-NumForet)
          }
          names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
            paste0(Annexe, " : nombre de vides")
          print(
            xtable(
              df, 
              caption = utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Vital, collapse = ", "), 
                ", non indispensables dans l'analyse des données}"
              ), 
              caption.placement = "bottom", 
              digits = rep(0, ncol(df) + 1), 
              align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
              label = paste0("TabMissAnnexe_PCQM", pop)
            ), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize"
          )
          cat("\\FloatBarrier
        ")

        } else {
          Vital <- c(
            "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
            "Essence", "Azimut", "Dist", "Diam"
          )
          Annexe <-
            names(PCQM_temp)[!names(PCQM_temp) %in% c(Vital, "Observations")]
          cat(
            utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                       paste0(Annexe, collapse = ", "), 
                       ")\\\\"
            )
          )
        }
      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'PCQM' pour la population ", 
            pop, "\\\\"
          )
        )
      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Nom de population incorrect\\\\
          Rappel : 'BMP' et 'Taillis' sont les seules populations admises\\\\"
        )
      )
    }

  }
  # cat(utf82LaTeX("\\end{itemize}"))

  ##### 2/ Contrôle des valeurs dupliquées #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des valeurs dupliquées (NumForet-NumPlac-Cycle-Population-Quart)}"
    )
  )

  df_Dupl <-
    PCQM %>%
    select(NumForet, NumPlac, Cycle, Population, Quart)

  pos1 <- which(duplicated(df_Dupl))
  pos2 <- which(duplicated(df_Dupl, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <-
        unique(
          c(Dupl, pos2[i]:pos1[i])
        )
    }
  }

  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Information dupliquée : \\\\"
        )
      )
      df <-
        PCQM[Dupl, c(
          "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
          "Essence", "Azimut", "Dist", "Diam"
        )]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'PCQM'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_PCQM"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'PCQM' : ", 
          length(Dupl), 
          " doublons détectés sur les placettes\\\\", 
          paste0(sort(unique(PCQM$NumPlac[Dupl])), collapse = ", "), "\\\\"
        )
      )

      cat("\\FloatBarrier

        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\"
      )
    )
  }

   ##### 3/ Contrôle des azimut de chaque quart #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des azimut des différents quarts}"
    )
  )

  df <-
    PCQM %>%
    select(NumForet, NumPlac, Cycle, Population, Quart, Azimut, Dist) %>%
    mutate(
      Quart_VERIF = cut(
        Azimut, 
        breaks = c(0, 100, 200, 300, 400), 
        labels = c("NE", "SE", "SO", "NO"), 
        include.lowest = T, 
        right = T
      )
    )

  pos1 <- with(df, which(Quart != Quart_VERIF))

  if (length(pos1) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(pos1) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Incohérence Azimut <-> Quart détectée : \\\\"
        )
      )
      df <-
        PCQM[pos1, c(
          "NumForet", "NumPlac", "Cycle", "Population", "Quart", 
          "Essence", "Azimut", "Dist", "Diam"
        )]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des incohérences Azimut <-> Quart dans la table 'PCQM'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c(
            "l", "|M{1.5cm}|", rep("M{1.5cm}|", 5), 
            rep("M{1cm}|", ncol(df) - 6)
          ), 
          label = "TabDoublon_PCQM"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - incohérence détectée entre les quarts et les azimuts dans la table 'PCQM' : ", 
          length(pos1), 
          " incohérences détectées sur les placettes\\\\", 
          paste0(sort(unique(PCQM$NumPlac[pos1])), collapse = ", "), "\\\\"
        )
      )

      cat("\\FloatBarrier

        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence Azimut <-> Quart détectée dans la table\\\\"
      )
    )
  }


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}

@
\FloatBarrier

\subsection{Table Cercle}
<<Cercles1-Presentation, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(Cercles)[1] > 0) {
  ##### 1/ Contrôle des essences inventoriées dans la table #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )
  cat("Les essences rencontrées dans la table 'Cercles' de la forêt", 
      foret, 
      " sont listées dans le tableau \\ref{ListEssence_Cercles}.\\\\"
  )
  Test <- Test + Controle_Essence(Cercles)
  cat("\\FloatBarrier ")

  v <- unique(Cercles$Essence)

  # Tableau listant les essences de l'inventaire (Cercles) présentes (et figurant dans la liste des essences de la feuille Essences).
  pos <- which(!v %in% Essences$Nom)

  if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
    v_Error <- v[pos]
    v <- v[-pos]
  }

  # Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
  # v <- Essences$Code[match(v, Essences$Nom)]
  v <- sort(v)

  v <- paste0(Essences$Code[match(v, Essences$Nom)], " - ", 
              v, " - ", 
              Essences$Latin[match(v, Essences$Nom)])

  # Impression du tableau des essences
  Vector2Table_Print(
    v, 
    "Liste des essences rencontrées dans la table", 
    "ListEssence_Cercles"
  )


  ##### 2/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(Cercles, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")


  ###### 3/ Présentation succincte des données #####
  cat(utf82LaTeX("\\paragraph{Présentation succincte des données}"))

  # df <-
  #   Cercles %>%
  #   filter(
  #     Cercles$NumForet == forest_num & !is.na(Cercles$NumForet) &
  #       !is.na(Cercles$NumPlac) & !is.na(Cercles$Population)
  #   ) %>%
  #   # distinct(NumForet, NumPlac, Population, .keep_all = T) %>%
  #   group_by(NumForet, Population) %>%
  #   summarise(Nbre = sum(Nbre, na.rm = T)) %>%
  #   ungroup()

  # --- 3.1/ Nombre d'éléments
  pos <- which(Cercles$Population == "BMP")
  cat(
    utf82LaTeX(
      "Nombre de BMP : (NumForet, NumPlac et Population non vides) : ", length(pos), "\\\\"
    )
  )
  pos <- which(Cercles$Population == "Taillis")
  cat(
    utf82LaTeX(
      "Nombre de Taillis : (NumForet, NumPlac et somme des valeurs de 'Nbre') : ", 
      sum(Cercles$Nbre[pos], na.rm = T), "\\\\"
    )
  )
  pos <- which(Cercles$Population != "BMP" & Cercles$Population != "Taillis")
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des populations non reconnues dans la feuille Cercle\\\\
        Rappel : les seules populations reconnues sont 'Taillis' et 'BMP' ('Bois Mort sur Pied')\\\\", 
        length(pos), " valeur(s) non reconnue(s)\\\\"
      )
    )
  }

  # --- 3.2/ Cycles inventoriés
  cat(
    utf82LaTeX(
      "La feuille 'Cercles' contient des informations pour le(s) cycle(s) : ", 
      paste0(sort(unique(Cercles$Cycle)), collapse = ", "), "\\\\"
    )
  )
  # --- 3.3/ Valeurs d'Azimut
  if (length(which(!is.na(Cercles$Azimut))) != 0) {
    az_MAX <- max(as.numeric(Cercles$Azimut[Cercles$Cycle == cycle]), na.rm = T)
    if (az_MAX >= 400) {
      if (az_MAX < 800) {
        az_MAX <- paste0("\\textbf{\\textcolor{Blue}{", az_MAX, " -> Placettes miroirs ?}}")
      } else {
        az_MAX <- paste0("\\textbf{\\textcolor{Red}{", az_MAX, "}}")
      }
    }
    az_MIN <- min(as.numeric(Cercles$Azimut[Cercles$Cycle == cycle]), na.rm = T)
    if (az_MIN < 0) {
      az_MIN <- paste0("\\textbf{\\textcolor{Red}{", az_MIN, "}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des azimuts : ", 
        az_MIN, 
        "-", 
        az_MAX, 
        "\\\\"
      )
    )
  } else cat(utf82LaTeX("Aucun azimut renseigné\\\\"))
    # --- 3.4/ Valeurs de Dist
    if (length(which(!is.na(Cercles$Dist))) != 0) {
    dist_MAX <- max(as.numeric(Cercles$Dist[Cercles$Cycle == cycle]), na.rm = T)
    if (dist_MAX >= 40) {
      dist_MAX <- paste0("\\textbf{\\textcolor{Red}{", dist_MAX, "}}")}
    dist_MIN <- min(as.numeric(Cercles$Dist[Cercles$Cycle == cycle]), na.rm = T)
    if (dist_MIN < 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, "}}")}
    if (dist_MIN == 0) {
      dist_MIN <- paste0("\\textbf{\\textcolor{Red}{", dist_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des distances : ", 
        dist_MIN, 
        "-", 
        dist_MAX, 
        "\\\\"
      )
    )
    } else cat(utf82LaTeX("Aucune distance renseignée\\\\"))
    # --- 3.5/ Valeurs de Diam
    d_MAX <- max(as.numeric(Cercles$Diam[Cercles$Cycle == cycle]), na.rm = T)
    if (d_MAX >= 200) {
      d_MAX <- paste0("\\textbf{\\textcolor{Red}{", d_MAX, "}}")
    }
    d_MIN <- min(as.numeric(Cercles$Diam[Cercles$Cycle == cycle]), na.rm = T)
    if (d_MIN < 4) {
      d_MIN <- paste0("\\textbf{\\textcolor{Red}{", d_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des Diam : ", 
        d_MIN, 
        "-", 
        d_MAX, 
        "\\\\"
      )
    )


  ##### 4/ Contrôle des Cycles de Cercles #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des numéros d'inventaire (cf feuille Cycles)}"
    )
  )
  Test <- Test + ControlCycle(Cercles)
}
@

<<Cercles2-Bois_morts_sur_pied, results = 'asis'>>=
# Présence de BMP dans la table Arbres
pos <- which(!is.na(Cercles$Type))

if (length(pos) > 0) {
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle incohérences sur les données de Bois Mort sur Pied}"
    )
  )
  ##### 1/ Contrôle des types de bois mort sur pied #####
  cat(utf82LaTeX("\\paragraph{BMP : Contrôle des types de bois mort sur pied}"))

  # pos <- which(!is.na(Cercles$Type) & !Cercles$Type %in% CodeTypoArbres$Code)
  pos <-
    with(Cercles, which(!is.na(Type) & !Type %in% CodeTypoArbres$Code))

  if (length(pos) > 0) {
    Test <- ifelse(Test > 1, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des types de bois mort sur pied non reconnus\\\\
        Rappel : les seuls types reconnus sont '", 
        paste0( CodeTypoArbres$Code, collapse = "', '"), 
        "' (respectivement '", 
        paste0(CodeTypoArbres$Descriptif, collapse = "', '"), 
        "').\\\\", length(pos), " valeur(s) non reconnue(s)"
      )
    )
    if (length(pos) < 5) cat(" : '", Cercles$Type[pos], "'\\\\") else cat("\\\\")

  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les types de bois mort sur pied sont reconnus\\\\

"
      )
    )
  }

  ##### 2/ Contrôle du respect des hauteurs #####
  # --- 2.1/ Hauteur des souches
  cat(utf82LaTeX("\\paragraph{BMP : Souches > 1, 30m}"))

  pos <- which(Cercles$Haut > 1.30 & Cercles$Type == "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant strictement plus d'1, 30m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        Cercles[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en souche et faisant plus d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = c(rep(0, ncol(df) - 1), 1, 0), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-1"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans cette table : ", 
          length(pos), 
          " erreurs détectées\\\\"
        )
      )
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de plus d'1, 30m classé en 'Souche' dans la table\\\\"
      )
    )
  }

  # --- 2.2/ Hauteur des chandelles des chandelles et des arbres
  cat(utf82LaTeX("\\paragraph{BMP : Arbres ou chandelles < 1, 30m}"))

  pos <- which(Cercles$Haut < 1.30 & Cercles$Type != "S")

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : \\\\"
        )
      )

      df <-
        Cercles[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Haut", "Type"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m (Impossible dans cette table)}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabBMP-2"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : ", 
          length(pos), " erreurs détectées\\\\"
        )
      )

      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de moins d'1, 30m classé en 'Arbre' ou en 'Chandelle' dans la table\\\\"
      )
    )
  }

  ##### 3/ Incohérences sur les données Type - Haut - StadeD - StadeE des BMP #####
  cat(
    utf82LaTeX(
      "\\paragraph[Incohérences entre les colonnes Type - Haut - Stade]{Incohérences entre les colonnes Type - Haut - Stade\\footnote{\\textit{\\underline{Rqe :} on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici\\\\
      \\indent \\underline{Attention :} il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas}}}"
    )
  )

  # cat(
  #   utf82LaTeX(
  #     "\\footnote{\\textit{Rqe : on détecte ici si les colonnes Type - Haut et Stade sont cohérentes entre elles. Selon le protocole d'inventaire choisi, ne pas tenir compte des incohérences mentionnées ici\\\\
  #     Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}}\\\\\\\\"
  #   )
  # )
  ListDisp_Verif <- c()
  pos_BM <-
    with(Cercles, which(!is.na(Type) | !is.na(Haut) | !is.na(Stade)))

  BMP_Temp <- Cercles[pos_BM, ]

  pos <- c()
  for (name in c("Type", "Haut", "Stade")) {
    if (name == "Haut") {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name]) & BMP_Temp$Type != 1
          )
        ))

    } else {
      pos <-
        unique(c(
          pos, 
          which(
            is.na(BMP_Temp[, name])
          )
        ))

    }
  }

  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{blue}{\\textbf{Remarque}} - Il peut y avoir des informations manquantes pour les BMP : \\\\"
        )
      )

      df <-
        BMP_Temp[pos, c(
          "NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Diam2", 
          "Type", "Haut", "Stade"
        )]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des BMP pour lesquels il peut manquer des informations}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df) - 1)), 
          label = "TabMissBMP"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )

    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{blue}{\\textbf{Remarque}} - Il peut y avoir des informations manquantes pour les BMP : ", length(pos), " manques détectés\\\\"
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence entre les colonnes Type - Haut - Stade pour les BMP\\\\"
      )
    )
  }
}
@

<<Cercles3-Valeurs_vides, results = 'asis'>>=

if (dim(Cercles)[1] > 0) {
  ##### 1/ Contrôle des valeurs vides des variables #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  # cat("\\begin{itemize}\n\\setlength\\itemsep{0em}")
  for (pop in unique( sort(Cercles$Population, na.last = T) )) {
    # cat("\\item ", pop)
    cat(
      "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item ", pop, "\n\\end{itemize}"
    )

    if (is.element(pop, c("BMP", "Taillis"))) { # Test si le nom de la population est correct
      # Définition de la table temporaire
      Cercles_temp <- Cercles %>% filter(Population == pop)

      # -------------------- #
      ListName <- c()
      for (name in names(Cercles_temp)) {
        pos <- which(is.na(Cercles_temp[, name]))
        if (length(pos) > 0) {ListName <- c(ListName, name)}
      }
      Vital <- c()
      Annexe <- c()

      if (length(ListName) > 0) { # éventuellement : rajouter "si BMP, alors il faut Haut et Type + contrôle des populations, + contrôle des types
        if (pop == "BMP") {
          Vital <-
            ListName[ListName %in% c(
              "NumForet", "NumPlac", "Cycle", "Population", 
              "Essence", "Diam"#, "Azimut", "Dist", 
              # "Haut", "Type"
            )]
        } else {
          Vital <-
            ListName[ListName %in% c(
              "NumForet", "NumPlac", "Cycle", "Population", 
              "Essence", "Diam" # "Azimut", "Dist", 
            )]
        }
        Annexe <-
          ListName[!ListName %in% c(Vital, "Observations", "StadeE", "StadeD")]
        # --- 5.1/ Variables "vitales"
        cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))

        if (length(Vital) > 0) {
          Test = ifelse(Test >= 2, Test, 2)
          cat(
            utf82LaTeX(
              "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
              paste0(Vital, collapse = ", "), "\\\\"
            )
          )

          df <-
            Cercles_temp %>%
            gather(var, value, Vital) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <-
          #   summaryBy(
          #     list(Vital, "NumForet"), data = Cercles_temp, 
          #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
          #   )
          if (length(Vital) == 1) {
            df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
          }
          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Vital)) {
            df <- df %>% select(-NumForet)
          }
          names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <-
            paste0(Vital, " : nombre de vides")
          print(
            xtable(
              df, 
              caption = utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Vital, collapse = ", "), 
                ", indispensables à l'analyse des données}"
              ), 
              caption.placement = "bottom", 
              digits = rep(0, ncol(df) + 1), 
              align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
              label = paste0("TabMissVital_Cercles", pop)
            ), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize"
          )
          cat("
          ")

        } else {
          Vital <- c(
            "NumForet", "NumPlac", "Cycle", "Population", 
            "Essence", "Diam" #"Azimut", "Dist", 
          )
          cat(
            utf82LaTeX(
              "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
              paste0(Vital, collapse = ", "), ")\\\\"
            )
          )
        }

        # --- 5.2/ Variables "annexes"
        cat(
          utf82LaTeX(
            "\\paragraph{Variables non indispensables à l'analyse des données}"
          )
        )
        if (length(Annexe) > 0) {
          Test = ifelse(Test > 1, Test, 1)

          cat(
            utf82LaTeX(
              "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
              paste0(Annexe, collapse = ", "), "\\\\"
            )
          )

          df <-
            Cercles_temp %>%
            gather(var, value, Annexe) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <-
          #   summaryBy(
          #     list(Annexe, "NumForet"), data = Cercles_temp, 
          #     FUN = function(x) length(which(is.na(x))), fun.names = "NbreVides"
          #   )
          if (length(Annexe) == 1) {
            df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
          }

          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Annexe)) {
            df <- df %>% select(-NumForet)
          }
          names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
            paste0(Annexe, " : nombre de vides")
          print(
            xtable(
              df, 
              caption = utf82LaTeX(
                "\\footnotesize{Vides constatés dans les variables ", 
                paste0(Vital, collapse = ", "), 
                ", non indispensables dans l'analyse des données}"
              ), 
              caption.placement = "bottom", 
              digits = rep(0, ncol(df) + 1), 
              align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
              label = paste0("TabMissAnnexe_Cercles", pop)
            ), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize"
          )
          cat("\\FloatBarrier
        ")

        } else {
          Vital <- c(
            "NumForet", "NumPlac", "Cycle", "Population", 
            "Essence", "Diam" # "Azimut", "Dist", 
          )
          Annexe <-
            names(Cercles_temp)[!names(Cercles_temp) %in% c(Vital, "Observations")]
          cat(
            utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                       paste0(Annexe, collapse = ", "), 
                       ")\\\\"
            )
          )
        }
      } else {
        cat(
          utf82LaTeX(
            "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'Cercles' pour la population ", 
            pop, "\\\\"
          )
        )
      }
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Nom de population incorrect\\\\
          Rappel : 'BMP' et 'Taillis' sont les seules populations admises\\\\"
        )
      )
    }

  }
  # cat(utf82LaTeX("\\end{itemize}"))

  ##### 2/ Contrôle des valeurs dupliquées #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle des valeurs dupliquées (NumForet-NumPlac-Cycle-Population-Essence-Diam)}"
    )
  )

  df_Dupl1 <- # si repérage des données de la feuille Cercle (ex : BMP)
    Cercles %>%
    filter(!is.na(Azimut) | !is.na(Dist)) %>%
    select(NumForet, NumPlac, Cycle, Population, Azimut, Dist, Essence, Diam, Nbre)
  df_Dupl2 <- # si pas de repérage des données de la feuille Cercle (ex : taillis)
    Cercles %>%
    filter(is.na(Azimut) & is.na(Dist)) %>%
    select(NumForet, NumPlac, Cycle, Population, Essence, Diam, Nbre)

  pos1 <- unique(
    which(duplicated(df_Dupl1)), 
    which(duplicated(df_Dupl2))
  )
  pos2 <- unique(
    which(duplicated(df_Dupl1, fromLast = T)), 
    which(duplicated(df_Dupl2, fromLast = T))
  )

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <-
        unique(
          c(Dupl, pos2[i]:pos1[i])
        )
    }
  }

  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Information dupliquée : \\\\"
        )
      )
      df <-
        Cercles[Dupl, c(
          "NumForet", "NumPlac", "Cycle", "Population", 
          "Essence", "Azimut", "Dist", "Diam"
        )]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'Cercles'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_Cercles"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'Cercles' : ", 
          length(Dupl), 
          " doublons détectés sur les placettes\\\\", 
          paste0(sort(unique(Cercles$NumPlac[Dupl])), collapse = ", "), "\\\\"
        )
      )

      cat("\\FloatBarrier

        ")
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\"
      )
    )
  }


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

<<Cercles_ancien, results = 'asis', eval = F, include = F>>=
Test = 0

if (dim(Cercles)[1] > 0) {
  cat("Les essences rencontrées dans la table 'Cercles' de la forêt", 
      foret, 
      " sont listées dans le tableau \\ref{ListEssence_Cercles}.\\\\")
  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}"))
  Test <- Test + Controle_Essence(Cercles)
  cat("\\FloatBarrier ")

  v <- unique(Cercles$Essence)

  # Tableau listant les essences de l'inventaire (Cercles) présentes (et figurant dans la liste des essences de la feuille Essences).
  pos <- which(!v %in% Essences$Nom)

  if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
    v_Error <- v[pos]
    v <- v[-pos]
  }

  # Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
  # v <- Essences$Code[match(v, Essences$Nom)]
  v <- sort(v)

  v <- paste0(Essences$Code[match(v, Essences$Nom)], " - ", 
              v, " - ", 
              Essences$Latin[match(v, Essences$Nom)])

  # Impression du tableau des essences
  Vector2Table_Print(
    v, 
    "Liste des essences rencontrées dans la table", 
    "ListEssence_Cercles"
  )


  # -------------------- Présentation succincte des données -------------------- #
  cat("\\paragraph{Présentation succincte des données}")
  cat("Nombre d'éléments (NumForet, NumPlac et Population non vides) : ", 
      dim(distinct(Cercles[Cercles$NumForet == forest_num &
                             !is.na(Cercles$NumForet) &
                             !is.na(Cercles$NumPlac) &
                             !is.na(Cercles$Population), ], 
                   NumForet, NumPlac, Population)
      )[1], "\\\\")
  cat(paste0("La feuille Cercles contient des informations pour la/les population(s) : '", 
             paste0(sort(unique(Cercles$Population), 
                         na.last = T), 
                    collapse = "', '"), "'\\\\"))
  cat(paste0("La feuille Cercles contient des informations pour le(s) cycle(s) : ", 
             paste0(sort(unique(Cercles$Cycle)), collapse = ", "), "\\\\"))
  # cat(paste("Valeurs extrêmes des azimuts : ", min(as.numeric(Cercles$Azimut), na.rm = T), "-", max(as.numeric(Cercles$Azimut), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des distances : ", min(as.numeric(Cercles$Dist), na.rm = T), "-", max(as.numeric(Cercles$Dist), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des azimut : ", min(as.numeric(Cercles$Azimut), na.rm = T), "-", max(as.numeric(Cercles$Azimut), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des Diam : ", min(as.numeric(Cercles$Diam), na.rm = T), "-", max(as.numeric(Cercles$Diam), na.rm = T), "\\\\"))
  cat(paste("Types inventoriés : '", 
            paste0(sort(unique(Cercles$Type), na.last = T), 
                   collapse = "', '"), "'\\\\

          "))





  # Pas besoin de contrôler le NumForet puisque subset fait sur cette base

  # # --- Contrôle des NumForet de Dispositifs :
  # cat(utf82LaTeX("\\subsubsection{Contrôle des numéros de dispositif}"))
  # ListDisp_Verif <- unique(setdiff(Num, unique(Transect$NumForet)))
  # if (length(ListDisp_Verif) > 0) {
  # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Aucune donnée n'est renseignée dans la table 'Transect' pour le(s) dispositif(s) :"))
  #   Vector2Table_Print(ListDisp_Verif, # utf82LaTeX(
  #                      "Liste des dispositifs de la base PSDRF non renseignés dans la table 'Transect'.", 
  #                      "TabMiss1_Transect")
  #   cat("\\FloatBarrier
  #       ")
  # } else {
  #   cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les dispositifs indiqués dans la table 'Cycles' du fichier administrateur", 
  #              basename(file), 
  #              " ont été renseignés au moins une fois dans la table 'Transect' (classeur d'inventaire)\\\\")))
  # }

  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}"))
  Test <- Test + Controle_Essence(Cercles)
  cat("\\FloatBarrier ")


  if (length(which(!is.na(Cercles$Stade))) > 0) {
    cat("\\subsubsection{Contrôle des stades de décomposition}")
    Cercles <-
      Cercles %>%
      mutate(
        StadeE = floor(Stade / 10), 
        StadeD = Stade - StadeE * 10
      )

    Test <- Controle_Durete(CodeDurete, Cercles, Test)
    cat("\\FloatBarrier ")

    if (length(which(!is.na(Cercles$StadeD))) > 0) {
      cat("\\FloatBarrier Fréquence des stades de décomposition :\\\\")
      df_FreqStadeD <- data.frame(table(Cercles$StadeD), stringsAsFactors = F) %>%
        rename("Stade de\ndécomposition" = "Var1", 
                "Occurence" = "Freq")
      print(xtable(df_FreqStadeD, 
                   digits = rep(0, dim(df_FreqStadeD)[2]+1), 
                   align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeD)[2]-1))), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            floating = F, 
            hline.after = c(-1:dim(df_FreqStadeD)[1]), 
            size = "\\scriptsize")
    }


    cat("\\subsubsection{Contrôle des stades d'écorce}")
    Test <- Controle_Ecorce(CodeEcorce, Cercles, Test)
    cat("\\FloatBarrier ")

    if (length(which(!is.na(Cercles$StadeE))) > 0) {
      cat("Fréquence des stades d'écorce :\\\\")
      df_FreqStadeE <- data.frame(table(Cercles$StadeE), stringsAsFactors = F) %>%
        rename("Stade écorce" = "Var1", 
                "Occurence" = "Freq")
      print(xtable(df_FreqStadeE, 
                   digits = rep(0, dim(df_FreqStadeE)[2]+1), 
                   align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeE)[2]-1))), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            floating = F, 
            hline.after = c(-1:dim(df_FreqStadeE)[1]), 
            size = "\\scriptsize")
    }
  }













  # cat("\\subsubsection{Contrôle des stades d'écorce}")
  # Test <- Controle_Ecorce(CodeEcorce, Transect, Test)
  # cat("\\FloatBarrier ")
  #
  # cat("\\subsubsection{Contrôle des stades de décomposition}")
  # Test <- Controle_Durete(CodeDurete, Transect, Test)
  # cat("\\FloatBarrier ")

  # ----- Contrôle des Cycles de Transect :
  cat(utf82LaTeX("\\subsubsection{Contrôle des numéros d'inventaire (Cycles)}"))
  Test <- Test + ControlCycle(Cercles)


  # ----- Contrôle des valeurs vides des variables :
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
if (Dev == T) {
  cat("\\textcolor{red}{Diviser l'analyse en 2 : pop BMP puis pop Taillis + contrôler que les numéros de quart correspondent avec les valeurs d'azimut ? + contrôler que si on a du BMP il faut assi renseigner les Stade, Type et Haut}\\\\")
}

  # cat("\\begin{itemize}\n\\setlength\\itemsep{0em}")
  for (pop in unique(sort(Cercles$Population, 
                          na.last = T))) {
    # tk_messageBox(type = "ok", message = pop)
    # cat("\\item ", pop, "\\\\")
    cat(
      "\\begin{itemize}\n\\setlength\\itemsep{0em}\n\\item ", pop, "\n\\end{itemize}"
    )

    if (is.element(pop, c("BMP", "Taillis"))) { # Test si le nom de la population est correct
      # Définition de la table temporaire
      Cercles_temp <- filter(Cercles, 
                             Population == pop)

      # -------------------- #
      ListName <- c()
      for (name in names(Cercles_temp)) {
        pos <- which(is.na(Cercles_temp[, name]))
        if (length(pos) > 0) {ListName <- c(ListName, name)}
      }
      Vital <- c()
      Annexe <- c()

      if (length(ListName) > 0) { # éventuellement : rajouter "si BMP, alors il faut Haut et Type + contrôle des populations, + contrôle des types
        if (pop == "BMP") {
          Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "Cycle", "Population", 
                                            "Essence", "Azimut", "Dist", "Diam", 
                                            "Haut", "Type")]
        } else {
          Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "Cycle", "Population", 
                                            "Essence", "Azimut", "Dist", "Diam")]
        }
        Annexe <- ListName[!ListName %in% c(Vital, "Observations", "Stade")]
        # --- Variables "vitales"
        if (length(Vital) > 0) {
          Test = ifelse(Test >= 2, Test, 2)
          cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                                paste0(Vital, 
                                       collapse = ", "))))

          df <-
            Cercles_temp %>%
            gather(var, value, Vital) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <- summaryBy(list(Vital, "NumForet"), data = Cercles_temp, FUN = function(x) length(which(is.na(x))), 
          #                 fun.names = "NbreVides")
          if (length(Vital) == 1) {
            df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
          }
          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Vital)) {
            df <- select(df, -NumForet)
          }
          names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
          print(xtable(df, 
                       caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                                   paste0(Vital, collapse = ", "), 
                                                   ", indispensables à l'analyse des données.}")), 
                       caption.placement = "bottom", 
                       digits = rep(0, ncol(df)+1), 
                       align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                       label = paste0("TabMissVital_Cercles", pop)), 
                include.rownames = FALSE, 
                include.colnames = TRUE, 
                hline.after = c(-1:nrow(df)), 
                size = "\\scriptsize")
          cat("
          ")
          # } else {
          #   ListDisp_Verif <- unique(df$NumForet)
          #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
          #
          #   Vector2Table_Print(ListDisp_Verif, 
          #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
          #                             paste0(Vital, collapse = ", "), 
          #                             ").")), 
          #                      "TabMissVital_Cercles")
          #   cat("
          #       ")
          # }
        } else {
          Vital <- c("NumForet", "NumPlac", "Cycle", "Population", 
                     "Essence", "Azimut", "Dist", "Diam")
          cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                                paste0(Vital, collapse = ", "), 
                                ")")))
        }
        # --- Variables "annexes"
        cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
        if (length(Annexe) > 0) {
          Test = ifelse(Test > 1, Test, 1)
          cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                                paste0(Annexe, 
                                       collapse = ", "))))

          df <-
            Cercles_temp %>%
            gather(var, value, Annexe) %>%
            mutate(var = paste0(var, ".NbreVides")) %>%
            group_by(NumForet, var) %>%
            summarise(value = length( which(is.na(value)) )) %>%
            ungroup() %>%
            spread(var, value, drop = F)
          # df <- summaryBy(list(Annexe, "NumForet"), data = Cercles_temp, FUN = function(x) length(which(is.na(x))), 
          #                 fun.names = "NbreVides")
          if (length(Annexe) == 1) {
            df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
          } else {
            df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
          }

          # Impression de la table
          # if (nrow(df) <= 20) {
          if (!is.element("NumForet", Annexe)) {
            df <- select(df, -NumForet)
          }
          names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
          print(xtable(df, 
                       caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                                   paste0(Vital, collapse = ", "), 
                                                   ", non indispensables dans l'analyse des données.}")), 
                       caption.placement = "bottom", 
                       digits = rep(0, ncol(df)+1), 
                       align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                       label = paste0("TabMissAnnexe_Cercles", pop)), 
                include.rownames = FALSE, 
                include.colnames = TRUE, 
                hline.after = c(-1:nrow(df)), 
                size = "\\scriptsize")
          cat("\\FloatBarrier
        ")
          # } else {
          #   ListDisp_Verif <- unique(df$NumForet)
          #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
          #
          #   Vector2Table_Print(ListDisp_Verif, 
          #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
          #                             paste0(Annexe, collapse = ", "), 
          #                             ").")), 
          #                      "TabMissAnnexe_Cercles")
          #   cat("
          #       ")
          # }
        } else {
          Vital <- c("NumForet", "NumPlac", "Cycle", "Population", 
                     "Essence", "Azimut", "Dist", "Diam")
          Annexe <- names(Cercles_temp)[!names(Cercles_temp) %in% c(Vital, "Observations")]
          cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                                paste0(Annexe, collapse = ", "), 
                                ")")))
        }
      } else {
        cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'Cercles' pour la population ", pop))
      }


      # Test si BMP : Type et Haut - mettre aussi tests sur StadeD et StadeE ?
      if (pop == "BMP") {
        # ---------- Incohérence type de BMP et Haut ---------- #
        if (length(which(!is.na(Cercles_temp$Type))) > 0) {
          cat(utf82LaTeX("\\subsubsection{Contrôle incohérences sur les données de bois mort sur pied et de taillis}"))
          # ----- Contrôle des types de bois mort sur pied :
          cat(utf82LaTeX("\\paragraph{BMP : Contrôle des types de bois mort sur pied}"))
          pos <- which(!is.na(Cercles_temp$Type) & !Cercles_temp$Type %in% CodeTypoArbres$Code)
          if (length(pos) > 0) {
            Test <- ifelse(Test > 1, Test, 2)
            cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des types de bois mort sur pied non reconnus\\\\
                                  Rappel : les seuls types reconnus sont '", paste0(CodeTypoArbres$Code, collapse = "', '"), "' (respectivement '", paste0(CodeTypoArbres$Descriptif, collapse = "', '"), "').\\\\", length(pos), " valeur(s) non reconnue(s)"))
            if (length(pos) < 5) {
              cat(": '", Cercles_temp$Type[pos], "'")
            }
          } else {
            cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les types de bois mort sur pied sont reconnus.\\\\

")))
          }

          cat(utf82LaTeX("\\paragraph{BMP : Souches > 1, 30m}"))
          pos <- which(Cercles_temp$Haut > 1.30 & Cercles_temp$Type == "S")
          if (length(pos) > 0) {
            Test = ifelse(Test >= 2, Test, 2)
            if (length(pos) <= 20) {
              # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans le PSDRF :"))
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant strictement plus d'1, 30m. Impossible dans cette table :"))
              df <- Cercles_temp[pos, c("NumForet", "NumPlac", "Cycle", "Population", "Diam", "Haut", "Type")]
              print(xtable(df, 
                           caption = "\\footnotesize{Liste des BMP classés en souche et faisant plus d'1, 30m (Impossible dans cette table)}", 
                           caption.placement = "bottom", 
                           digits = c(rep(0, ncol(df)-1), 1, 0), 
                           align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                           label = "TabBMP-1"), 
                    include.rownames = FALSE, 
                    include.colnames = TRUE, 
                    hline.after = c(-1:nrow(df)), 
                    size = "\\scriptsize")
              cat("\\FloatBarrier
        ")

            } else {
              # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans le PSDRF :"))
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans cette table : ", length(pos), " erreurs détectées."))
              # cat(paste0("Dispositifs concernés : ", paste0(unique(Arbres$NumForet[pos]), collapse = ", ")))

              # ListDisp_Verif <- unique(Arbres$NumForet[pos])
              # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
              #
              # Vector2Table_Print(ListDisp_Verif, 
              #                    "Liste des dispositifs ayant des BMP de plus d'1, 30m classés en 'Souche' (Impossible dans le PSDRF)", 
              #                    "TabBMP-1")
              cat("\\FloatBarrier
        ")
            }
          } else {
            cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de plus d'1, 30m classé en 'Souche' dans la table.\\\\"))
          }

          cat(utf82LaTeX("\\paragraph{BMP : Arbres ou chandelles < 1, 30m}"))
          pos <- which(Cercles_temp$Haut < 1.30 & Cercles_temp$Type != "S")
          if (length(pos) > 0) {
            Test = ifelse(Test >= 2, Test, 2)
            if (length(pos) <= 20) {
              # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans le PSDRF\\\\"))
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table :"))
              # cat(utf82LaTeX(paste0("Dispositifs concernés :", 
              #                       paste0(unique(Arbres$NumForet[pos]), collapse = ", "), 
              #                       ".\\\\")))
              df <- Cercles_temp[pos, c("NumForet", "NumPlac", "Cycle", "Population", "Diam", "Haut", "Type")]
              print(xtable(df, 
                           caption = "\\footnotesize{Liste des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m (Impossible dans cette table)}", 
                           caption.placement = "bottom", 
                           digits = rep(0, ncol(df)+1), 
                           align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                           label = "TabBMP-2"), 
                    include.rownames = FALSE, 
                    include.colnames = TRUE, 
                    hline.after = c(-1:nrow(df)), 
                    size = "\\scriptsize")
            } else {
              # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans le PSDRF\\\\ "))
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Arbre' ou en 'Chandelle' et faisant moins d'1, 30m. Impossible dans cette table : ", length(pos), " erreurs détectées."))
              # cat(paste0("Dispositifs concernés : ", paste0(unique(Arbres$NumForet[pos]), collapse = ", ")))

              # ListDisp_Verif <- unique(Arbres$NumForet[pos])
              # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
              #
              # Vector2Table_Print(ListDisp_Verif, 
              #                    "Liste des dispositifs ayant des BMP de moins d'1, 30m et classés en 'Arbre' ou en 'Chandelle' (Impossible dans le PSDRF)", 
              #                    "TabBMP-2")
              cat("\\FloatBarrier
        ")
            }
          } else {
            cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun BMP de moins d'1, 30m classé en 'Arbre' ou en 'Chandelle' dans la table.\\\\"))
          }

          # Incohérences sur les données Type - Haut - StadeD - StadeE des BMP :
          cat(utf82LaTeX("\\paragraph{Incohérences entre les colonnes Type - Haut - Stade}"))
          cat(utf82LaTeX("\\textit{Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}\\\\

               "))
          ListDisp_Verif <- c()
          pos_BM <- which(!is.na(Cercles_temp$Type) |
                            # (!is.na(Cercles_temp$Haut) & Cercles_temp$Type != 1) |
                            !is.na(Cercles_temp$Haut) |
                            !is.na(Cercles_temp$Stade))
          BMP_Temp <- Cercles_temp[pos_BM, ]
          pos <- c()
          for (name in c("Type", "Haut", "Stade")) {
            if (name == "Haut") {
              pos <- unique(c(pos, which(is.na(BMP_Temp[, name]) &
                                          BMP_Temp$Type != 1)))
            } else {
              pos <- unique(c(pos, which(is.na(BMP_Temp[, name]))))
            }
          }

          if (length(pos) > 0) {
            Test = ifelse(Test >= 2, Test, 2)
            if (length(pos) <= 20) {
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des informations manquantes pour les BMP :"))
              # cat(Arbres[pos, c("NumForet", "NumPlac", "NumArbre", "Cycle", "Diam1", "Diam2", "Type")], "\\\\")
              df <- BMP_Temp[pos, c("NumForet", "NumPlac", "Cycle", "Population", "Diam", "Haut", "Type")]
              print(xtable(df, 
                           caption = "\\footnotesize{Liste des BMP pour lesquels il manque des informations}", 
                           caption.placement = "bottom", 
                           digits = rep(0, ncol(df)+1), 
                           align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df)-1)), 
                           label = "TabMissBMP"), 
                    include.rownames = FALSE, 
                    include.colnames = TRUE, 
                    hline.after = c(-1:nrow(df)), 
                    size = "\\scriptsize")
            } else {
              cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des informations manquantes pour les BMP (Type - Haut - Stade) : ", length(pos), " manques détectés."))
              #, 
              # paste0(unique(Arbres$NumForet[pos]), collapse = ", "), 
              # ".\\\\")))
              # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
              #
              # Vector2Table_Print(ListDisp_Verif, 
              #                    "Liste des dispositifs ayant des informations manquantes pour les BMP", 
              #                    "TabMissBMP")
            }
          } else {
            cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucune incohérence entre les colonnes Type - Haut - Stade pour les BMP\\\\"))
          }
        }
      }


    } else {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Nom de population incorrect. Rappel : 'BMP' et 'Taillis' sont les seules populations admises\\\\")
    }
  }
  cat("\\end{itemize}")















  # ListName <- c()
  # for (name in names(Cercles)) {
  #   pos <- which(is.na(Cercles[, name]))
  #   if (length(pos) > 0) {ListName <- c(ListName, name)}
  # }
  # Vital <- c()
  # Annexe <- c()
  # cat("\\textcolor{red}{rajouter 'si BMP, alors il faut Haut et Type + contrôle des populations, + contrôle des types'}\\\\")
  # if (length(pos) > 0) { # éventuellement : rajouter "si BMP, alors il faut Haut et Type + contrôle des populations, + contrôle des types
  #   Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "Cycle", "Population", "Quart", 
  #                                     "Essence", "Azimut", "Dist", "Diam")]
  #   Annexe <- ListName[!ListName %in% c(Vital, "Observations")]
  #   # --- Variables "vitales"
  #   if (length(Vital) > 0) {
  #     Test = ifelse(Test >= 2, Test, 2)
  #     cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
  #                           paste0(Vital, 
  #                                  collapse = ", "))))
  #     df <- summaryBy(list(Vital, "NumForet"), data = Cercles, FUN = function(x) length(which(is.na(x))), 
  #                     fun.names = "NbreVides")
  #     if (length(Vital) == 1) {
  #       df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
  #     } else {
  #       df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
  #     }
  #     # Impression de la table
  #     # if (nrow(df) <= 20) {
  #     if (!is.element("NumForet", Vital)) {
  #       df <- select(df, -NumForet)
  #     }
  #     names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
  #     print(xtable(df, 
  #                  caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
  #                                              paste0(Vital, collapse = ", "), 
  #                                              ", indispensables à l'analyse des données.}")), 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
  #                  label = "TabMissVital_Cercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("
  #         ")
  #     # } else {
  #     #   ListDisp_Verif <- unique(df$NumForet)
  #     #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     #   Vector2Table_Print(ListDisp_Verif, 
  #     #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
  #     #                             paste0(Vital, collapse = ", "), 
  #     #                             ").")), 
  #     #                      "TabMissVital_Cercles")
  #     #   cat("
  #     #       ")
  #     # }
  #   } else {
  #     Vital <- c("NumForet", "NumPlac", "Cycle", "Population", "Quart", 
  #                "Essence", "Azimut", "Dist", "Diam")
  #     cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
  #                           paste0(Vital, collapse = ", "), 
  #                           ")")))
  #   }
  #   # --- Variables "annexes"
  #   cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
  #   if (length(Annexe) > 0) {
  #     Test = ifelse(Test > 1, Test, 1)
  #     cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
  #                           paste0(Annexe, 
  #                                  collapse = ", "))))
  #     df <- summaryBy(list(Annexe, "NumForet"), data = Cercles, FUN = function(x) length(which(is.na(x))), 
  #                     fun.names = "NbreVides")
  #     if (length(Annexe) == 1) {
  #       df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
  #     } else {
  #       df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
  #     }
  #
  #     # Impression de la table
  #     # if (nrow(df) <= 20) {
  #     if (!is.element("NumForet", Annexe)) {
  #       df <- select(df, -NumForet)
  #     }
  #     names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
  #     print(xtable(df, 
  #                  caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
  #                                              paste0(Vital, collapse = ", "), 
  #                                              ", non indispensables dans l'analyse des données.}")), 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
  #                  label = "TabMissAnnexe_Cercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #       ")
  #     # } else {
  #     #   ListDisp_Verif <- unique(df$NumForet)
  #     #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     #   Vector2Table_Print(ListDisp_Verif, 
  #     #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
  #     #                             paste0(Annexe, collapse = ", "), 
  #     #                             ").")), 
  #     #                      "TabMissAnnexe_Cercles")
  #     #   cat("
  #     #       ")
  #     # }
  #   } else {
  #     Vital <- c("NumForet", "NumPlac", "Cycle", "Population", "Quart", 
  #                "Essence", "Azimut", "Dist", "Diam")
  #     Annexe <- names(Cercles)[!names(Cercles) %in% c(Vital, "Observations")]
  #     cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
  #                           paste0(Annexe, collapse = ", "), 
  #                           ")")))
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table"))
  # }



  # # --- Sécurité duplicata
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  # pos <- which(duplicated(Cercles))
  # if (length(pos) > 0) {
  #   if (length(pos) <= 20) {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Cercles :"))
  #     t <- Cercles[pos, c("NumForet", "NumPlac", "Id", "Cycle", 
  #                         "Essence", "Cercles", "Dist")]
  #     # t
  #     print(xtable(t, 
  #                  caption = "Doublons détectés dans la table 'Cercles'", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, dim(t)[2]+1), 
  #                  align = c("l", "|M{2.5cm}|", rep("M{2.5cm}|", dim(t)[2]-1)), 
  #                  label = "TabDupl_Cercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:dim(t)[1]), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Cercles pour les dispositifs :"))
  #     ListDisp_Verif <- unique(Cercles$NumForet[pos])
  #     ListDisp_Verif <- paste0(ListDisp_Verif, "-", Cercles$Nom[match(ListDisp_Verif, Cercles$NumForet)])
  #
  #     Vector2Table_Print(ListDisp_Verif, 
  #                        "Liste des dispositifs de la base PSDRF ayant des doublons dans la table Cercles", 
  #                        "TabDupl_Cercles")
  #
  #     cat("\\FloatBarrier
  #         ")
  #   }
  # }

  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Cercles <- arrange(Cercles, 
                     NumForet, NumPlac, Cycle, Population)
  pos1 <- which(duplicated(Cercles))
  pos2 <- which(duplicated(Cercles, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'Cercles': \\\\")
      df <- Cercles[Dupl, c("NumForet", "NumPlac", "Cycle", "Population", 
                           "Essence", "Azimut", "Dist")]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'Cercles'}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_Cercles"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'Cercles' : ", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(sort(unique(Cercles$NumPlac[Dupl])), collapse = ", "), ".")))
      #, paste0(unique(Cercles$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Cercles$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Cercles", 
      #                    "TabDoublon_Cercles")
      # cat("\\FloatBarrier
      #     ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\

      ")
  }


  # ---------- Contrôle des valeurs d'angle (≤ 50) : ---------- #
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs d'angle}"))
  # Cercles <- arrange(Cercles, 
  #                     NumForet, NumPlac, Id, Cycle, Angle)
  # pos <- which(Cercles$Angle > 50)
  #
  #
  # if (length(pos) > 0) {
  #   Test = ifelse(Test >= 2, Test, 2)
  #   if (length(pos) <= 20) {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table 'Cercles' : \\\\")
  #     df <- Cercles[pos, c("NumForet", "NumPlac", "Id", "Cycle", "Essence", "Cercles", "Dist", "Angle")]
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Liste des angles > 50°  dans la table 'Cercles'}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
  #                  label = "TabAngle_Cercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table : ", 
  #                           length(pos), 
  #                           " élément(s) détecté(s) sur les placettes \\\\", 
  #         paste0(sort(unique(Cercles$NumPlac[pos])), collapse = ", "))))
  #     #, paste0(unique(Cercles$NumForet[Dupl]), collapse = ", "))))
  #     # ListDisp_Verif <- unique(Cercles$NumForet[Dupl])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Cercles", 
  #     #                    "TabDoublon_Cercles")
  #     # cat("\\FloatBarrier
  #     #     ")
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun angle > 50°  détecté dans la table\\\\
  #
  #       "))
  # }














  # Contrôle des Essences de Cercles :
  # cat(utf82LaTeX("\\subsubsection{Contrôle incohérences sur les listes d'essence}"))
  # ListEss <- setdiff(CodeEssence$Essence, unique(Cercles$Essence))
  # if (length(ListEss) > 0) {
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Certaines essences ne sont pas prises en compte dans la table 'Cercles' : "))
  #   Vector2Table_Print(ListEss, 
  #                      "Liste des essences de n'apparaissant pas dans la table 'Cercles'", 
  #                      "TabEss_Cercles")
  # }

  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@

<<Cercle_encorePLUSancien, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', eval = F, include = F>>=
Test = 0

if (dim(Cercles)[1] > 0) {
  ###### 1/ Présentation succincte des données #####
  cat(utf82LaTeX("\\paragraph{Présentation succincte des données}"))

  df <-
    Cercles %>%
    filter(
      Cercles$NumForet == forest_num & !is.na(Cercles$NumForet) &
        !is.na(Cercles$NumPlac) & !is.na(Cercles$Population)
    ) %>%
    distinct(NumForet, NumPlac, Population)
  # --- 1.1/ Nombre d'éléments de BMP
  pos <- which(Cercles$Population == "BMP")
  cat(
    utf82LaTeX(
      "Nombre de BMP : (NumForet, NumPlac et Id non vides) : ", length(pos), "\\\\"
    )
  )
  pos <- which(Cercles$Population == "Taillis")
  cat(
    utf82LaTeX(
      "Nombre de Taillis : (NumForet, NumPlac et Id non vides) : ", nrow(df), "\\\\"
    )
  )
  pos <- which(Cercles$Population != "BMP" & Cercles$Population != "Taillis")
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    cat(
      utf82LaTeX(
        "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des populations non reconnues dans la feuille Cercle. Rappel  "
  }

  # --- 1.2/ Cycles inventoriés
  cat(
    utf82LaTeX(
      "La feuille Cercles contient des informations pour le(s) cycle(s) : ", 
      paste0(sort(unique(Cercles$Cycle)), collapse = ", "), "\\\\"
    )
  )
  # --- 1.3/ Dists
  cat(
    utf82LaTeX(
      "Valeurs extrêmes des distances : ", min(as.numeric(Cercles$Dist), na.rm = T), 
      "-", max(as.numeric(Cercles$Dist), na.rm = T), "\\\\"
    )
  )
  # --- 1.4/ Diamètres
  cat(
    utf82LaTeX(
      "Valeurs extrêmes des Diam : ", min(as.numeric(Cercles$Diam), na.rm = T), 
      "-", max(as.numeric(Cercles$Diam), na.rm = T), "\\\\

          "
    )
  )

  ##### 2/ Contrôle des essences inventoriées dans la table #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )
  Test <- Test + Controle_Essence(Cercles)
  cat("\\FloatBarrier ")

  ##### 3/ Stades de décomposition et d'écorce #####
  pos <- which(!is.na(Cercles$Stade))
  if (length(pos) > 0) {
    # --- 3.1/ Stades de décomposition
    cat(utf82LaTeX("\\subsubsection{Contrôle des stades de décomposition}"))

    Test <- Controle_Durete(CodeDurete, Cercles, Test)
    cat("\\FloatBarrier ")

    if (length(which(!is.na(Cercles$StadeD))) > 0) {
      cat(utf82LaTeX("\\FloatBarrier Fréquence des stades de décomposition :\\\\"))

      df_FreqStadeD <-
        data.frame(
          table(Cercles$StadeD), stringsAsFactors = F) %>%
        rename("Stade de\ndécomposition" = "Var1", "Occurence" = "Freq"
        )

      print(
        xtable(
          df_FreqStadeD, 
          digits = rep(0, dim(df_FreqStadeD)[2] + 1), 
          align = c(
            "l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeD)[2]-1)
          )
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        floating = F, 
        hline.after = c(-1:dim(df_FreqStadeD)[1]), 
        size = "\\scriptsize"
      )
    }

    # --- 3.2/ Stades écorce
    cat("\\subsubsection{Contrôle des stades d'écorce}")

    Test <- Controle_Ecorce(CodeEcorce, Cercles, Test)
    cat("\\FloatBarrier ")

    if (length(which(!is.na(Cercles$StadeE))) > 0) {
      cat(utf82LaTeX("Fréquence des stades d'écorce :\\\\"))

      df_FreqStadeE <-
        data.frame(table(Cercles$StadeE), stringsAsFactors = F) %>%
        rename("Stade écorce" = "Var1", "Occurence" = "Freq")

      print(
        xtable(
          df_FreqStadeE, 
          digits = rep(0, dim(df_FreqStadeE)[2] + 1), 
          align = c(
            "l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeE)[2] - 1))
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        floating = F, 
        hline.after = c(-1:dim(df_FreqStadeE)[1]), 
        size = "\\scriptsize"
      )
    }
  }

  ##### 4/ Contrôle des Cycles de Cercles #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des numéros d'inventaire (Cycles)}"))
  Test <- Test + ControlCycle(Cercles)

  ##### 5/ Contrôle des valeurs vides des variables #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  ListName <- c()
  for (name in names(Cercles)) {
    pos <- which(is.na(Cercles[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "Id", "Cycle", 
                                      "Essence", "Cercles", "Diam", #, "Dist"
                                      "Contact", "Angle", "Chablis", "StadeD", "StadeE")]
    Annexe <- ListName[!ListName %in% c(Vital, "Observations")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
          paste0(Vital, collapse = ", ")
        )
      )

      df <- summaryBy(list(Vital, "NumForet"), data = Cercles, FUN = function(x) length(which(is.na(x))), 
                      fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_Cercles"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                             paste0(Vital, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissVital_Cercles")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
                 "Essence", "Cercles", "Dist", "Diam", 
                 "Contact", "Angle", "Chablis", "StadeD", "StadeE")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), 
                            ")")))
    }
    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)
      cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Annexe, 
                                   collapse = ", "))))
      df <- summaryBy(list(Annexe, "NumForet"), data = Cercles, FUN = function(x) length(which(is.na(x))), 
                      fun.names = "NbreVides")
      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Annexe)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", non indispensables dans l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissAnnexe_Cercles"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
      #                             paste0(Annexe, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissAnnexe_Cercles")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
                 "Essence", "Cercles", "Dist", "Diam", 
                 "Contact", "Angle", "Chablis", "StadeD", "StadeE")
      Annexe <- names(Cercles)[!names(Cercles) %in% c(Vital, "Observations")]
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                            paste0(Annexe, collapse = ", "), 
                            ")")))
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table"))
  }



  # # --- Sécurité duplicata
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  # pos <- which(duplicated(Cercles))
  # if (length(pos) > 0) {
  #   if (length(pos) <= 20) {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Cercles :"))
  #     t <- Cercles[pos, c("NumForet", "NumPlac", "Id", "Cycle", 
  #                         "Essence", "Cercles", "Dist")]
  #     # t
  #     print(xtable(t, 
  #                  caption = "Doublons détectés dans la table 'Cercles'", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, dim(t)[2]+1), 
  #                  align = c("l", "|M{2.5cm}|", rep("M{2.5cm}|", dim(t)[2]-1)), 
  #                  label = "TabDupl_Cercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:dim(t)[1]), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Cercles pour les dispositifs :"))
  #     ListDisp_Verif <- unique(Cercles$NumForet[pos])
  #     ListDisp_Verif <- paste0(ListDisp_Verif, "-", Cercles$Nom[match(ListDisp_Verif, Cercles$NumForet)])
  #
  #     Vector2Table_Print(ListDisp_Verif, 
  #                        "Liste des dispositifs de la base PSDRF ayant des doublons dans la table Cercles", 
  #                        "TabDupl_Cercles")
  #
  #     cat("\\FloatBarrier
  #         ")
  #   }
  # }

  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Cercles <- arrange(Cercles, 
                     NumForet, NumPlac, Id, Cycle)
  pos1 <- which(duplicated(Cercles))
  pos2 <- which(duplicated(Cercles, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\")
      df <- Cercles[Dupl, c("NumForet", "NumPlac", "Id", "Cycle", "Essence", "Cercles", "Dist", "Angle")]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table 'Cercles'}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_Cercles"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(sort(unique(Cercles$NumPlac[Dupl])), collapse = ", "))))
      #, paste0(unique(Cercles$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Cercles$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Cercles", 
      #                    "TabDoublon_Cercles")
      # cat("\\FloatBarrier
      #     ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\

      ")
  }


  # ---------- Contrôle des valeurs d'angle (≤ 50) : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs d'angle}"))
  Cercles <- arrange(Cercles, 
                     NumForet, NumPlac, Id, Cycle, Angle)
  pos <- which(Cercles$Angle > 50)


  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(pos) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table : \\\\")
      df <- Cercles[pos, c("NumForet", "NumPlac", "Id", "Cycle", "Essence", "Cercles", "Dist", "Angle")]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des angles > 50°  dans la table 'Cercles'}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabAngle_Cercles"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table : ", 
                            length(pos), 
                            " élément(s) détecté(s) sur les placettes \\\\", 
                            paste0(sort(unique(Cercles$NumPlac[pos])), collapse = ", "))))
      #, paste0(unique(Cercles$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Cercles$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Cercles", 
      #                    "TabDoublon_Cercles")
      # cat("\\FloatBarrier
      #     ")
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun angle > 50°  détecté dans la table\\\\

      "))
  }














  # Contrôle des Essences de Cercles :
  # cat(utf82LaTeX("\\subsubsection{Contrôle incohérences sur les listes d'essence}"))
  # ListEss <- setdiff(CodeEssence$Essence, unique(Cercles$Essence))
  # if (length(ListEss) > 0) {
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Certaines essences ne sont pas prises en compte dans la table 'Cercles' : "))
  #   Vector2Table_Print(ListEss, 
  #                      "Liste des essences de n'apparaissant pas dans la table 'Cercles'", 
  #                      "TabEss_Cercles")
  # }

  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table BMSLineaire}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Attention : checker les angles (doivent être numériques) + les valeurs de contact et chablis (même si pas utilisés pour l'instant)}}{}
<<BMSLineaires, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(BMSLineaires)[1] > 0) {

  ##### 1/ Contrôle des essences inventoriées dans la table #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )
  cat("Les essences rencontrées dans la table 'BMSLineaire' de la forêt", 
      foret, 
      " sont listées dans le tableau \\ref{ListEssence_BMSLineaires}.\\\\"
  )
  Test <- Test + Controle_Essence(BMSLineaires)
  cat("\\FloatBarrier ")

  v <- unique(BMSLineaires$Essence)

  # Tableau listant les essences de l'inventaire (BMSLineaires) présentes (et figurant dans la liste des essences de la feuille Essences).
  pos <- which(!v %in% Essences$Nom)

  if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
    v_Error <- v[pos]
    v <- v[-pos]
  }

  # Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
  # v <- Essences$Code[match(v, Essences$Nom)]
  v <- sort(v)

  v <- paste0(Essences$Code[match(v, Essences$Nom)], " - ", 
              v, " - ", 
              Essences$Latin[match(v, Essences$Nom)])

  # Impression du tableau des essences
  Vector2Table_Print(
    v, 
    "Liste des essences rencontrées dans la table", 
    "ListEssence_BMSLineaires"
  )



  ##### 2/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(BMSLineaires, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")



  ##### 3/ Présentation succincte des données #####
  BMSLineaires <-
    BMSLineaires %>%
    mutate(
      StadeE = floor(Stade / 10), 
      StadeD = Stade - StadeE * 10
    )

  cat("\\paragraph{Présentation succincte des données}")
  cat(paste("Nombre de billons (NumForet, NumPlac et Transect non vides) sur l'ensemble des inventaires : ", 
            dim(distinct(BMSLineaires[BMSLineaires$NumForet == forest_num &
                                        !is.na(BMSLineaires$NumPlac) &
                                        !is.na(BMSLineaires$Transect), ], 
                         NumForet, NumPlac, Transect)
            )[1], "\\\\"))
  cat(paste0("La feuille BMSLineaire contient des informations pour le(s) cycle(s) : ", 
             paste0(sort(unique(BMSLineaires$Cycle)), collapse = ", "), "\\\\"))
  # cat(paste("Valeurs extrêmes des azimuts : ", min(as.numeric(BMSLineaires$Azimut), na.rm = T), "-", max(as.numeric(BMSLineaires$Azimut), na.rm = T), "\\\\"))
  # cat(paste("Valeurs extrêmes des distances : ", min(as.numeric(BMSLineaires$Dist), na.rm = T), "-", max(as.numeric(BMSLineaires$Dist), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des Diam : ", min(as.numeric(BMSLineaires$Diam), na.rm = T), "-", max(as.numeric(BMSLineaires$Diam), na.rm = T), "\\\\

          "))





  # Pas besoin de contrôler le NumForet puisque subset fait sur cette base

  # # --- Contrôle des NumForet de Dispositifs :
  # cat(utf82LaTeX("\\subsubsection{Contrôle des numéros de dispositif}"))
  # ListDisp_Verif <- unique(setdiff(Num, unique(Transect$NumForet)))
  # if (length(ListDisp_Verif) > 0) {
  # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Aucune donnée n'est renseignée dans la table 'Transect' pour le(s) dispositif(s) :"))
  #   Vector2Table_Print(ListDisp_Verif, # utf82LaTeX(
  #                      "Liste des dispositifs de la base PSDRF non renseignés dans la table 'Transect'.", 
  #                      "TabMiss1_Transect")
  #   cat("\\FloatBarrier
  #       ")
  # } else {
  #   cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les dispositifs indiqués dans la table 'Cycles' du fichier administrateur", 
  #              basename(file), 
  #              " ont été renseignés au moins une fois dans la table 'Transect' (classeur d'inventaire)\\\\")))
  # }

  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}"))
  Test <- Test + Controle_Essence(BMSLineaires)
  cat("\\FloatBarrier ")


  cat("\\subsubsection{Contrôle des stades de décomposition}")
  Test <- Controle_Durete(CodeDurete, BMSLineaires, Test)
  cat("\\FloatBarrier

    ")

  if (length(which(!is.na(BMSLineaires$StadeD))) > 0) {
    cat("Fréquence des stades de décomposition :\\\\")
    df_FreqStadeD <- data.frame(table(BMSLineaires$StadeD), stringsAsFactors = F) %>%
      rename("Stade de\ndécomposition" = "Var1", 
              "Occurence" = "Freq")
    print(xtable(df_FreqStadeD, 
                 digits = rep(0, dim(df_FreqStadeD)[2]+1), 
                 align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeD)[2]-1))), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          # floating = F, 
          hline.after = c(-1:dim(df_FreqStadeD)[1]), 
          size = "\\scriptsize")
  }


  cat("\\subsubsection{Contrôle des stades d'écorce}")
  Test <- Controle_Ecorce(CodeEcorce, BMSLineaires, Test)
  cat("\\FloatBarrier

    ")

  if (length(which(!is.na(BMSLineaires$StadeE))) > 0) {
    cat("Fréquence des stades d'écorce :\\\\")
    df_FreqStadeE <- data.frame(table(BMSLineaires$StadeE), stringsAsFactors = F) %>%
      rename("Stade écorce" = "Var1", 
              "Occurence" = "Freq")
    print(xtable(df_FreqStadeE, 
                 digits = rep(0, dim(df_FreqStadeE)[2]+1), 
                 align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeE)[2]-1))), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          # floating = F, 
          hline.after = c(-1:dim(df_FreqStadeE)[1]), 
          size = "\\scriptsize")
  }













  # cat("\\subsubsection{Contrôle des stades d'écorce}")
  # Test <- Controle_Ecorce(CodeEcorce, BMSLineaires, Test)
  # cat("\\FloatBarrier ")
  #
  # cat("\\subsubsection{Contrôle des stades de décomposition}")
  # Test <- Controle_Durete(CodeDurete, BMSLineaires, Test)
  # cat("\\FloatBarrier ")

  # ----- Contrôle des Cycles de BMSLineaires :
  cat(utf82LaTeX("\\subsubsection{Contrôle des numéros d'inventaire (Cycles)}"))
  Test <- Test + ControlCycle(BMSLineaires)


  # ----- Contrôle des valeurs vides des variables :
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  ListName <- c()
  for (name in names(BMSLineaires)) {
    pos <- which(is.na(BMSLineaires[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

if (Dev == T) {
  cat("\\textcolor{red}{Penser à une version où on peut savoir si on prend l'angle ou non (et dans ce cas mettre une inclinaiseon par défaut à 25 deg}\\\\

    ")
}
  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "Id", "Cycle", 
                                      "Transect", "Diam", #, "Dist", "Essence", "Contact", "Angle", "Chablis", 
                                      "Stade")]
    Annexe <- ListName[!ListName %in% c(Vital, "Observations", "StadeD", "StadeE")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        BMSLineaires %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = BMSLineaires, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_BMSLineaires"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                             paste0(Vital, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissVital_BMSLineaires")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
                 "Essence", "Transect", "Dist", "Diam", 
                 "Contact", "Angle", "Chablis", "Stade")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), 
                            ")")))
    }
    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)
      cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Annexe, 
                                   collapse = ", "))))

      df <-
        BMSLineaires %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Annexe, "NumForet"), data = BMSLineaires, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Annexe)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", non indispensables dans l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissAnnexe_BMSLineaires"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
      #                             paste0(Annexe, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissAnnexe_BMSLineaires")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
                 "Essence", "Transect", "Dist", "Diam", 
                 "Contact", "Angle", "Chablis", "Stade")
      Annexe <- names(BMSLineaires)[!names(BMSLineaires) %in% c(Vital, "Observations", "StadeD", "StadeE")]
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                            paste0(Annexe, collapse = ", "), 
                            ")")))
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table"))
  }



  # # --- Sécurité duplicata
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  # pos <- which(duplicated(BMSLineaires))
  # if (length(pos) > 0) {
  #   if (length(pos) <= 20) {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table BMSLineaires :"))
  #     t <- BMSLineaires[pos, c("NumForet", "NumPlac", "Id", "Cycle", 
  #                         "Essence", "Transect", "Dist")]
  #     # t
  #     print(xtable(t, 
  #                  caption = "Doublons détectés dans la table 'BMSLineaires'", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, dim(t)[2]+1), 
  #                  align = c("l", "|M{2.5cm}|", rep("M{2.5cm}|", dim(t)[2]-1)), 
  #                  label = "TabDupl_BMSLineaires"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:dim(t)[1]), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table BMSLineaires pour les dispositifs :"))
  #     ListDisp_Verif <- unique(BMSLineaires$NumForet[pos])
  #     ListDisp_Verif <- paste0(ListDisp_Verif, "-", BMSLineaires$Nom[match(ListDisp_Verif, BMSLineaires$NumForet)])
  #
  #     Vector2Table_Print(ListDisp_Verif, 
  #                        "Liste des dispositifs de la base PSDRF ayant des doublons dans la table BMSLineaires", 
  #                        "TabDupl_BMSLineaires")
  #
  #     cat("\\FloatBarrier
  #         ")
  #   }
  # }

  # ---------- Contrôle des valeurs dupliquées -> inutile dans PermGF : billons non identifiés ---------- #
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  # BMSLineaires <- arrange(BMSLineaires, 
  #                        NumForet, NumPlac, Cycle)
  # pos1 <- which(duplicated(BMSLineaires))
  # pos2 <- which(duplicated(BMSLineaires, fromLast = T))
  #
  # Dupl <- c()
  # if (length(pos1) > 0) {
  #   for (i in 1:length(pos1)) {
  #     Dupl <- c(Dupl, pos2[i]:pos1[i])
  #   }
  # }
  # if (length(Dupl) > 0) {
  #   Test = ifelse(Test >= 2, Test, 2)
  #   if (length(Dupl) <= 20) {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\")
  #     df <- BMSLineaires[Dupl, c("NumForet", "NumPlac", "Id", "Cycle", "Essence", "Transect", "Dist", "Angle")]
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Liste des doublons dans la table 'BMSLineaire'}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
  #                  label = "TabDoublon_BMSLineaires"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
  #                           length(Dupl), 
  #                           " doublons détectés sur les placettes \\\\", 
  #         paste0(sort(unique(BMSLineaires$NumPlac[Dupl])), collapse = ", "))))
  #     #, paste0(unique(BMSLineaires$NumForet[Dupl]), collapse = ", "))))
  #     # ListDisp_Verif <- unique(BMSLineaires$NumForet[Dupl])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table BMSLineaire", 
  #     #                    "TabDoublon_BMSLineaires")
  #     # cat("\\FloatBarrier
  #     #     ")
  #   }
  # } else {
  #   cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\
  #
  #       ")
  # }


  # ---------- Contrôle des valeurs d'angle (≤ 50) : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs d'angle}"))
  BMSLineaires <- arrange(BMSLineaires, 
                          NumForet, NumPlac, Cycle, Angle)
  pos <- which(BMSLineaires$Angle > 50)


  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(pos) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table : \\\\")
      df <- BMSLineaires[pos, c("NumForet", "NumPlac", "Cycle", "Essence", "Transect", "Angle")]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des angles > 50°  dans la table 'BMSLineaire'}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabAngle_BMSLineaires"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Angle(s) > 50°  dans la table : ", 
                            length(pos), 
                            " élément(s) détecté(s) sur les placettes \\\\", 
                            paste0(sort(unique(BMSLineaires$NumPlac[pos])), collapse = ", "))))
      #, paste0(unique(BMSLineaires$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(BMSLineaires$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table BMSLineaires", 
      #                    "TabDoublon_BMSLineaires")
      # cat("\\FloatBarrier
      #     ")
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun angle > 50°  détecté dans la table\\\\

      "))
  }














  # Contrôle des Essences de BMSLineaires :
  # cat(utf82LaTeX("\\subsubsection{Contrôle incohérences sur les listes d'essence}"))
  # ListEss <- setdiff(CodeEssence$Essence, unique(BMSLineaires$Essence))
  # if (length(ListEss) > 0) {
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Certaines essences ne sont pas prises en compte dans la table 'BMSLineaires' : "))
  #   Vector2Table_Print(ListEss, 
  #                      "Liste des essences de n'apparaissant pas dans la table 'BMSLineaires'", 
  #                      "TabEss_BMSLineaires")
  # }

  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table BMSCercle}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Pas grave si DiamMed == 0 et DiamIni et DiamFin renseignés ! Corriger correction en remarque + explication (ou alors changer le test : cas non géré = indiquer que si DiamIni renseigné et DiamFin, alors on sous-estime...\\}}{}
<<BMSCercles, , echo = F, comment = NA, warning = FALSE, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(BMSCercles)[1] > 0) {

  ##### 1/ Contrôle des essences inventoriées dans la table #####
  cat(
    utf82LaTeX(
      "\\subsubsection{Contrôle sur les essences inventoriées dans la table}"
    )
  )
  cat("Les essences rencontrées dans la table 'BMSCercle' de la forêt", 
      foret, 
      " sont listées dans le tableau \\ref{ListEssence_BMSCercles}.\\\\"
  )
  Test <- Test + Controle_Essence(BMSCercles)
  cat("\\FloatBarrier ")

  v <- unique(BMSCercles$Essence)

  # Tableau listant les essences de l'inventaire (BMSCercles) présentes (et figurant dans la liste des essences de la feuille Essences).
  pos <- which(!v %in% Essences$Nom)

  if (length(pos) > 0)  { # on élimine les essences de l'inventaire non répertoriées dans la feuille "Essences"
    v_Error <- v[pos]
    v <- v[-pos]
  }

  # Construit une liste : 'Code essence en 3 lettres' - 'nom vernaculaire' - 'nom latin'
  # v <- Essences$Code[match(v, Essences$Nom)]
  v <- sort(v)

  v <- paste0(Essences$Code[match(v, Essences$Nom)], " - ", 
              v, " - ", 
              Essences$Latin[match(v, Essences$Nom)])

  # Impression du tableau des essences
  Vector2Table_Print(
    v, 
    "Liste des essences rencontrées dans la table", 
    "ListEssence_BMSCercles"
  )



  ##### 2/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(BMSCercles, vect = c("NumForet", "NumPlac", "Cycle"))
  cat("\\FloatBarrier ")


  ##### 3/ Présentation succincte des données #####
  BMSCercles <-
    BMSCercles %>%
    mutate(
      StadeE = floor(Stade / 10), 
      StadeD = Stade - StadeE * 10
    )

  cat("\\paragraph{Présentation succincte des données}")
  df <-
    BMSCercles %>%
    filter(NumForet == forest_num & !is.na(NumForet) & !is.na(NumPlac)) %>%
    distinct(NumForet, NumPlac)

  cat(
    utf82LaTeX(
      "Nombre de billons (NumForet et NumPlac non vides) sur l'ensemble des inventaires : ", 
      nrow(df), "\\\\"
    )
  )
  cat(paste0("La feuille BMSCercles contient des informations pour le(s) cycle(s) : ", 
             paste0(sort(unique(BMSCercles$Cycle)), collapse = ", "), "\\\\"))
  # cat(paste("Valeurs extrêmes des azimuts : ", min(as.numeric(BMSCercles$Azimut), na.rm = T), "-", max(as.numeric(BMSCercles$Azimut), na.rm = T), "\\\\"))
  # cat(paste("Valeurs extrêmes des distances : ", min(as.numeric(BMSCercles$Dist), na.rm = T), "-", max(as.numeric(BMSCercles$Dist), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des DiamMed : ", min(as.numeric(BMSCercles$DiamMed), na.rm = T), "-", max(as.numeric(BMSCercles$DiamMed), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des DiamIni : ", min(as.numeric(BMSCercles$DiamIni), na.rm = T), "-", max(as.numeric(BMSCercles$DiamIni), na.rm = T), "\\\\"))
  cat(paste("Valeurs extrêmes des DiamFin : ", min(as.numeric(BMSCercles$DiamFin), na.rm = T), "-", max(as.numeric(BMSCercles$DiamFin), na.rm = T), "\\\\"))

  long_MAX <- max(as.numeric(BMSCercles$Longueur[BMSCercles$Cycle == cycle]), na.rm = T)
    if (long_MAX >= 20) {
      long_MAX <- paste0("\\textbf{\\textcolor{Red}{", long_MAX, "}}")}
    long_MIN <- min(as.numeric(BMSCercles$Longueur[BMSCercles$Cycle == cycle]), na.rm = T)
    if (long_MIN < 0 | long_MIN > 20) {
      long_MIN <- paste0("\\textbf{\\textcolor{Red}{", long_MIN, "}}")}
    if (long_MIN == 0) {
      long_MIN <- paste0("\\textbf{\\textcolor{Red}{", long_MIN, " !!}}")}
    cat(
      utf82LaTeX(
        "Valeurs extrêmes des longueurs de billon : ", 
        long_MIN, 
        "-", 
        long_MAX, 
        "\\\\"
      )
    )

  cat("\\subsubsection{Contrôle des stades de décomposition}")
  Test <- Controle_Durete(CodeDurete, BMSCercles, Test)
  cat("\\FloatBarrier ")

  if (length(which(!is.na(BMSCercles$StadeD))) > 0) {
    cat("\\FloatBarrier Fréquence des stades de décomposition :\\\\")
    df_FreqStadeD <- data.frame(table(BMSCercles$StadeD), stringsAsFactors = F) %>%
      rename("Stade de\ndécomposition" = "Var1", 
              "Occurence" = "Freq")
    print(xtable(df_FreqStadeD, 
                 digits = rep(0, dim(df_FreqStadeD)[2]+1), 
                 align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeD)[2]-1))), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:dim(df_FreqStadeD)[1]), 
          size = "\\scriptsize")
  }


  cat("\\subsubsection{Contrôle des stades d'écorce}")
  Test <- Controle_Ecorce(CodeEcorce, BMSCercles, Test)
  cat("\\FloatBarrier ")

  if (length(which(!is.na(BMSCercles$StadeE))) > 0) {
    cat("Fréquence des stades d'écorce :\\\\")
    df_FreqStadeE <- data.frame(table(BMSCercles$StadeE), stringsAsFactors = F) %>%
      rename("Stade écorce" = "Var1", 
              "Occurence" = "Freq")
    print(xtable(df_FreqStadeE, 
                 digits = rep(0, dim(df_FreqStadeE)[2]+1), 
                 align = c("l", "|M{1.7cm}|", rep("M{1.7cm}|", dim(df_FreqStadeE)[2]-1))), 
          include.rownames = FALSE, 
          include.colnames = TRUE, 
          hline.after = c(-1:dim(df_FreqStadeE)[1]), 
          size = "\\scriptsize")
  }











  # Pas besoin de contrôler le NumForet puisque subset fait sur cette base

  # # --- Contrôle des NumForet de BMSCercles :
  # cat(utf82LaTeX("\\subsubsection{Contrôle des numéros de dispositif}"))
  # ListDisp_Verif <- unique(setdiff(Num, unique(BMSCercles$NumForet)))
  # if (length(ListDisp_Verif) > 0) {
  # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #   cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Aucune donnée n'est renseignée dans la table 'BMSCercles' pour le(s) dispositif(s) :"))
  #   Vector2Table_Print(utf82LaTeX(ListDisp_Verif), # utf82LaTeX(
  #                      "Liste des dispositifs de la base PSDRF n'ayant aucune information de renseignée dans la table 'BMSCercles'.", 
  #                      "TabMiss1_BMSCercles")
  #   cat("\\FloatBarrier
  #       ")
  # } else {
  #   cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les dispositifs indiqués dans la table 'Cycles' du fichier administrateur ", 
  #                  basename(file), 
  #                  " ont été renseignés au moins une fois dans la table 'BMSCercles' (classeur d'inventaire)\\\\")))
  # }


  # --- Contrôle des Cycles de BMSCercles :
  cat(utf82LaTeX("\\subsubsection{Contrôle des numéros d'inventaire (Cycles)}"))
  Test <- Test + ControlCycle(BMSCercles)


  # --- Repérages des vides
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  # Contrôle des valeurs vides des variables :
  ListName <- c()
  for (name in names(BMSCercles)) {
    pos <- which(is.na(BMSCercles[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <-
      ListName[ListName %in% c(
        "NumForet", "NumPlac", "Cycle", "Essence", "DiamMed", "Longueur"
      )] # "Azimut", "Dist", 
    Annexe <-
      ListName[!ListName %in% c(Vital, "Observations", "StadeD", "StadeE")] # "Azimut", "Dist", 
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      # cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
      #            paste0(unique(Vital), 
      #                   collapse = ", "), 
      #            " dans les classeurs d'inventaire des dispositifs :")))
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        BMSCercles %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = BMSCercles, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données}")), 
                   caption.placement = "bottom", 
                   # caption.width = ".75\\textwidth", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_BMSCercles"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                                        paste0(Vital, collapse = ", "), 
      #                                        ").")), 
      #                      "TabMissVital_BMSCercles")
      #   cat("\\FloatBarrier
      #       ")
      # }
    } else {
      Vital <- c(
        "NumForet", "NumPlac", "Cycle", "Essence", "Azimut", "Dist", 
        "DiamMed", "Longueur"
      )
      cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                     paste0(Vital, collapse = ", "), ").\\\\"))
    }
    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)
      cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Annexe, 
                                   collapse = ", "))))

      df <-
        BMSCercles %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Annexe, "NumForet"), data = BMSCercles, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Annexe)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <-
        paste0(Annexe, " : nombre de vides")
      print(
        xtable(
          df, 
          caption = utf82LaTeX(
            "\\footnotesize{Vides constatés dans les variables ", 
            paste0(Annexe, collapse = ", "), 
            ", non indispensables dans l'analyse des données.}"
          ), 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissAnnexe_BMSCercles"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
      #                             paste0(Annexe, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissAnnexe_BMSCercles")
      #   cat("\\FloatBarrier
      #       ")
      # }
    } else {
      Vital <- c(
        "NumForet", "NumPlac", "Id", "Cycle", 
        "Essence", "Azimut", "Dist", "DiamMed", "Longueur"
      )
      Annexe <- names(BMSCercles)[!names(BMSCercles) %in% c(Vital, "Observations")]
      cat(
        utf82LaTeX(
          "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
          paste0(Annexe, collapse = ", "), ").\\\\"
        )
      )
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table.\\\\"))
  }

  # --- Sécurité duplicata -  inutile dans GF
  # cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées (NumForet-NumPlac-Cycle)}"))
  # df_Dupl <- arrange(BMSCercles, 
  #                     NumForet, NumPlac, Id, Cycle) %>%  #, NumArbre
  #   select(NumForet, NumPlac, Id, Cycle)
  # BMSCercles <- arrange(BMSCercles, 
  #                     NumForet, NumPlac, Id, Cycle) %>%  #, NumArbre
  #   mutate(NumPlac = as.character(NumPlac), 
  #          DiamIni = as.numeric(DiamIni), 
  #          DiamMed = as.numeric(DiamMed), 
  #          DiamFin = as.numeric(DiamFin))
  # pos1 <- which(duplicated(df_Dupl))
  # pos2 <- which(duplicated(df_Dupl, fromLast = T))
  #
  # Dupl <- c()
  # if (length(pos1) > 0) {
  #   for (i in 1:length(pos1)) {
  #     Dupl <- c(Dupl, pos2[i]:pos1[i])
  #   }
  # }
  # if (length(Dupl) > 0) {
  #   Test = ifelse(Test >= 2, Test, 2)
  #   if (length(Dupl) <= 20) {
  #     # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table BMSCercles :"))
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table :")
  #     df <- BMSCercles[pos, c("NumForet", "NumPlac", "Id", "NumArbre", "Cycle")]
  #     # t
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Doublons détectés dans la table 'BMSCercles'}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
  #                  label = "TabDupl_BMSCercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #         ")
  #   } else {
  #     # cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table BMSCercles pour les dispositifs :")))
  #     cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
  #                           length(Dupl), 
  #                           " doublons détectés sur les placettes \\\\", 
  #         paste0(sort(unique(BMSCercles$NumPlac[Dupl])), collapse = ", "))))
  #     # ListDisp_Verif <- unique(BMSCercles$NumForet[pos])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs de la base PSDRF ayant des doublons dans la table BMSCercles", 
  #     #                    "TabDupl_BMSCercles")
  #
  #     cat("\\FloatBarrier
  #         ")
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\"))
  #   }




  # ---------- Contrôle des diamètres : ---------- #
  # cat(utf82LaTeX("\\subsubsection{Contrôle des incohérences sur les diamètres : DiamIni, DiamMed, DiamFin < 30cm}"))
  # cat(utf82LaTeX("\\textit{Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}\\\\
  #
  #              "))
  # ----- Contrôle DiamFin > 30 :
  pos <-
    with(
      BMSCercles, 
      unique(c(
        which(DiamFin < 30 & DiamFin != 0), 
        which(DiamMed < 30 & DiamMed != 0), 
        which(DiamIni < 30 & DiamIni != 0)
      ))
    )
  # # ----- Contrôle DiamFin > 30 :
  # pos <- which(BMSCercles$DiamFin < 30 & BMSCercles$DiamFin != 0)
  # if (length(pos) > 0) {
  #   Test = ifelse(Test >= 2, Test, 2)
  #   if (length(pos) <= 20) {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Les billons suivants ont des valeurs de diamètre inférieures à 30 cm. Impossible dans cette table :")
  #     df <-
  #       BMSCercles[pos, c(
  #         "NumForet", "NumPlac", "Cycle", 
  #         "DiamIni", "DiamMed", "DiamFin", "Longueur"
  #       )]
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Billons pour lesquels au moins 1 diamètre est inférieur à 30 cm (impossible dans cette table)}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df)-1)), 
  #                  label = "TabDiam_BMSCercles"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #       ")
  #   } else {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des valeurs de diamètre inférieures à 30 cm. Impossible dans cette table : ", length(pos), " erreurs détectées")
  #     # ListDisp_Verif <- unique(BMSCercles$NumForet[pos])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs ayant des BMS de plus de 30cm dont le DiamFin est inférieur à 30cm (Impossible dans le PSDRF)", 
  #     #                    "TabDiamBMS-1")
  #     cat("\\FloatBarrier
  #       ")
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucun diamètre < 30cm dans la table"))
  # }
  # # ----- Contrôle DiamIni et DiamFin non vides pour les billons > 5m :
  # cat(utf82LaTeX("\\paragraph{Contrôle des incohérences : DiamIni, DiamMed et DiamFin non vides pour les billons > 5m}"))
  # pos <- which((is.na(BMSCercles$DiamIni) | is.na(BMSCercles$DiamMed) | is.na(BMSCercles$DiamFin)) & BMSCercles$Longueur >= 5)
  # if (length(pos) > 0) {
  #   Test = ifelse(Test >= 2, Test, 2)
  #   if (length(pos) <= 20) {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Valeurs manquantes dans 'DiamIni' ou 'DiamFin' pour des billons d'au moins 5 m de longueur. Impossible dans PermGF :")
  #     df <- BMSCercles[pos, c("NumForet", "NumPlac", "Cycle", 
  #                            "DiamIni", "DiamMed", "DiamFin", "Longueur")]
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Billons d'au moins 5m de longueur pour lesquels des valeurs de diamètre sont vides (impossible dans cette table)}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df)-1)), 
  #                  label = "TabDiam_BMSCerclesbis"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #       ")
  #   } else {
  #     cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - Valeurs de diamètre manquantes pour des billons d'au moins 5 m de longueur. Impossible dans PermGF : ", length(pos), " erreurs détectées")
  #     # ListDisp_Verif <- unique(BMSCercles$NumForet[pos])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs ayant des BMS de plus de 30cm, d'une longueur >= 5 m et dont le DiamIni ou le DiamFin sont manquants (Impossible dans le PSDRF)", 
  #     #                    "TabDiamBMS-2")
  #     cat("\\FloatBarrier
  #       ")
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur de diamètre vide pour des billons de longueur supérieure à 5m"))
  # }
  # # ----- Contrôle DiamIni vide ou DiamFin vides pour les billons < 5m :
  # cat(utf82LaTeX("\\paragraph{Contrôle des éléments inventoriés : DiamIni vide ou DiamFin renseignés pour les billons < 5m}"))
  # cat(utf82LaTeX("\\textit{Attention : il peut y avoir des espaces ( =  valeurs non vides) renseignés dans les colonnes testées, ce qui peut prêter à confusion (pas d'erreur visible). Bien nettoyer les cellules mentionnées dans ce cas.}\\\\
  #
  #              "))
  # pos <- which((!is.na(BMSCercles$DiamIni) | !is.na(BMSCercles$DiamFin)) &
  #                as.numeric(BMSCercles$Longueur) < 5)
  # if (length(pos) > 0) {
  #   Test = ifelse(Test >= 1, Test, 1)
  #   if (length(pos) <= 20) {
  #     cat("\\textcolor{Blue}{\\textbf{Remarque}} - Valeurs renseignées dans 'DiamIni' ou 'DiamFin' pour des billons de moins de 5 m de longueur. Non demandé dans cette table :")
  #     df <- BMSCercles[pos, c("NumForet", "NumPlac", "Cycle", 
  #                            "DiamIni", "DiamMed", "DiamFin", "Longueur")]
  #     print(xtable(df, 
  #                  caption = "\\footnotesize{Billons de moins 5m de longueur pour lesquels des valeurs de 'DiamIni' et/ou de 'DiamFin' sont renseignées (impossible dans cette table)}", 
  #                  caption.placement = "bottom", 
  #                  digits = rep(0, ncol(df)+1), 
  #                  align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df)-1)), 
  #                  label = "TabDiam_BMSCerclester"), 
  #           include.rownames = FALSE, 
  #           include.colnames = TRUE, 
  #           hline.after = c(-1:nrow(df)), 
  #           size = "\\scriptsize")
  #     cat("\\FloatBarrier
  #       ")
  #   } else {
  #     cat("\\textcolor{Blue}{\\textbf{Remarque}} - Valeurs renseignées dans 'DiamIni' ou 'DiamFin' pour des billons de moins de 5 m de longueur. Non demandé dans cette table : ", length(pos), " éléments détectés")
  #     # ListDisp_Verif <- unique(BMSCercles$NumForet[pos])
  #     # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
  #     #
  #     # Vector2Table_Print(ListDisp_Verif, 
  #     #                    "Liste des dispositifs ayant des BMS de plus de 30cm, d'une longueur < 5 m et dont le DiamIni ou le DiamFin sont renseignés (Impossible dans le PSDRF)", 
  #     #                    "TabDiamBMS-3")
  #     cat("\\FloatBarrier
  #       ")
  #   }
  # } else {
  #   cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucun valeur renseignée dans les colonnes DiamIni et DiamFin pour des billons de longueur inférieure à 5m"))
  # }
  # ----- Contrôle DiamIni > DiamMed > DiamFin :
  cat(utf82LaTeX("\\subsubsection{Contrôle des incohérences : DiamIni > DiamMed > DiamFin}"))
  pos <- with(BMSCercles, which(!(DiamIni > DiamMed & DiamMed > DiamFin)))
  if (length(pos) > 0) {
    Test = ifelse(Test >= 1, Test, 1)
    if (length(pos) <= 20) {
      cat("\\textcolor{Blue}{\\textbf{Remarque}} - Incohérence possible dans les diamètres des billons : certains ne respectent pas la logique 'DiamIni' > 'DiamMed' > 'DiamFin' :")
      df <- BMSCercles[pos, c("NumForet", "NumPlac", "Cycle", 
                             "DiamIni", "DiamMed", "DiamFin", "Longueur")]
      print(xtable(df, 
                   caption = "\\footnotesize{Billons pour lesquels la règle 'DiamIni' > 'DiamMed' > 'DiamFin' n'est pas respectée}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1cm}|", rep("M{1cm}|", ncol(df)-1)), 
                   label = "TabDiam_BMSCerclesquart"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat("\\textcolor{DarkViolet}{\\textbf{Attention}} - Incohérence possible dans les diamètres des billons : certains ne respectent pas la logique 'DiamIni' > 'DiamMed' > 'DiamFin' :", length(pos), " erreurs détectées")
      # ListDisp_Verif <- unique(BMSCercles$NumForet[pos])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs ayant des BMS pour lesquels la règle 'DiamIni' > 'DiamMed' > 'DiamFin' n'est pas respectée (Impossible dans le PSDRF)", 
      #                    "TabDiamBMS-4")
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La règle DiamIni > DiamMed > DiamFin est bien respectée"))
  }


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table Coords}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Cohérence avec les placettes des tables Placettes et Regroup ? contrôler que la forêt est bien dans les placettes !! - mettre même alarme que pour SIG}}{}
<<Coords, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(Coords)[1] > 0) {
  ##### 1/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(Coords)
  cat("\\FloatBarrier ")


  # ----- Contrôle des valeurs vides des variables :
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  # cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  ListName <- c()
  for (name in names(Coords)) {
    pos <- which(is.na(Coords[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c("NumForet", "NumPlac", "EPSG", "Xgps", "Ygps")]
    Annexe <- ListName[!ListName %in% c(Vital, "Observations")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        Coords %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = Coords, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_Coords"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                             paste0(Vital, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissVital_Coords")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "EPSG", "Xgps", "Ygps")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), 
                            ")")))
    }
    # # --- Variables "annexes"
    # cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    # if (length(Annexe) > 0) {
    #   Test = ifelse(Test > 1, Test, 1)
    #   cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
    #              paste0(Annexe, 
    #                     collapse = ", "))))
    #   df <- summaryBy(list(Annexe, "NumForet"), data = Coords, FUN = function(x) length(which(is.na(x))), 
    #                   fun.names = "NbreVides")
    #   if (length(Annexe) == 1) {
    #     df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
    #   } else {
    #     df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
    #   }
    #
    #   # Impression de la table
    #   # if (nrow(df) <= 20) {
    #         if (!is.element("NumForet", Annexe)) {
    #   df <- select(df, -NumForet)
    #   }
    #     names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
    #     print(xtable(df, 
    #                  caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
    #                                       paste0(Vital, collapse = ", "), 
    #                                       ", non indispensables dans l'analyse des données.}")), 
    #                  caption.placement = "bottom", 
    #                  digits = rep(0, ncol(df)+1), 
    #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
    #                  label = "TabMissAnnexe_Coords"), 
    #           include.rownames = FALSE, 
    #           include.colnames = TRUE, 
    #           hline.after = c(-1:nrow(df)), 
    #           size = "\\scriptsize")
    #     cat("\\FloatBarrier
    #       ")
    #   # } else {
    #   #   ListDisp_Verif <- unique(df$NumForet)
    #   #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
    #   #
    #   #   Vector2Table_Print(ListDisp_Verif, 
    #   #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
    #   #                             paste0(Annexe, collapse = ", "), 
    #   #                             ").")), 
    #   #                      "TabMissAnnexe_Coords")
    #   #   cat("
    #   #       ")
    #   # }
    # } else {
    #    Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
    #              "Essence", "Transect", "Dist", "Diam", 
    #              "Contact", "Angle", "Chablis", "StadeD", "StadeE")
    #   Annexe <- names(Coords)[!names(Coords) %in% c(Vital, "Observations")]
    #   cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
    #              paste0(Annexe, collapse = ", "), 
    #              ")")))
    # }
  } else {
    # cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table"))
    Vital <- c("NumForet", "NumPlac", "EPSG", "Xgps", "Ygps")
    cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                          paste0(Vital, collapse = ", "), 
                          ")")))
  }


  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Coords <- arrange(Coords, 
                    NumForet, NumPlac)
  pos1 <- which(duplicated(Coords))
  pos2 <- which(duplicated(Coords, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\")
      df <- Coords[Dupl, c("NumForet", "NumPlac", "EPSG", "Xgps", "Ygps", "Observations")]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table 'Coords'}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_Coords"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(sort(unique(Coords$NumPlac[Dupl])), collapse = ", "))))

    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table\\\\

      ")
  }


  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table Reperes}
<<Reperes, echo = FALSE, comment = NA, warning = FALSE, results = 'asis'>>=
Test = 0

if (dim(Reperes)[1] > 0) {
  # ----- Contrôle des valeurs vides des variables :
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  # cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  ListName <- c()
  for (name in names(Reperes)) {
    pos <- which(is.na(Reperes[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c(
      "NumForet", "NumPlac", "NumArbre", "Essence", "Azimut", "Dist"
      )]
    Annexe <- ListName[!ListName %in% c(Vital, "Observations")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        Reperes %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = Reperes, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_Reperes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                             paste0(Vital, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissVital_Reperes")
      #   cat("
      #       ")
      # }
    } else {
      Vital <- c("NumForet", "NumPlac", "NumPlac", "Essence", "Azimut", "Dist")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), 
                            ")")))
    }
    # # --- Variables "annexes"
    # cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    # if (length(Annexe) > 0) {
    #   Test = ifelse(Test > 1, Test, 1)
    #   cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
    #              paste0(Annexe, 
    #                     collapse = ", "))))
    #   df <- summaryBy(list(Annexe, "NumForet"), data = Reperes, FUN = function(x) length(which(is.na(x))), 
    #                   fun.names = "NbreVides")
    #   if (length(Annexe) == 1) {
    #     df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
    #   } else {
    #     df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
    #   }
    #
    #   # Impression de la table
    #   # if (nrow(df) <= 20) {
    #         if (!is.element("NumForet", Annexe)) {
    #   df <- select(df, -NumForet)
    #   }
    #     names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
    #     print(xtable(df, 
    #                  caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
    #                                       paste0(Vital, collapse = ", "), 
    #                                       ", non indispensables dans l'analyse des données.}")), 
    #                  caption.placement = "bottom", 
    #                  digits = rep(0, ncol(df)+1), 
    #                  align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
    #                  label = "TabMissAnnexe_Reperes"), 
    #           include.rownames = FALSE, 
    #           include.colnames = TRUE, 
    #           hline.after = c(-1:nrow(df)), 
    #           size = "\\scriptsize")
    #     cat("\\FloatBarrier
    #       ")
    #   # } else {
    #   #   ListDisp_Verif <- unique(df$NumForet)
    #   #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
    #   #
    #   #   Vector2Table_Print(ListDisp_Verif, 
    #   #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
    #   #                             paste0(Annexe, collapse = ", "), 
    #   #                             ").")), 
    #   #                      "TabMissAnnexe_Reperes")
    #   #   cat("
    #   #       ")
    #   # }
    # } else {
    #    Vital <- c("NumForet", "NumPlac", "Id", "Cycle", 
    #              "Essence", "Transect", "Dist", "Diam", 
    #              "Contact", "Angle", "Chablis", "StadeD", "StadeE")
    #   Annexe <- names(Reperes)[!names(Reperes) %in% c(Vital, "Observations")]
    #   cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
    #              paste0(Annexe, collapse = ", "), 
    #              ")")))
    # }
  } else {
    # cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table"))
    Vital <- c("NumForet", "NumPlac", "NumPlac", "Essence", "Azimut", "Dist")
    cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                          paste0(Vital, collapse = ", "), 
                          ")")))
  }


  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Reperes <- arrange(Reperes, 
                     NumForet, NumPlac, NumPlac, Essence, Azimut, Dist)
  pos1 <- which(duplicated(Reperes))
  pos2 <- which(duplicated(Reperes, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : \\\\")
      df <- Reperes[Dupl, ]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table Reperes}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_Reperes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(unique(Reperes$NumPlac[Dupl]), collapse = ", "))))
      #, paste0(unique(Reperes$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Reperes$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Reperes", 
      #                    "TabDoublon_Reperes")
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table.\\\\

      ")
  }





  ##### 2/ Contrôle de la cohérence entre les placettes de la table Placettes et les placettes des tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Cohérence de la liste des placettes avec la table 'Placettes'}"))

  Test <- miss_plot(Reperes, vect = c("NumForet", "NumPlac"))
  cat("\\FloatBarrier ")







  ##### Fin #####
  if (Test == 0) {
    cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")
  }
  if (Test == 1) {
    cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")
  }
  if (Test >= 2) {
    cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")
  }
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier
\clearpage

% \section{Autres tables}
% \subsection{Table attributaire du fichier SIG de localisation des placettes}
<<Shapes, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', include = F, eval = F>>=
if (dim(Coords)[1] > 0) {
  Test = 0
  # SIG <- Placettes_SHP %>%
  #   st_set_geometry(NULL)
  SIG <- Coords
  # ---------- Contrôle des valeurs vides des variables : ---------- #
  # --- Repérages des vides
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  # Contrôle des valeurs vides des variables :
  ListName <- c()
  for (name in names(SIG)) {
    pos <- which(is.na(SIG[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()

  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c("NumForet", "NumPlac")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        Placettes %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = Placettes, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX("\\footnotesize{Vides constatés dans les variables ", 
                                        paste0(Vital, collapse = ", "), 
                                        ", indispensables à l'analyse des données.}"), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_Placettes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
          ")
    } else {
      Vital <- c("NumForet", "NumPlac", "Cycle", "Strate", "PoidsPlacette")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), ")")))
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table attributaire des données SIG."))
  }















  # --- Contrôler cohérence NumForet avec les tables : Arbres, BMSsup30, Referents?, Reges, Transect et Cycles
  cat(utf82LaTeX("\\subsubsection{Contrôle cohérence liste des placettes entre les tables}"))
  Miss2 <- function(Table) {
    if (dim(Table)[1] > 0) {
      temp1 <- distinct(Table, 
                        # one_of("NumForet", "NumPlac", "Cycle"), 
                        NumForet, NumPlac)
      temp1$Corresp1 <- 1
      temp2 <- Placettes[, c("NumForet", "NumPlac")]
      temp2$Corresp2 <- 2
      temp3 <- full_join(temp1, temp2, all = T, 
                         by = c("NumForet" = "NumForet", 
                              "NumPlac" = "NumPlac"))
      temp3 <- temp3[which(is.na(temp3$Corresp1) | is.na(temp3$Corresp2)), ]

      List1 <- which(is.na(temp3$Corresp1))
      List2 <- which(is.na(temp3$Corresp2))

      if (length(List2) > 0) {
        if (length(List2) <= 20) {
          Test <- ifelse(Test >= 2, Test, 2)
          cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers inventaires : un/des numéro(s) de placette(s) figure(nt) dans la table ", 
                                deparse(substitute(Table)), 
                                " mais ne figure(nt) pas dans la table Placettes\\\\")))

          t <- distinct(temp3[List2, ], 
                        NumForet, NumPlac) %>%
            group_by(NumForet) %>%
            mutate(NbrePlac = length(NumPlac)) %>%
            ungroup() %>%
            select(NumForet, NumPlac)

          print(xtable(t, 
                       caption = utf82LaTeX(paste0("\\footnotesize{Liste des placettes renseignées dans la table ", 
                                                   deparse(substitute(Table)), 
                                                   " mais ne figurant pas dans la table Placettes.}")), 
                       caption.placement = "bottom", 
                       digits = rep(0, dim(t)[2]+1), 
                       align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2]-1)), 
                       label = paste0("TabMiss2_", deparse(substitute(Table)), "Placettes")), 
                include.rownames = FALSE, 
                include.colnames = TRUE, 
                hline.after = c(-1:dim(t)[1]), 
                size = "\\scriptsize")
          cat("\\FloatBarrier
            ")
        } else {
          cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table ", 
                                deparse(substitute(Table)), 
                                " mais pas dans la table Placettes : ", 
                                length(List2), " erreurs détectées\\\\")))
          # ListDisp_Verif <- unique(temp3$NumForet[List2])
          # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
          # Vector2Table_Print(ListDisp_Verif, 
          #                    paste0("Liste des dispositifs de la base PSDRF ayant des placettes renseignées dans la table", 
          #                           deparse(substitute(Table)), 
          #                           "mais pas dans la table Placettes."), 
          #                    paste0("TabMiss2_", deparse(substitute(Table)), "Placettes"))
        }
      }
      if (length(List1) > 0) {
        if (length(List1) <= 20) {
          if (deparse(substitute(Table)) == "Cycles") {
            Test <- ifelse(Test >= 2, Test, 2)
            cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table Placettes mais ne figure(nt) pas dans la table Cycles : \\\\")))
          } else {
            Test <- ifelse(Test > 0, Test, 1)
            cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table Placettes mais ne figure(nt) pas dans la table ", 
                                  deparse(substitute(Table)), 
                                  " : \\\\")))
          }
          t <- distinct(temp3[List1, ], 
                        NumForet, NumPlac) %>%
            group_by(NumForet) %>%
            mutate(NbrePlac = length(NumPlac)) %>%
            ungroup() %>%
            select(NumForet, NumPlac)

          print(xtable(t, 
                       caption = utf82LaTeX(paste0("\\footnotesize{Liste des placettes renseignées dans la table Placettes mais ne figurant pas dans la table ", 
                                                   deparse(substitute(Table)), ".}")), 
                       caption.placement = "bottom", 
                       digits = rep(0, dim(t)[2]+1), 
                       align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", dim(t)[2]-1)), 
                       label = paste0("TabMiss3_", deparse(substitute(Table)), "Placettes")), 
                include.rownames = FALSE, 
                include.colnames = TRUE, 
                hline.after = c(-1:dim(t)[1]), 
                size = "\\scriptsize")
          cat("\\FloatBarrier
            ")
        } else {
          if (deparse(substitute(Table)) == "Cycles") {
            Test <- ifelse(Test >= 2, Test, 2)
            cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table Placettes mais ne figure(nt) pas dans la table Cycles : ", 
                                  length(List1), " erreurs détectées\\\\")))
          } else {
            Test <- ifelse(Test > 0, Test, 1)
            cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Fichiers d'inventaire : un/des numéro(s) de placette(s) figure(nt) dans la table Placettes mais ne figure(nt) pas dans la table ", 
                                  deparse(substitute(Table)), 
                                  " : ", length(List1), " éléments détectés\\\\")))
          }
          # ListDisp_Verif <- unique(temp3$NumForet[List1])
          # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
          # Vector2Table_Print(ListDisp_Verif, 
          #                    paste0("Liste des dispositifs de la base PSDRF ayant des placettes renseignées dans la table Placettes mais pas dans la table ", 
          #                           deparse(substitute(Table)), 
          #                           " des fichiers d'inventaire."), 
          #                    paste0("TabMiss3_", deparse(substitute(Table)), "Placettes"))
        }
      }
      if (length(List1) == 0 & length(List2) == 0) {
        cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table '", 
                              deparse(substitute(Table)), 
                              "' et la table 'Placettes' sont cohérentes.")))
      }
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table ", deparse(substitute(Table)), " est vide.")))
    }
    return(Test)
  }

  cat("\\paragraph{Cohérence placettes de la feuille 'Coords' / placettes de la feuille 'Placettes'}")
  Test <- Miss2(SIG)
  cat("\\FloatBarrier ")


  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  SIG <- arrange(SIG, 
                 NumForet, NumPlac)
  pos1 <- which(duplicated(SIG))
  pos2 <- which(duplicated(SIG, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ")
      df <- SIG[Dupl, ]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table SIG}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_SIG"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
                            length(Dupl), 
                            " doublons détectés sur les placettes \\\\", 
                            paste0(sort(unique(SIG$NumPlac[Dupl])), collapse = ", "))))
      #, paste0(unique(Placettes$NumForet[Dupl]), collapse = ", "))))
      # ListDisp_Verif <- unique(Placettes$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Placettes", 
      #                    "TabDoublon_Placettes")
      cat("\\FloatBarrier
        ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table.\\\\

      ")
  }






  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat(utf82LaTeX("\\textcolor{Blue}{\\textbf{Remarque}} - Pas de données SIG disponibles pour le dispositif."))
}
@
\FloatBarrier

\section{Conformité avec les codifications}

\subsection{Table Qual}
<<Quals, , echo = F, comment = NA, warning = FALSE, results = 'asis'>>=
Test = 0

if (dim(Quals)[1] > 0) {
  # Sécurité duplicata
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  pos <- which(duplicated(Quals))
  if (length(pos) > 0) {
    cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Quals ligne(s) :", 
                          paste0(pos, collapse = ", "))))
    #   t <- pander(Quals[pos, ])
    #     row.names(t) <- NULL
    #   panderOptions('table.split.cells', 10)
    #   panderOptions('table.split.table', 100)
    #
    #   return(pander(t))
    t <- Quals[pos, ]
    t
    cat("\\FloatBarrier
      ")
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table Qual\\\\

                 "))
  }

  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
  print(xtable(Quals, 
               caption = utf82LaTeX(paste0("\\footnotesize{Notations de la feuille Qual.}")), 
               caption.placement = "bottom", 
               digits = rep(0, dim(Quals)[2]+1), 
               align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", dim(Quals)[2]-1)), 
               label = "TabMissVital_Forets"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:dim(Quals)[1]), 
        size = "\\scriptsize")
} else {
  cat("\\begin{center}
\\textcolor{DarkViolet}{\\textbf{Attention} - Aucune donnée renseignée}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table Tiers}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Vérifier la définition des types dans la feuille Listes}}{}
<<Tiers, results = 'asis', eval = T, include = T>>=

if (nrow(Tiers) > 0) {
  Test = 0

  ##### 1/ Contrôle des valeurs vides des variables #####
  pos <- c()
  for (name in c("Nom", "Prenom", "Adresse1", "Type")) {
    pos <- unique(c(pos, which(is.na(Tiers[, name]))))
  }

  if (length(pos) > 0) {
  cat(
      utf82LaTeX(
        "\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) dans les colonnes 'Nom', 'Prénom', 'Adresse1' et/ou 'Type' de la table 'Tiers'."
      )
    )
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les colonnes 'Nom', 'Prénom', 'Adresse1' et 'Type' de la table 'Tiers'."
      )
    )
  }


  ##### 2/ Contrôle des valeurs dupliquées #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Tiers <- Tiers %>% arrange(Nom, Prenom, Type)
  pos1 <- which(duplicated(Tiers))
  pos2 <- which(duplicated(Tiers, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Information dupliquée dans la table 'Tiers' :"
        )
      )
      df <- Tiers[Dupl, c("Nom", "Pr\u00E9nom", "Type")]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'Tiers'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df)+1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_Tiers"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
          length(Dupl), " doublons détectés."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'Tiers'."
      )
    )
  }


  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{Blue}{\\textbf{Remarque}} - Aucune information renseignée dans la table 'Tiers'."
    )
  )
}


@
\FloatBarrier

\subsection{Table Essences}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Faire le contrôle qu'il n'y a pas de doublons sur la colonne EssReg}}{}
<<Essences, echo = FALSE, comment = NA, warning = FALSE, results = 'asis'>>=
Test = 0
Essences <- Essences %>% filter(NumForet == forest_num)
##### 1/ Contrôle des valeurs vides #####
cat(
  utf82LaTeX(
    "\\subsubsection{Contrôle des valeurs vides dans les colonnes clés (NumForet, Nom, Code)}"
  )
)

pos <- c()
for (name in c("NumForet", "Nom", "Code")) { #, "CodeIFN"
  pos <- unique(c(pos, which(is.na(Essences[, name]))))
}

if (length(pos) > 0) {
  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) dans la table 'Essences'."
    )
  )
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Les colonnes Nom, Code ne présentent pas de valeur vide."
    )
  )
}


##### 2/ Contrôle de la cohérence avec les tables d'inventaire #####
cat(utf82LaTeX("\\subsubsection{Contrôle sur les listes d'essence inventoriées}"))
cat(
  utf82LaTeX(
    "Principe : toutes les essences rencontrées dans l'inventaire doivent figurer dans la table Essences"
  )
)

cat(utf82LaTeX("\\paragraph{Essences de la table Arbres}"))
Test <- Test + Controle_Essence(Arbres, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table Reges}"))
Test <- Test + Controle_Essence(Reges, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table PCQM}"))
Test <- Test + Controle_Essence(PCQM, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table Cercles}"))
Test <- Test + Controle_Essence(Cercles, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table BMSLineaires}"))
Test <- Test + Controle_Essence(BMSLineaires, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table BMSCercles}"))
Test <- Test + Controle_Essence(BMSCercles, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table Tarifs}"))
Test <- Test + Controle_Essence(Tarifs, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table AccD}"))
Test <- Test + Controle_Essence(AcctD, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table EssReg}"))
Test <- Test + Controle_Essence(EssReg, Essences)
cat(utf82LaTeX("\\paragraph{Essences de la table EssInd}"))
Test <- Test + Controle_Essence(EssInd, Essences)

##### 3/ Contrôle des valeurs dupliquées #####
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))

pos <- which(duplicated(Essences[, "Nom"]))
if (length(pos) > 0) {
  Test = ifelse(Test >= 2, Test, 2)
  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Essences ligne(s) : ", 
      paste0(pos, collapse = ", "), "\\\\"
    )
  )

  t <- Essences[pos, ]
  t
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table Essences"))
}


# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

\subsection{Table EssReg}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{Contrôle des essences : pas grave si il y a des regroupements d'essence supplémentaires renseignés dans la table + indiquer que si pas de regroupement, on prend ceux par défaut (en faire la liste)}}{}
<<EssReg, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(EssReg)[1]) {
  ##### 1/ Présentation des regroupements #####
  cat(utf82LaTeX("\\subsubsection{Liste des regroupements}"))

  # pos <- which(EssReg$NumForet == forest_num)
  # if (length(pos) == 0) {
  #   Test <- ifelse(Test > 0, Test, 1)
  #   cat(
  #     utf82LaTeX(
  #       "\\textcolor{Blue}{\\textbf{Remarque}} - Aucun regroupement d'essences renseigné pour cette forêt."
  #     )
  #   )
  # } else {
  #   cat(
  #     utf82LaTeX(
  #       "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Des regroupements d'essence ont été renseignés pour cette forêt :\\\\
  #
  #                  "
  #     )
  #   )

  t <-
    EssReg[, c("Essence", "EssReg")] %>%
    # EssReg[pos, c("Essence", "EssReg")] %>%
    distinct() %>% rename("Regroupement d'essences" = "EssReg")

  print(
    xtable(
      t, 
      caption = "\\footnotesize{Liste des regroupements d'essences renseignés pour cette forêt}", 
      caption.placement = "bottom", 
      digits = rep(0, dim(t)[2]+1), 
      align = c("l", "|M{3cm}|", rep("M{3cm}|", dim(t)[2] - 1)), 
      label = "TabEssReg"), 
    include.rownames = FALSE, 
    include.colnames = TRUE, 
    floating = T, 
    hline.after = c(-1:dim(t)[1]
    ), 
    sanitize.text.function = function(x) {return(x)}, 
    size = "\\scriptsize"
  )
  # }

  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences inventoriées dans la table}"))

  Test <- Test + Controle_Essence(EssReg)
  cat("\\FloatBarrier ")

  ##### 2/ Contrôle des valeurs dupliquées #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  EssReg <- EssReg %>% arrange(NumForet, Essence, EssReg)
  pos1 <- which(duplicated(EssReg[, c("NumForet", "Essence")]))
  pos2 <- which(duplicated(EssReg[, c("NumForet", "Essence")], fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) for (i in 1:length(pos1)) {Dupl <- c(Dupl, pos2[i]:pos1[i])}

  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(Dupl) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'EssReg' : "
        )
      )
      df <- EssReg[Dupl, ]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'EssReg'}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{3cm}|", ncol(df) - 1)), 
          label = "TabDoublon_EssReg"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'EssReg' : ", 
          length(Dupl), " doublons détectés."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'EssReg'."
      )
    )
  }

  ##### 3/ Absence de valeurs #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  pos <-
    unique(which(is.na(EssReg$Essence) | is.na(EssReg$Essence) | is.na(EssReg$EssReg)))
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)

    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des valeurs vides dans la table 'EssReg' :"
        )
      )

      df <- EssReg[pos, ]

      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des valeurs vides de la table 'EssReg'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissEssReg"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des valeurs vides dans la table 'EssReg' : ", 
          length(pos), " erreurs détectées."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table 'EssReg' ne contient pas de valeur vide."
      )
    )
  }

  ##### 4/ Contrôle de la cohérence avec les tables d'inventaire #####
  cat(utf82LaTeX("\\subsubsection{Contrôle sur les listes d'essence inventoriées}"))
  cat(
    utf82LaTeX(
      "Principe : toutes les essences rencontrées dans l'inventaire doivent figurer dans la table EssReg"
    )
  )

  cat(utf82LaTeX("\\paragraph{Essences de la table Arbres}"))
  Test <- Test + Controle_Essence(Arbres, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table Reges}"))
  Test <- Test + Controle_Essence(Reges, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table PCQM}"))
  Test <- Test + Controle_Essence(PCQM, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table Cercles}"))
  Test <- Test + Controle_Essence(Cercles, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table BMSLineaires}"))
  Test <- Test + Controle_Essence(BMSLineaires, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table BMSCercles}"))
  Test <- Test + Controle_Essence(BMSCercles, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table Tarifs}"))
  Test <- Test + Controle_Essence(Tarifs, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table AccD}"))
  Test <- Test + Controle_Essence(AcctD, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table EssReg}"))
  Test <- Test + Controle_Essence(EssReg, EssReg, column = "Essence")
  cat(utf82LaTeX("\\paragraph{Essences de la table EssInd}"))
  Test <- Test + Controle_Essence(EssInd, EssReg, column = "Essence")

  ##### Fin #####
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}
@
\FloatBarrier

\subsection{Table EssInd}
<<EssInd, results = 'asis', eval = T, include = T>>=
Test = 0

if (dim(EssInd)[1] > 0) {
  ##### 1/ Présentation des regroupements #####
  # cat(
  #   utf82LaTeX(
  #     "\\subsubsection{Liste des essences à individualiser (feuille EssInd)}"
  #   )
  # )
  #
  # pos <- which(EssInd$NumForet == forest_num)
  # if (length(pos) == 0) {
  #   Test <- ifelse(Test > 0, Test, 1)
  #   cat(
  #     utf82LaTeX(
  #       "\\textcolor{Blue}{\\textbf{Remarque}} - Aucun regroupement d'essences renseigné pour cette forêt."
  #     )
  #   )
  # } else {
  #   cat(
  #     utf82LaTeX(
  #       "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Des essences à individualiser ont été renseignées pour cette forêt :\\\\
  #
  #                  "
  #     )
  #   )

  t <- unique(EssInd[, "Essence"])
  # t <- unique(EssInd[pos, "Essence"])
  Vector2Table_Print(
    t, 
    "Liste des essences à individualiser renseignées pour cette forêt.", 
    "TabEssInd"
  )
  # }

  ##### 2/ Contrôle des essences renseignées #####
  cat(utf82LaTeX("\\subsubsection{Contrôle sur les essences listées dans la table}"))
  Test <- Test + Controle_Essence(EssInd)
  cat("\\FloatBarrier ")

  ##### 3/ Contrôle des valeurs dupliquées #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  EssInd <- EssInd %>% arrange(NumForet, Essence)
  pos1 <- which(duplicated(EssInd))
  pos2 <- which(duplicated(EssInd, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'EssInd' : "
        )
      )
      df <- EssInd[Dupl, ]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des doublons dans la table 'EssInd'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df) + 1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabDoublon_EssInd"
        ), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
      cat("\\FloatBarrier
        ")
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
          length(Dupl), " doublons détectés."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'EssInd'."
      )
    )
  }

  ##### 4/ Contrôle des valeurs vides #####
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))

  pos <- unique(which(is.na(EssInd$NumForet) | is.na(EssInd$Essence)))
  if (length(pos) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(pos) <= 20) {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des valeurs vides dans la table 'EssInd' :"
        )
      )
      df <- EssInd[pos, ]
      print(
        xtable(
          df, 
          caption = "\\footnotesize{Liste des valeurs vides de la table 'EssInd'.}", 
          caption.placement = "bottom", 
          digits = rep(0, ncol(df)+1), 
          align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df) - 1)), 
          label = "TabMissEssInd"), 
        include.rownames = FALSE, 
        include.colnames = TRUE, 
        hline.after = c(-1:nrow(df)), 
        size = "\\scriptsize"
      )
    } else {
      cat(
        utf82LaTeX(
          "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des valeurs vides dans la table 'EssInd' : ", 
          length(pos), " erreurs détectées."
        )
      )
    }
  } else {
    cat(
      utf82LaTeX(
        "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table 'EssInd' ne contient pas de valeur vide."
      )
    )
  }


  ##### Fin #####
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat("\\begin{center}
\\textcolor{blue}{\\textbf{Aucune donnée renseignée}}
\\end{center}
                    ")
}

@
\FloatBarrier

\subsection{Table Prix}
\textcolor{red}{TODO : controle des essences de la feuille Prix}
<<Prix, echo = FALSE, comment = NA, warning = FALSE, results = 'asis'>>=
Test = 0

##### 1/ Contrôle des valeurs vides #####
cat(
  utf82LaTeX(
    "\\subsubsection{Contrôle des valeurs vides}"
  )
)

pos <- c()
for (name in c("Essence", "Classe", "Qual", "PU")) {
  pos <- unique(c(pos, which(is.na(Prix[, name]))))
}

if (length(pos) > 0) {
  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) dans la table 'Prix'."
    )
  )
} else {
  cat(
    utf82LaTeX(
      "\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Les colonnes Essence, Nom, Latin et EssReg ne présentent pas de valeur vide."
    )
  )
}


##### 3/ Contrôle des valeurs dupliquées #####
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))

pos <- which(duplicated(Prix))
if (length(pos) > 0) {
  cat(
    utf82LaTeX(
      "\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table Prix ligne(s) :", 
      paste0(pos, collapse = ", "), "\\\\"
    )
  )

  t <- Prix[pos, ]
  t
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table Prix"))
}


# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

\subsection{Table CodeEcologie}
<<CodeEcologie, echo = F, comment = NA, warning = FALSE, results = 'asis'>>=
cat(utf82LaTeX("\\subsubsection{Contrôle codification}"))
Test = 0
pos <- is.na(CodeEcolos[which(!tolower(CodeEcolos$Codification) %in% c("prosilva", 
                                                                       "irstea", 
                                                                       "engref", 
                                                                       "efi")), ])
if (length(pos) > 0){
  Test <- 2
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Des codifications autres que celle de 'prosilva', 'engref', 'irstea' ou de l' 'efi' ont été détectés dans la table 'CodeEcologie'.")))
} else {
  cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Les codifications enregistrées dans la table CodeEcologie sont conformes\\\\
      Rappel : les seules codifications retenues sont 'prosilva', 'engref', 'irstea', 'efi').")
}


# Sécurité duplicata
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
pos <- which(duplicated(CodeEcolos))
if (length(pos) > 0) {
  Test <- 2
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table CodeEcologie ligne(s) : ", 
                        paste0(pos, collapse = ", "), 
                        ".")))
  #   t <- pander(CodeEcologie[pos, ])
  #     row.names(t) <- NULL
  #   panderOptions('table.split.cells', 10)
  #   panderOptions('table.split.table', 100)
  #
  #   return(pander(t))
  t <- CodeEcolos[pos, ]
  t
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table CodeEcologie.\\\\"))
}

# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

\subsection{Table CodeDurete}
<<CodeDurete, , echo = F, comment = NA, warning = FALSE, results = 'asis'>>=
cat(utf82LaTeX("\\subsubsection{Contrôle codification}"))
Test = 0
ref <- data.frame(
  Code = seq(1:5), 
  Descriptif = c(
    "Dur ou non altéré", 
    "Décomposition <1/4 du diamètre", 
    "Décomposition entre 1/4 et 1/2 du diamètre", 
    "Décomposition entre 1/2 et 3/4 du diamètre", 
    "Décomposition supérieure à 3/4."
  ), 
  stringsAsFactors = F
)
if(all.equal(CodeDurete, ref) != TRUE){
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - La table de codification 'CodeDurete' n'est pas conforme (fichier administrateur).\\\\")))
} else {
  cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table de codification CodeDurete est conforme.")
}

# Sécurité duplicata
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
pos <- which(duplicated(CodeDurete))
if (length(pos) > 0) {
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table CodeDurete ligne(s) : ", 
                        paste0(pos, collapse = ", "), 
                        "\\\\")))
  #   t <- pander(CodeDurete[pos, ])
  #     row.names(t) <- NULL
  #   panderOptions('table.split.cells', 10)
  #   panderOptions('table.split.table', 100)
  #
  #   return(pander(t))
  t <- CodeDurete[pos, ]
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table CodeDurete."))
}


# --- Contrôle des codes dureté rencontrés dans les autres tables.
cat(utf82LaTeX("\\subsubsection{Cohérence avec les stades de décomposition rencontrés dans l'inventaire}"))
Controle_Durete <- function(CodeDurete, Table, Test) {
  pos <- which(!is.element(Table$StadeD, c(NA, CodeDurete$Code)))
  if (length(pos) > 0) {
    Test <- 2
    if (length(pos) <= 20) {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) de décomposition non conforme(s) détecté(s) dans la table ", deparse(substitute(Table)), " :")))
      df <- Table[pos, c(1:4, match("StadeD", names(Table)))]
      print(xtable(df, 
                   caption = paste0("\\footnotesize{Liste des stades de décomposition non reconnus dans la table ", deparse(substitute(Table)), "}"), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = paste0("Tab-", deparse(substitute(Table)))), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")

    } else {
      # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans le PSDRF :"))
      cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) de décomposition non conforme(s) détecté(s) dans la table ", 
                     deparse(substitute(Table)), 
                     " : ", length(pos), " erreurs détectées."))
    }
  } else {
    cat(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes de décomposition rencontrés dans la table ", deparse(substitute(Table)), " sont conformes."))
  }
  return(Test)
}




# cat("\\paragraph{Stades de décomposition de la feuille 'Arbres'}")
# Test <- Controle_Durete(CodeDurete, Arbres, Test)
# cat("\\FloatBarrier ")
#
# cat("\\paragraph{Stades de décomposition de la feuille 'BMSsup30'}")
# Test <- Controle_Durete(CodeDurete, BMSsup30, Test)
# cat("\\FloatBarrier ")
#
# cat("\\paragraph{Stades de décomposition de la feuille 'Transect'}")
# Test <- Controle_Durete(CodeDurete, Transect, Test)
# cat("\\FloatBarrier ")



# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

\subsection{Table CodeEcorce}
<<CodeEcorce, , echo = F, comment = NA, warning = FALSE, results = 'asis'>>=
cat(utf82LaTeX("\\subsubsection{Contrôle codification}"))
Test = 0
ref <- data.frame(Code = seq(1:4), 
                  Descriptif = c("Présente sur tout le billon", "Présente sur plus de 50% de la surface", 
                               "Présente sur moins de 50% de la surface", "Absente du billon"), 
                  stringsAsFactors = F)
if(all.equal(CodeEcorce, ref) != TRUE){
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - La table de codification 'CodeEcorce' n'est pas conforme (fichier administrateur).")))
} else {cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table de codification CodeEcorce est conforme.")}


# Sécurité duplicata
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
pos <- which(duplicated(CodeEcorce))
if (length(pos) > 0) {
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table CodeEcorce ligne(s) : ", 
                        paste0(pos, collapse = ", "), 
                        ".")))
  #   t <- pander(CodeEcorce[pos, ])
  #     row.names(t) <- NULL
  #   panderOptions('table.split.cells', 10)
  #   panderOptions('table.split.table', 100)
  #
  #   return(pander(t))
  t <- CodeEcorce[pos, ]
  t
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table CodeEcorce."))
}

# --- Contrôle des codes écorce rencontrés dans les autres tables.
cat(utf82LaTeX("\\subsubsection{Cohérence avec les stades écorce rencontrés dans l'inventaire}"))
Controle_Ecorce <- function(CodeEcorce, Table, Test) {
  pos <- which(!is.element(Table$StadeE, c(NA, CodeEcorce$Code)))
  if (length(pos) > 0) {
    Test <- 2
    if (length(pos) <= 20) {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) écorce non conforme(s) détecté(s) dans la table ", deparse(substitute(Table)), " :")))
      df <- Table[pos, c(1:4, match("StadeE", names(Table)))]
      print(xtable(df, 
                   caption = paste0("\\footnotesize{Liste des stades écorce non reconnus dans la table ", deparse(substitute(Table)), "}"), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = paste0("Tab-", deparse(substitute(Table)))), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")

    } else {
      # cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il y a des BMP classés en 'Souche' et faisant plus d'1, 30m. Impossible dans le PSDRF :"))
      cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Stade(s) écorce non conforme(s) détecté(s) dans la table ", 
                     deparse(substitute(Table)), 
                     " : ", length(pos), " erreurs détectées."))
    }
  } else {
    cat(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Tous les codes écorce rencontrés dans la table ", deparse(substitute(Table)), " sont conformes"))
  }
  return(Test)
}




# cat("\\paragraph{Stades de décomposition de la feuille 'Arbres'}")
# Test <- Controle_Ecorce(CodeEcorce, Arbres, Test)
# cat("\\FloatBarrier ")
#
# cat("\\paragraph{Stades de décomposition de la feuille 'BMSsup30'}")
# Test <- Controle_Ecorce(CodeEcorce, BMSsup30, Test)
# cat("\\FloatBarrier ")
#
# cat("\\paragraph{Stades de décomposition de la feuille 'Transect'}")
# Test <- Controle_Ecorce(CodeEcorce, Transect, Test)
# cat("\\FloatBarrier ")
# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

\subsection{Table CodeTypoArbres}
<<CodeTypoArbres, , echo = F, comment = NA, warning = FALSE, results = 'asis', include = F, eval = F>>=
cat(utf82LaTeX("\\subsubsection{Contrôle codification}"))
Test = 0
ref <- data.frame(
  Code = c("A", "C", "S"), 
  Descriptif = c(
    "Arbres", "Chandelles", "Souches"
    ), 
  stringsAsFactors = F
)
if (all.equal(CodeTypoArbres[, 1:2], ref) != T) {
  Test = 2
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - La table de codification 'CodeTypoArbres' n'est pas conforme.")))
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - La table de codification 'CodeTypoArbres' est conforme"))
}


# Sécurité duplicata
cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
pos <- which(duplicated(CodeTypoArbres))
if (length(pos) > 0) {
  cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table CodeTypoArbres ligne(s) :", 
                        paste0(pos, collapse = ", "))))
  #   t <- pander(CodeTypoArbres[pos, ])
  #     row.names(t) <- NULL
  #   panderOptions('table.split.cells', 10)
  #   panderOptions('table.split.table', 100)
  #
  #   return(pander(t))
  t <- CodeTypoArbres[pos, ]
  t
  cat("\\FloatBarrier
      ")
} else {
  cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table CodeTypoArbres"))
}

# ---------- Fin ---------- #
if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
@
\FloatBarrier

% \subsection{Table BOBIBE}
% \textcolor{red}{A voir si vérification utile ? - laisser en suspens pour l'instant.}
% \FloatBarrier
\subsection{Table Listes}
\EditIf{\Sexpr{Dev}}{TRUE}{\textcolor{red}{A vérifier en lien avec la table Echantillonnages - contrôler notation Ssplac de régé, types de BM disponibles, Types de Tiers, dénomination des Quarts pour le PCQM}}{}
<<Listes, echo = FALSE, comment = NA, warning = FALSE, results = 'asis', eval = T, include = T>>=
Test = 0


if (dim(Listes)[1] > 0) {
  # --- Repérages des vides
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs vides}"))
  cat(utf82LaTeX("\\paragraph{Variables indispensables à l'analyse des données}"))
  # Contrôle des valeurs vides des variables :
  ListName <- c()
  for (name in names(Listes)) {
    pos <- which(is.na(Listes[, name]))
    if (length(pos) > 0) {ListName <- c(ListName, name)}
  }
  Vital <- c()
  Annexe <- c()

  if (length(ListName) > 0) {
    Vital <- ListName[ListName %in% c("NumForet")]
    Annexe <- ListName[!ListName %in% c("NumForet")]
    # --- Variables "vitales"
    if (length(Vital) > 0) {
      Test = ifelse(Test >= 2, Test, 2)
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Vital, 
                                   collapse = ", "))))

      df <-
        Listes %>%
        gather(var, value, Vital) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Vital, "NumForet"), data = Listes, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Vital) == 1) {
        df <- df[which(df[, paste0(Vital, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Vital, ".NbreVides")]) != 0, ]
      }
      # Impression de la table
      # if (nrow(df) <= 20) {
      if (!is.element("NumForet", Vital)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Vital, ".NbreVides")] <- paste0(Vital, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", indispensables à l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissVital_Listes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- utf82LaTeX(paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)]))
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                      utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes indispensables à l'analyse des données (", 
      #                             paste0(Vital, collapse = ", "), 
      #                             ")."), 
      #                      "TabMissVital_Listes"))
      #   cat("\\FloatBarrier
      #       ")
      # }
    } else {
      Vital <- c("NumForet")
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables indispensables à l'analyse des données (", 
                            paste0(Vital, collapse = ", "), ")")))
    }
    # --- Variables "annexes"
    cat(utf82LaTeX("\\paragraph{Variables non indispensables à l'analyse des données}"))
    if (length(Annexe) > 0) {
      Test = ifelse(Test > 1, Test, 1)
      cat(utf82LaTeX(paste0("\\textcolor{Blue}{\\textbf{Remarque}} - Il manque des informations (vides) au(x) colonne(s) ", 
                            paste0(Annexe, 
                                   collapse = ", "))))

      df <-
        Listes %>%
        gather(var, value, Annexe) %>%
        mutate(var = paste0(var, ".NbreVides")) %>%
        group_by(NumForet, var) %>%
        summarise(value = length( which(is.na(value)) )) %>%
        ungroup() %>%
        spread(var, value, drop = F)
      # df <- summaryBy(list(Annexe, "NumForet"), data = Listes, FUN = function(x) length(which(is.na(x))), 
      #                 fun.names = "NbreVides")
      if (length(Annexe) == 1) {
        df <- df[which(df[, paste0(Annexe, ".NbreVides")] != 0), ]
      } else {
        df <- df[rowSums(df[, paste0(Annexe, ".NbreVides")]) != 0, ]
      }

      # Impression de la table
      # if (ncol(df) <= 20) {
      if (!is.element("NumForet", Annexe)) {
        df <- select(df, -NumForet)
      }
      names(df)[names(df) %in% paste0(Annexe, ".NbreVides")] <- paste0(Annexe, " : nombre de vides")
      print(xtable(df, 
                   caption = utf82LaTeX(paste0("\\footnotesize{Vides constatés dans les variables ", 
                                               paste0(Vital, collapse = ", "), 
                                               ", non indispensables dans l'analyse des données.}")), 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{2.0cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabMissAnnexe_Listes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
          ")
      # } else {
      #   ListDisp_Verif <- unique(df$NumForet)
      #   ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      #   Vector2Table_Print(ListDisp_Verif, 
      #                     utf82LaTeX(paste0("Liste des dispositifs ayant des valeurs manquantes dans les colonnes non indispensables à l'analyse des données (", 
      #                             paste0(Annexe, collapse = ", "), 
      #                             ").")), 
      #                      "TabMissAnnexe_Listes")
      #   cat("\\FloatBarrier
      #       ")
      # }


    } else {
      Vital <- c("NumForet")
      Annexe <- names(Listes)[!names(Listes) %in% c(Vital, "Observations")]
      cat(utf82LaTeX(paste0("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans les variables non indispensables à l'analyse des données (", 
                            paste0(Annexe, collapse = ", "), ")")))
    }
  } else {
    cat(utf82LaTeX("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Il n'y a aucune valeur vide dans la table 'Listes'"))
  }



  # ---------- Contrôle des valeurs dupliquées : ---------- #
  cat(utf82LaTeX("\\subsubsection{Contrôle des valeurs dupliquées}"))
  Listes <- arrange(Listes, 
                    NumForet, Descriptif_Liste)
  pos1 <- which(duplicated(Listes))
  pos2 <- which(duplicated(Listes, fromLast = T))

  Dupl <- c()
  if (length(pos1) > 0) {
    for (i in 1:length(pos1)) {
      Dupl <- c(Dupl, pos2[i]:pos1[i])
    }
  }
  if (length(Dupl) > 0) {
    Test = ifelse(Test >= 2, Test, 2)
    if (length(Dupl) <= 20) {
      cat("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table 'Listes' : ")
      df <- Listes[Dupl, ]
      print(xtable(df, 
                   caption = "\\footnotesize{Liste des doublons dans la table 'Listes'}", 
                   caption.placement = "bottom", 
                   digits = rep(0, ncol(df)+1), 
                   align = c("l", "|M{1.5cm}|", rep("M{1.5cm}|", ncol(df)-1)), 
                   label = "TabDoublon_Listes"), 
            include.rownames = FALSE, 
            include.colnames = TRUE, 
            hline.after = c(-1:nrow(df)), 
            size = "\\scriptsize")
      cat("\\FloatBarrier
        ")
    } else {
      cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - information dupliquée dans la table : ", 
                            length(Dupl), 
                            " doublons détectés.")))
      # ListDisp_Verif <- unique(Listes$NumForet[Dupl])
      # ListDisp_Verif <- paste0(ListDisp_Verif, "-", Dispositifs$Nom[match(ListDisp_Verif, Dispositifs$NumForet)])
      #
      # Vector2Table_Print(ListDisp_Verif, 
      #                    "Liste des dispositifs de la base PSDRF ayant des informations dupliquées dans la table Listes", 
      #                    "TabDoublon_Listes")
      # cat("\\FloatBarrier
      #     ")
    }
  } else {
    cat("\\textcolor{ForestGreen}{\\textbf{Vérifié}} - Aucun doublon détecté dans la table 'Listes'\\\\

      ")
  }




  # ----- Vérification du contenu de la table Listes avec d'autres tables
  # --- Notation SsPlac Régé :
  Rege_SsPlac <- unique(Reges$SsPlac)
  v_temp <- Listes$Attribut[Listes$Liste == "ListeSsPlac"]
  tests <- which(!Rege_SsPlac %in% v_temp)
  if (length(tests) > 0) {
    Test = 2
    cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - des notations de sous-placettes de la table 'Reges' ne sont pas cohérentes avec les informations de la table 'Listes' (utilisée comme référence) : '", 
                          paste0(Rege_SsPlac[tests], 
                                 collapse = "', '"), "'\\\\

                          ")))
  }

  # --- Notation Quarts de PCQM :
  PCQM_Quart <- unique(PCQM$Quart)
  v_temp <- Listes$Attribut[Listes$Liste == "ListeQuart"]
  tests <- which(!PCQM_Quart %in% v_temp)
  if (length(tests) > 0) {
    Test = 2
    cat(utf82LaTeX(paste0("\\textcolor{red}{\\textbf{Correction nécessaire}} - des notations de sous-placettes de la table 'Reges' ne sont pas cohérentes avec les informations de la table 'Listes' (utilisée comme référence) : '", 
                          paste0(PCQM_Quart[tests], 
                                 collapse = "', '"), "'\\\\

                          ")))
  }



  # ---------- Fin ---------- #
  if (Test == 0) {cat("\\begin{center}
                    \\textcolor{ForestGreen}{\\textbf{Table vérifiée - Pas d'anomalie détectée}}
                    \\end{center}
                    ")}
  if (Test == 1) {cat("\\begin{center}
                    \\textcolor{blue}{\\textbf{La table peut contenir des irrégularités (cf remarques)}}
                    \\end{center}
                    ")}
  if (Test >= 2) {cat("\\begin{center}
                    \\textcolor{red}{\\textbf{La table contient des erreurs = corrections nécessaires}}
                    \\end{center}
                    ")}
} else {
  cat(utf82LaTeX("\\textcolor{red}{\\textbf{Correction nécessaire}} - Aucune information de tarif renseignée pour le dispositif"))
}
@
\FloatBarrier

\end{document}
