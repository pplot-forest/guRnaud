)
# }
# gf_AgregArbres call
# (pour le dispositif en cours d'analyse uniquement)
# print(paste0("complete_progress : ", complete_progress)) # debug
gf_AgregArbres(
wd = rv$wd,
output_dir = rv$rep_sav$GF_report,
combination_table = results_by_plot_to_get,
forest = rv$forest,
last_cycle = rv$last_cycle,
complete_progress = complete_progress,
i18n = i18n
)
# gf_AgregPlacettes call
gf_AgregPlacettes(
wd = rv$wd,
output_dir = rv$rep_sav$GF_report,
combination_table = results_by_stand_to_get,
forest = rv$forest, last_cycle = rv$last_cycle,
complete_progress = complete_progress,
i18n = i18n
)
# } end of 'build tables' function # TODO : construire une nouvelle version ?
}) # end of withProgress
show_alert(
title = i18n()$t("Calculs des résultats termin\u00E9s !!"),
text = i18n()$t("Calculs des résultats termin\u00E9s et archiv\u00E9s"),
type = "success"
)
# })
}
}) # end of observeEvent
# # -- bouton 'calcul des résultats' - calcul des variables par arbres, placettes et ensembles (package PermGF)
# observeEvent(input$edit_GF_report, {
#
#   # -- répertoire de travail
#   wd <- parseDirPath(ui_volumes, input$directory)
#   # wd <- "/Users/Valentin/Travail/Outils/GitHub/PermGF2" # debug
#
#   # -- chargement des données
#   # chemins relatifs des archives
#   admin_arch <- "tables/gfCodes.Rdata"
#
#   # création d'un nouvel environnement et chargement
#   db = new.env()
#   # db = globalenv()
#   # print(str(db))
#   load( file.path(wd, admin_arch) , db) # TODO : à améliorer - supprimer chargements inutiles ! # to load Dispositif + Cycles
#   forest <- input$stand_select
#
#   with(db, {
#     # -- gestion des noms et num du dispositif
#     forest_num <- as.numeric(str_sub(forest, 1, str_locate(forest, "-")[, 1] - 1)) #changement2
#     forest_name <-
#       with(Dispositifs, Nom[match(forest_num, NumDisp)])
#
#     # -- arguments relatifs au dispositifs
#     last_cycle <-
#       with(Cycles, max(Cycle[NumDisp == forest_num], na.rm = T))
#     last_year <-
#       with(Cycles, Annee[NumDisp == forest_num & Cycle == last_cycle])
#
#     if (length(last_year) > 1) {
#       stop("Correction du classeur administrateur nécessaire : il y a 2 années identiques renseignées dans la feuille Cycles")
#     }
#
#     # -- création du dossier de sortie
#     output_dir <- file.path("out", forest, "livret_GF")
#     dir.create(output_dir, showWarnings = F, recursive = T)
#
#     # -- définition des arguments nécessaires au knit
#     repPdf <- file.path(wd, output_dir)
#     repLogos <- file.path(wd, "data/images/logos/")
#     repFigures <- file.path(repPdf, "figures/")
#
#     # -- superassignements
#     # répertoire de sauvegarde pour les tables spécifiques du dispositif
#     rep_sav <<- dirname(repPdf)
#     # nom de la sortie en .tex
#     output_filename <- paste0(forest_num, "_livret-GF_", last_year, ".tex")
#     output <<- file.path(repPdf, output_filename)
#   })
#
#   template <- "gf_Livret_2020.Rnw"
#   # TODO : supprimer les messages de joining by
#
#   # output !!
#   output$report = downloadHandler(
#     filename = "/Users/Valentin/Travail/Outils/GitHub/PermGF2/out/1-Bois des Brosses/livret_GF/1_livret-GF_2018.pdf",
#
#     content = function(file) {
#       out = knit2pdf(
#         "/Users/Valentin/Travail/Outils/GitHub/PermGF2/template/gf_Livret_2020.Rnw",          clean = TRUE,
#         output = "/Users/Valentin/Travail/Outils/GitHub/PermGF2/out/1-Bois des Brosses/livret_GF/1_livret-GF_2018.tex",
#         compiler = "pdflatex",
#         quiet = TRUE,
#         envir = db
#         )
#       file.rename(out, file) # move pdf to file for downloading
#     },
#
#     contentType = 'application/pdf'
#   )
#
#   # knit2pdf(
#   #   input = file.path(wd, "template", template),
#   #   output = output,
#   #   compiler = "pdflatex",
#   #   quiet = TRUE,
#   #   envir = db
#   # )
#
#   print(file.path(wd, "template", template))
#   print(output)
# }) # end of observeEvent
# db1 <- reactive({
#   # créer une réactive value pour le répertoire admin ?
#   wd = parseDirPath(ui_volumes, input$directory)
#   # wd <- "/Users/Valentin/Travail/Outils/GitHub/PermGF2" # debug
#
#   # -- chargement des données
#   # chemins relatifs des archives
#   admin_arch = "tables/gfCodes.Rdata"
#
#   # -- chargement des données
#   # chemins relatifs des archives
#   tables_list_arch <- file.path(wd, "tables/report_tables_list.Rdata")
#   inventory_arch <- file.path(wd, "tables/gfDonneesBrutes.Rdata")
#   admin_arch <- file.path(wd, "tables/gfCodes.Rdata")
#   dictionary_arch <- file.path(wd, "tables/gf_dictionary.Rdata")
#
#   # création d'un nouvel environnement et chargement
#   # db = new.env()
#   # db = globalenv()
#   # print(str(db))
#
#   # load(tables_list_arch)
#   # tables <- load(inventory_arch)
#   # load(admin_arch)
#   # load(dictionary_arch, db)
# })
# output$data <- renderDataTable({
#   data.frame(
#     wd = rv$rep_pdf,
#     forest = rv$forest,
#     forest_num = rv$forest_num,
#     last_cycle = rv$last_cycle,
#     last_year = rv$last_year
#   )
#   # rep
# })
output$text <- renderPrint({
# rv$wd
input$stand_select
# wd()
})
# reactive expression - répertoire de travail 'wd'
wd <- reactive( parseDirPath(ui_volumes, input$directory) )
# reactive values -----
# rv <- reactiveValues()
# react to input$directory - doublon avec wd() reactive expression
# observeEvent(input$directory, {
#   # sécurité pour éviter trigger pendant que sélection du répertoire est en cours
#   if (!is.null(wd()) & length(wd()) != 0) {
#
#     # -- chemin du répertoire administrateur
#     rv$wd <- parseDirPath(ui_volumes, input$directory)
#     # print(paste0("wd = ", rv$wd)) # debug
#     # wd <- "/Users/Valentin/Travail/Outils/GitHub/PermGF2" # debug
#   }
# }, ignoreInit = TRUE)
# react to input$directory
observeEvent(input$load_data, {
# sécurité répertoire administrateur
if (is.null(wd()) | !length(wd())) { # cond 'is.null(wd()) | !length(wd())'
show_alert(
title = i18n()$t("Aucun répertoire administrateur sélectionné"),
text = i18n()$t("Choisir un répertoire administrateur avant de commencer le traitement de données"),
type = "error"
)
} else { # else of cond 'is.null(wd()) | !length(wd())'
# -- chargement des données
# sécurité présence du répertoire tables
if (!"tables" %in% list.files(wd())) { # cond '!"tables" %in% list.files(wd())'
show_alert(
title = i18n()$t("Dossier 'tables' manquant"),
text = i18n()$t("Il doit exister un dossier 'tables' contenant les archives des données inventaire et administrateur"),
type = "error"
)
# dir.create(file.path(wd, "tables"), showWarnings = F)
} else { # else of cond '!"tables" %in% list.files(wd())'
# -- sécurité présence des Rdata nécessaires
all_arch_present <- 1
missing_arch <- arch_list[ which(!arch_list %in% list.files(file.path(wd(), "tables"))) ]
if (length(missing_arch) > 0) { # cond 'length(missing_arch) > 0'
all_arch_present <- 0
if (length(missing_arch) == 1) {
show_alert(
title = i18n()$t("Archive des données d'inventaire manquantes"),
text = paste0(
i18n()$t("Import/copie de fichiers nécessaire : l'archive "),
missing_arch,
i18n()$t(" doit figurer dans le dossier 'tables' pour pouvoir traiter les données.")
),
type = "error"
)
}
if (length(missing_arch) > 1) {
show_alert(
title = i18n()$t("Archives des données d'inventaire manquantes"),
text = paste0(
i18n()$t("Import/copie de fichiers nécessaire : les archives "),
missing_arch,
i18n()$t(" doivent figurer dans le dossier 'tables' pour pouvoir traiter les données.")
),
type = "error"
)
}
} # end of cond 'length(missing_arch) > 0'
# bascule la valeur 'all_arch_present' dans la reactive value
# -> évite de tout reload les dependents avec les tests de sécurité ci-dessus
rv$all_arch_present <- all_arch_present
if (rv$all_arch_present) { # cond 'all_arch_present'
# -- stands list
# stand num list
all_num_list <- sort( as.numeric( unique(data()[["IdArbres"]]$NumForet) ) )
# browser()
admin <- data()[["Forets"]] %>% filter(NumForet %in% all_num_list)
# stand label list & build rv
if (is.element(NA, all_num_list)) warning("NumForet vide d\u00E9tect\u00E9")
rv$all_forest_list <<- paste0(
all_num_list, "-", admin$Nom[match(all_num_list, admin$NumForet)]
)
# debug
# print(paste0("tables_list_rdata = ", rv$tables_list_rdata)) # debug
# print(paste0("inventory_rdata = ", rv$inventory_rdata)) # debug
# print(paste0("admin_rdata = ", rv$admin_rdata)) # debug
# print(paste0("dictionary_rdata = ", rv$dictionary_rdata)) # debug
# print(paste0("all_forest_list = ", paste0(rv$all_forest_list[1:3], collapse = ", "))) # debug
} else { # else of cond 'all_arch_present'
rv$all_forest_list <- NULL
} # end of cond 'all_arch_present'
} # end of cond '!"tables" %in% list.files(wd())'
} # end of cond 'is.null(wd()) | !length(wd())'
}) # end of 'observeEvent(input$load_data'
# react to input$stand_select
observeEvent(input$stand_select, {
# trigger security
if (input$stand_select != "") { # cond 'input$stand_select != ""' - trigger security
# -- définition du répertoire de travail (TODO : argument à supprimer ?)
rv$wd <- wd()
# -- gestion des noms et num du dispositif
# TODO : faire le tri des éléments à rendre vraiment réactifs
rv$forest <- input$stand_select
rv$forest_num <- as.numeric(str_sub(rv$forest, 1, str_locate(rv$forest, "-")[, 1] - 1))
# print(paste0("wd = ", wd())) # debug
rv$forest_name <-
with(data()[["Forets"]], Nom[match(rv$forest_num, NumForet)])
# browser()
# -- arguments relatifs au dispositif
rv$last_cycle <-
with(data()[["Cycles"]], max(Cycle[NumForet == rv$forest_num], na.rm = T))
rv$last_year <-
with(data()[["Cycles"]], Annee[NumForet == rv$forest_num & Cycle == rv$last_cycle])
if (length(rv$last_year) > 1) {
stop("Correction du classeur administrateur nécessaire : il y a 2 années identiques renseignées dans la feuille Cycles")
}
# -- création du dossier de sortie
rv$output_dir <- file.path("out", clean_names(rv$forest))
# -- définition des arguments nécessaires au knit
rv$rep_logos <- file.path(wd(), "data/images/logos") # non actif
rv$rep_pdf$check_report <- file.path(wd(), rv$output_dir, "rapport_verif")
rv$rep_pdf$GF_report <- file.path(wd(), rv$output_dir, "livret_GF")
rv$rep_figures$check_report <- file.path(rv$rep_pdf$check_report, "figures/")
rv$rep_figures$GF_report <- file.path(rv$rep_pdf$GF_report, "figures/")
rv$rep_sav$check_report <- dirname(rv$rep_pdf$check_report)
rv$rep_sav$GF_report <- dirname(rv$rep_pdf$GF_report)
# chemin du template (absolute path)
rv$template_path$check_report <- file.path(wd(), "template/gf_check_data_2023.Rnw")
rv$template_path$GF_report <- file.path(wd(), "template/gf_Carnet_2022.Rnw")
# nom de la sortie en .tex
# rv$output_filename$check_report <- paste0(rv$forest_num, "_verif_", rv$last_year, ".tex")
rv$output_filename$check_report <-
file.path( rv$rep_pdf$check_report, paste0(rv$forest_num, "_verif_", rv$last_year, ".tex") )
# rv$output_filename$GF_report <- paste0(rv$forest_num, "_livret-GF_", rv$last_year, ".tex")
rv$output_filename$GF_report <-
file.path( rv$rep_pdf$GF_report, paste0(rv$forest_num, "_livret-GF_", rv$last_year, ".tex") )
# debug
# print(paste0("rep_pdf = ", rv$rep_pdf)) # debug
# print(paste0("rep_logos = ", rv$rep_logos)) # debug
# print(paste0("rep_figures = ", rv$rep_figures)) # debug
# print(paste0("rep_figures (check report) = ", rv$rep_figures$check_report)) # debug
# print(paste0("rep_figures (livret GF) = ", rv$rep_figures$GF_report)) # debug
# print(paste0("rep_sav = ", rv$rep_sav)) # debug
# print(paste0("output_dir = ", rv$output_dir)) # debug
# print(paste0("template_path = ", rv$template_path)) # debug
# print(paste0("lang = ", rv$lang)) # debug
# print(rv$output_filename$GF_report) # debug
# print(rv$output_filename$check_report) # debug
} # end of cond 'input$stand_select != ""' - trigger security
}, ignoreInit = T)
# A VOIR
#   # -- création du dossier de sortie
#   dir.create(output_dir, showWarnings = F, recursive = T)
#
#   # -- définition des arguments nécessaires au knit
#
#   # -- superassignements
#   # # répertoire de sauvegarde pour les tables spécifiques du dispositif
#   # rep_sav <<- dirname(repPdf)
#   # nom de la sortie en .tex
#   output_filename <- paste0(forest_num, "_livret-GF_", last_year, ".tex")
#   output <<- file.path(repPdf, output_filename)
# })
data_set <- reactive({stand_updated <- paste0(input$stand_select, "coucou")})
# edit GF report
output$GF_report = downloadHandler(
filename = function() {
paste0(rv$forest_num, "_livret-GF_", rv$last_year, ".pdf")
},
content = function(file) {
# sécurité répertoire administrateur
if (is.null(rv$wd) | !length(rv$wd)) {
show_alert(
title = i18n()$t("Aucun répertoire administrateur sélectionné"),
text = i18n()$t("Choisir un répertoire administrateur avant de commencer le traitement de données"),
type = "error"
)
} else {
# TEST = data_set()
# rep <- rv$wd
# tk_messageBox(type = "ok", message = rv$template_path) # debug
# chargement des archives nécessaires au knit
# load( file.path(rv$rep_sav, "tables/gfTablesBrutes.Rdata") )
# load( file.path(rv$rep_sav, "tables/gfTablesElaboreesPlac.Rdata") )
# for(i in 1:length(results_by_plot)) {assign(names(results_by_plot)[i], results_by_plot[[i]])}
# load( file.path(rv$rep_sav, "/tables/gfTablesElaborees.Rdata") )
# for(i in 1:length(results_by_group)) {assign(names(results_by_group)[i], results_by_group[[i]])}
# TODO : filtrer les tables (avec "filter_by_forest" ?)
out = knit2pdf(
input = rv$template_path$GF_report,
output = rv$output_filename$GF_report,
compiler = "pdflatex",
quiet = TRUE,
# envir = data(), si data() choisi comme environnement, rajouter les éléments manquants à l'environnement data -> mieux définir figures (avec adresse de rep_pdf), i18n et sans doute d'autres
clean = TRUE
)
file.rename(out, file) # move pdf to file for downloading
}
},
contentType = 'application/pdf'
)
# boutons pour choisir les annexes du livret
output$import_data_box <- renderUI({
box(
title = i18n()$t("Import des données"),
status = "primary",
solidHeader = TRUE,
collapsible = TRUE,
collapsed = TRUE, # FALSE
width = 12,
# -- column 'admin data import'
# column(
#   width = 12,
#   style = "display:inline-block;width:50%",
#
#   div(
#     # -- text 'import des données administrateur'
#     column(
#       width = 12,
#       # div(
#       style = "display:inline-block;width:calc(100% - 150pt - 3em)",
#       strong(i18n()$t("Import des données administrateur :"))
#       # ),
#     ),
#
#     # -- bouton 'import des données administrateur'
#     column(
#       width = 12,
#       style = "display:inline-block;width:150pt",
#       actionButton(
#         inputId = "import_admin_data",
#         label = i18n()$t("Importer les données"),
#         width = "135pt"
#       )
#     )
#   ),
#
#   # -- bouton 'sélection des fichiers administrateurs'
#   column(
#     style = "display:inline-block;width:100%;padding:-10pt",
#     # style = "display:inline-block;border:1px solid;width:100%;",
#     width = 12,
#     shinyFilesButton(
#       id = "select_admin_files",
#       label = i18n()$t("Sélection des fichiers administrateurs"),
#       title = NULL,
#       multiple = TRUE
#     )
#   )
# ),
# -- column 'inventory data import'
column(
width = 12,
style = "display:inline-block;width:100%",
div(
# -- text 'import des données d'inventaire'
column(
width = 12,
# div(
style = "display:inline-block;width:30%",
strong(i18n()$t("Import des données d'inventaire :"))
# ),
),
# -- bouton 'sélection des fichiers d'inventaire'
column(
style = "display:inline-block;width:40%;",
# style = "display:inline-block;border:1px solid;width:100%;",
width = 12,
shinyFilesButton(
id = "select_inventory_files",
label = i18n()$t("Sélection des fichiers d'inventaire"),
title = NULL,
multiple = TRUE
)#,
# verbatimTextOutput("directorypath")
),
# -- bouton 'import des données d'inventaire'
column(
width = 12,
style = "display:inline-block;width:30%",
actionButton(
inputId = "import_inventory_data",
label = i18n()$t("Importer les données"),
width = "135pt"
)
)
) # end of div
)
)
})
# reactive value containing all parameters used to process results + edit GF report
}
project_repo <- dirname( rstudioapi::getSourceEditorContext()$path )
# -- création des objets nécessaire à l'application
# objet translator - pour reactive expression i18n
translator <- Translator$new(translation_json_path = file.path("../www/translations/translation.json"))
getwd()
runApp('inst')
project_repo <- dirname( rstudioapi::getSourceEditorContext()$path )
project_repo <- dirname(dirname( rstudioapi::getSourceEditorContext()$path ))
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
runApp('inst')
shiny::runApp('inst/shiny-app')
output_dir
source("~/Travail/Outils/GitHub/guRnaud/R/import_data_wb.R")
runApp('inst/shiny-app')
project_repo <- dirname(dirname( rstudioapi::getSourceEditorContext()$path ))
project_repo
project_repo <- dirname(dirname(dirname( rstudioapi::getSourceEditorContext()$path )))
# -- création des objets nécessaire à l'application
# objet translator - pour reactive expression i18n
translator <- Translator$new(translation_json_path = file.path("../../www/translations/translation.json"))
translator$set_translation_language("Français")
project_repo <- dirname(dirname(dirname( rstudioapi::getSourceEditorContext()$path )))
project_repo
# -- création des objets nécessaire à l'application
# objet translator - pour reactive expression i18n
translator <- Translator$new(translation_json_path = file.path("../../www/translations/translation.json"))
runApp('inst/shiny-app')
runApp('inst/shiny-app')
runApp('inst/shiny-app')
runApp('inst/shiny-app')
runApp('inst/shiny-app')
runApp('inst/shiny-app')
runApp('inst/shiny-app')
file.path(project_repo, "www/translations/translation.json")
runApp('inst/shiny-app')
devtools::document()
getwd()
devtools::build()
getwd()
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
devtools::build()
remove.packages("test")
?createStyle
?tk_select.list
??tk_select.list
library(tcltk)
tk_select.list(
choices = years_list,
preselect = years_list[length(years_list)],
multiple = F,
title = "Choisir une année d'inventaire"
)
library(tcltk2)
install.packages("easyclimate")
install.packages("lubridate")
install.packages("class")
install.packages("jpeg")
install.packages("png")
library(guRnaud)
